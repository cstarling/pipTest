/** @file DCM.idl
 * This file holds the general interface definition of the %DCM module.
 * 
 * @mainpage D C M
 * General interface definition for the %DCM Digital Content Manager.
 * This document describes the interface through Corba of the %DCM device.
 *
 * In the @ref intro you will find some explanation about the usage.
 *
 * @author Multiple.
 *
 * <B>Disclaimer:</B>
 *
 * Scientific-Atlanta, a Cisco Company Proprietary & Confidential Information.
 * Information in this document or any information it refers to shall not be disclosed or be made available in any form.
 * Information in this document or any information it refers to is provided "as is", without warranties or entitlement for support of other activities of any kind.
 * Information in this document and the %DCM interface it describes is subject to change at the sole discretion of Scientific-Atlanta, a Cisco Company. 
 * Information in this document and the %DCM interface it describes can change at any time and no compatibility between releases is guaranteed.
 *
 * &copy; Copyright 2007 by Scientific-Atlanta, a Cisco Company. All rights reserved.
 *
 * @htmlonly
 * @see <a href="http://sabekorlnx02/cgi-bin/cvsweb.cgi/Projects/DCM_IDL/DCM.idl"> CVS History </a>
 * @endhtmlonly
 * @latexonly
 * \newpage
 * @endlatexonly 
 */

#include "DCM_Types.idl"

module DCM
{
  
  /** DEFINES:
   * - Maximum number of supported TSs/ IO board is 500.
   * - Maximum number of supported TSs/GBE output port is 250.
   * - Maximum number of supported TSs/GBE input port is 500.
   * - It is possible to create 2000 TSs on a board respectively on a port but
   *   only 500 or 250 can be 'active streaming' 

   * - Maximum string length without terminating 0.
   *
   * - BoardNr = 0 is Main board
   * - The number of board locations a device has depends on the chassis type.
   *     For DCM 2RU MkI chassis: 4
   *     For DCM 1RU chassis: 2
   *     For DCM 2RU MkII chassis: 8
   *   Unless otherwise stated, board numbers range from 1 to the number of board locations.
   */

  const unsigned short MAX_ACTIVE_OUTPUT_TS_PER_BOARD = 500; /** Active streaming */
  const unsigned short MAX_ACTIVE_OUTPUT_TS_PER_PORT  = 250; /** Active streaming */
  const unsigned short MAX_OUTPUT_TS_PER_BOARD        = 2000;
  
  /** @page intro Introduction
   * @{
   *
   * IDL call implementation.
   *
   * In general commands are executed to the "up to first error" method.
   *
   * - Setting values will continue until the end of the list or an invalid
   *   record is encountered. The latter case will raise an exception
   * - Getting values will only succeed when all filter values are correct.
   *
   * Two examples:
   * - Calling IPS_OutTS_AddL to create new TSs, returns an OpNotSucceeded 
   *   exception and returns no newly created streams if the system already
   *   has 1998 TSs and you want to add 3 more. Two streams will be added however.
   *
   * - When calling the IPS_OutTS_GetL to obtain a list of outgoing TS, the BoardNr
   *   and SlotNr must exist. When a list of refs is supplied, all those refs must
   *   exist. If not an OpNotSucceeded will be raised. 
   *
   * %DCM architecture overview
   *
   *   @b Multiplexing
   *
   * - A TS is identified by a physical reference IPS_RefTS_t.
   * - BoardGetL_V2: Get a list of present boards in the device and their board type.
   * - Input:
   *   TS: IPS_InTS_GetL: Get a list of incoming transport streams
   *   Service: IPS_InServiceGetL: Get the list of services on an input TS that are 
   *       currently present in the incoming transport stream or passed to an output
   * - Output:
   *   TS on ASI: TS always exists
   *   TS on GbE IPS_OutTS_AddL: Create a number of TSs based on board defaults
   *        IPS_OutDefaultsSet(), IPS_OutDefaultsGet()
   *   Service: IPS_OutServiceAddL: Add a list of services to one or more outgoing TSs
   * .
   *   @b Scrambling
   *
   *   %DCM scrambler configuration and configuration of paremeters for communication with Conditional Access Systems (CAS) 
   *   can be done using the following calls.
   *   Details of these calls are listed in scrambler.idl and are available upon request.
   * - Scrambling configuration
   *    -# Scrambler settings.\n
   *        The IIOP call GetScsSettings can be used to get the global scrambler settings
   *        The IIOP call SetScsSettings can be used to set the global scrambler settings.
   *        This IIOP call takes the same parameters the previous one returns.  
   *    -# Proxy information.\n
   *        To connect with a simulcrypt device (EIS, ECMG) a proxy needs to be created on the DCM. 
   *        All simulcrypt proxies have a unique identifier (proxy_id). 
   *        This proxy_id is assigned to the proxy at construction time and can be used to address that specific proxy.
   *        The IIOP call GetInterfaceList will return all proxy_id's currently in use. These proxy_id's are listed per proxy type.
   *
   * - ECMG proxy.
   *    -# ECMG Proxy creation.\n
   *        A new ECMG proxy can be created by using the CreateEcmg IIOP call.  This call returns only one parameter:
   *        -  EcmgId  unique identifier (proxy_id) for newly created ECMG proxy. 
   *           This proxy_id needs to be used in all other IIOP calls concerning this proxy.
   *        An existing ECMG proxy can be removed by using the DeleteEcmg IIOP call. This call takes only one argument:
   *        -  EcmgId  unique identifier (proxy_id) for ECMG proxy
   *    -# ECMG Proxy configuration.\n
   *        Once a proxy has been created, it can be configured. The current configuration can be checked using the GetEcmgConfig IIOP call.
   *        An ECMG proxy can be configured by using the SetEcmgConfig IIOP call.\n
   *        Extra parameters can be configured for an ECMG proxy. 
   *        A lot of channel specific parameters (reported by a channel_status message between ECMG and scrambler) can be overruled. 
   *        Therefore the IIOP call SetEcmgOverrule can be used. 
   *        This overrule configuration can be checked with the GetEcmgOverrule IIOP call.
   *        Two more channel specific parameters can be overruled with the SetEcmgOverruleExt IIOP call.
   *        This extra overrule configuration can be checked with the GetEcmgOverruleExt IIOP call.
   *    -# ECMG Connections.\n
   *        The IIOP call GetConnList will return all ConnId's currently in use for a specific ECMG proxy. 
   *        This call takes only one argument:
   *        -  EcmgId  unique identifier (proxy_id) for ECMG proxy
   *        And will return a list of all used ConnId's:
   *        -  ConnIds  list of all ConnId's for ECMG proxy.
   * 
   *        - ECMG connection creation.\n
   *           A new connection can be created by the means of the CreateEcmgConn IIOP call. 
   *           An existing connection can be removed by using the DeleteEcmgConn IIOP call. 
   *        
   *        - ECMG connection configuration.\n
   *           Once an ECMG connection has been created, it can be configured. 
   *           The current configuration can be checked using the GetEcmgConnConfig IIOP call.
   *           An ECMG connection can be configured by using the SetEcmgConfig IIOP call. This call uses the same parameters as the get call.
   *          
   *        - Connection status.\n
   *           For every connection the status can be retrieved, by using the GetEcmgConnStatus IIOP call.
   * 
   *    -# ECMG status.\n
   *       The status of an ECMG proxy can be retrieved, by using the GetEcmgStatus IIOP call. This call takes only one argument:
   *        -  EcmgId  unique identifier (proxy_id) for ECMG proxy.
   *   
   *        
   *    -# Descriptor rules.\n
   *       Descriptor rules can be defined on proxy level. These rules can append private data to the CA descriptors. 
   *       A descriptor rule needs to be created and configured.
   *       Each descriptor rule has a unique identifier (DescRuleId), which is assigned to the descriptor rule at construction 
   *       time and can be used to address that specific descriptor rule.
   *    
   *       The IIOP call GetEcmgDescList will return all DescRuleId's currently in use for a specific ECMG proxy. This call takes only one argument:
   *       -  EcmgId  unique identifier (proxy_id) for ECMG proxy
   *       And will return a list of all used DescRuleId's:
   *       -  DescRuleIds  list of all DescRuleId's for ECMG proxy
   *   
   *      - Descriptor rule creation.\n
   *         A new descriptor rule can be created by the means of the CreateEcmgDescriptor IIOP call. This call takes only one argument:
   *         -  EcmgId  unique identifier (proxy_id) for ECMG proxy
   *         And will return one argument as well:
   *         -  DescRuleId  Unique identifier for newly created descriptor rule. 
   *         This DescRuleId needs to be used in all other IIOP calls concerning this proxy.\n      
   *         An existing descriptor rule can be removed by using the DeleteEcmgDescriptor IIOP call. 
   *      
   *      - Descriptor rule configuration.\n
   *         Once descriptor rule has been created, it can be configured. The current configuration can be checked using the GetEcmgDescriptor IIOP call.  
   *         This call takes two arguments:
   *         -  EcmgId  unique identifier (proxy_id) for ECMG proxy.
   *         -  DescRuleId  unique identifier for descriptor rule.\n
   *         A descriptor rule can be configured by using the SetEcmgDescriptor IIOP call. This call uses the same parameters as the get call.
   *
   *    -# Hot backup configuration\n
   *        The connection to an ECMG can be denied for inactive devices. To enable this feature a setting on the ECMG proxy must be reset. 
   *        This setting can be adapted using the SetHotEcmgConnection IIOP call. This call takes the following arguments:
   *        -  EcmgId  unique identifier (proxy_id) for ECMG proxy
   *        -  bBackupHotStandby  flag to indicate whether hot standby (inactive device establishes connection to ECMG) must be enabled or not
   *        
   *        This setting can be checked by using the GetHotEcmgConnection IIOP call. This call uses the same parameters as the set call.  
   *
   * - EMMG proxy   
   *   -# EMMG Proxy creation.
   *       A new EMMG proxy can be created by using the CreateEmmg IIOP call.  This call returns only one parameter:
   *       -  EmmgId  unique identifier (proxy_id) for newly created EMMG proxy. 
   *       This proxy_id needs to be used in all other IIOP calls concerning this proxy.\n
   *       An existing EMMG proxy can be removed by using the DeleteEmmg IIOP call. This call takes only one argument:
   *       -  EmmgId  unique identifier (proxy_id) for EMMG proxy.
   *
   *   -# EMMG Proxy configuration.
   *       Once a proxy has been created, it can be configured. The current configuration can be checked using the GetEmmgConfig IIOP call.
   *       This call takes only one argument:
   *       -  EmmgId  unique identifier (proxy_id) for ECMG proxy.
   *       An ECMG proxy can be configured by using the SetEmmgConfig IIOP call. This call uses the same parameters as the get call.
   * 
   *   -# EMMG status.
   *       The status of an EMMG proxy can be retrieved, by using the GetEmmgStatus IIOP call. This call takes only one argument:
   *       -  EmmgId  unique identifier (proxy_id) for EMMG proxy.
   *   
   *   -# Descriptor rules.
   *       Descriptor rules can be defined on proxy level. These rules can append private data to the CA descriptors in the CAT. 
   *       A descriptor rule needs to be created and configured.
   *       Each descriptor rule has a unique identifier (DescRuleId), which is assigned to the descriptor rule at construction time 
   *       and can be used to address that specific descriptor rule.\n        
   *       The IIOP call GetEmmgDescList will return all DescRuleId's currently in use for a specific EMMG proxy. This call takes only one argument:
   *       -  EmmgId  unique identifier (proxy_id) for EMMG proxy.
   *       And will return a list of all used DescRuleId's:
   *       -  DescRuleIds  list of all DescRuleId's for EMMG proxy.
   *
   *       - Descriptor rule creation.
   *           A new descriptor rule can be created by the means of the CreateEmmgDescriptor IIOP call. This call takes only one argument:
   *           -  EmmgId  unique identifier (proxy_id) for EMMG proxy
   *           And will return one argument as well:
   *           -  DescRuleId  Unique identifier for newly created descriptor rule. 
   *           This DescRuleId needs to be used in all other IIOP calls concerning this proxy.
   *           
   *           An existing descriptor rule can be removed by using the DeleteEmmgDescriptor IIOP call. This call takes two arguments:
   *           -  EmmgId  unique identifier (proxy_id) for EMMG proxy.
   *           -  DescRuleId  unique identifier for descriptor rule.
   *    
   *       - Descriptor rule configuration.
   *           Once descriptor rule has been created, it can be configured. The current configuration can be checked using the GetEmmgDescriptor IIOP call.  This call takes two arguments:
   *           -  EmmgId  unique identifier (proxy_id) for EMMG proxy.
   *           -  DescRuleId  unique identifier for descriptor rule.\n       
   *           A descriptor rule can be configured by using the SetEmmgDescriptor IIOP call. This call uses the same parameters as the get call.
   *
   * - EIS proxy.
   *     -# Proxy creation.
   *         A new EIS proxy can be created by using the CreateEis IIOP call.  This call returns only one parameter:
   *         -  EisId  unique identifier (proxy_id) for newly created EIS proxy. This proxy_id needs to be used in all other IIOP calls concerning this proxy.
   *         
   *         An existing EIS proxy can be removed by using the DeleteEis IIOP call. This call takes only one argument:
   *         -  EisId  unique identifier (proxy_id) for EIS proxy.
   *     
   *     -# Proxy configuration.
   *         Once a proxy has been created, it can be configured. The current configuration can be checked using the GetEisConfig IIOP call.  This call takes only one argument:
   *         -  EisId  unique identifier (proxy_id) for EIS proxy.
   *         An EIS proxy can be configured by using the SetEisConfig IIOP call. This call uses the same parameters as the get call.
   *     
   *     -# EIS status.
   *         The status of an EIS proxy can be retrieved, by using the GetEisStatus IIOP call. This call takes only one argument:
   *         -  EisId  unique identifier (proxy_id) for EIS proxy.
   *         And will return the following parameters:
   *         -  EisConnectionState  status of connection.
   *         -  ConnectionPeer  IP address of connected EIS.
   *  
   *         For historical reasons a second IIOP call, GetEisStatusEx, exists which will return the same and additional parameters. This call takes again only one argument:
   *         -  EisId  unique identifier (proxy_id) for EIS proxy
   *         And will return the following paramters:
   *         -  EisConnectionState  status of connection.
   *         -  ConnectionPeer  IP address of connected EIS.
   *         -  NbrOfChannels  number of connections to EIS.
   *  
   * - PSIG proxy.
   *     -# Proxy creation.
   *         A new PSIG proxy can be created by using the CreatePsig IIOP call.  This call returns only one parameter:
   *         -  PsigId  unique identifier (proxy_id) for newly created PSIG proxy. 
   *            This proxy_id needs to be used in all other IIOP calls concerning this proxy.
   *         
   *         An existing PSIG proxy can be removed by using the DeletePsig IIOP call. This call takes only one argument:
   *         -  PsigId  unique identifier (proxy_id) for PSIG proxy.
   *  
   *     -# Proxy configuration
   *         Once a proxy has been created, it can be configured. The current configuration can be checked using the GetPsigConfig IIOP call. 
   *         This call takes only one argument:
   *         -  PsigId  unique identifier (proxy_id) for PSIG proxy.
   *    
   *         A PSIG proxy can be configured by using the SetPsigConfig IIOP call. This call uses the same parameters as the get call.
   *      
   *     -# PSIG status.
   *         The status of a PSIG proxy can be retrieved, by using the GetPsigStatus IIOP call. This call takes only one argument:
   *         -  PsigId  unique identifier (proxy_id) for PSIG proxy.
   *     .
   *
   *   @b Transrating
   *
   *   There are 3 kinds of TR groups (defined in the IDL by the enum: eTR_GroupType):
   *   - (Single TS) MPTS All services.
   *        TR group associated with a single TS.
   *        All services of that TS are automatically part of the TR group.
   *        There can only be one such a TR group associated with a TS.
   *   - (Single TS) MPTS Selective services.
   *        TR group associated with a single TS.
   *        A sub set of output services can be part of the TR group.
   *        There can be mulitple TR groups of this type associated with the same output TS.
   *   - Multi TS TR group.
   *        TR group associated with multiple SPTS (SPTS only, no MPTS allowed).
   *        
   *   A TS can only be associated with 1 type of TR group (e.g. it is not possible to have 
   *   a MPTS All Services and MPTS Selective Services TR group associated with the same 
   *   output TS, or it is not possible that an output TS is associated with a MPTS selective 
   *   services TR group while part of a Mulit TS TR group).
   *
   *   TR group Identification:
   *   A TR group is identified by a GroupID (TR_GroupID_t).
   *   All actions conserning TR groups must specify the Group ID to target the correct TR group.
   *
   *   (Single TS) MPTS All Services TR group:
   *   - Create: TR_GroupAddL, TR_TS_AddL
   *   - Delete: TR_GroupDeleteL
   *   - Add new Services: When a service a added to the TS the service is automatically 
   *         added to the TR group
   *   - Remove Services: When a service is removed from the output the service is 
   *         automaticaaly removed from the TR group
   *         There is no need to remove the output services from the TR group first 
   *         when deleting the TR group.
   *
   *   (Single TS) MPTS Selective Services TR group:
   *   - Create: TR_GroupAddL
   *   - Delete: TR_GroupDeleteL
   *   - Add output service to the TR group (Service must exist at the output): TR_ServiceAddL
   *   - Remove existing output service from the TR group but not from the output TS:
   *         TR_ServiceDeleteL
   *         Remove existing output service from the output TS:
   *         When a service is removed from the output TS the service is automaticaly 
   *         removed from the TR group
   *         There is no need to remove the output services from the TR group first 
   *         when deleting the TR group
   *   Multi TS TR group:
   *   - Create: TR_GroupAddL
   *   - Delete: TR_GroupDeleteL
   *   - Add SPTS (SPTS must exist at the output): TR_TS_AddL
   *   - Remove SPTS from the TR group but not from the output: TR_TS_DeleteL
   *   - Remove SPTS from the output: 
   *         When a TS is removed from the output the TS is automatically removed 
   *         from the TR group
   *         No need to remove the TS from the TR group before removal of the TR group itself
   * @}
   */

  /** @interface DeviceControl
   * The only interface of %DCM to the outside world.
   */   
  interface DeviceControl 
  {
    // GENERAL STRUCTURE DEFINITIONS
    /////////////////////////////////////////////////////////////////////////////////////// 
 
    /// A sequence of bytes.
    typedef sequence<octet> ByteStream;
    
    /// A sequence of longs.
    typedef sequence<long> LongStream;

    /// The different system types
    enum eSystemType
    {
      eDCM,
      eDCM_SuperCrypt,
      eDCM_Statmux
    };
    
    /// The different product families
    enum eSystemType_V2
    {
      eSystemType_V2_DCM,
      eSystemType_V2_SuperCrypt,
      eSystemType_V2_MVP,
      eSystemType_V2_PCAM,
      eSystemType_V2_Reserved1,
      eSystemType_V2_Reserved2,
      eSystemType_V2_Reserved3,
      eSystemType_V2_Reserved4,
      eSystemType_V2_Reserved5,
      eSystemType_V2_Reserved6,
      eSystemType_V2_Reserved7,
      eSystemType_V2_Reserved8,
      eSystemType_V2_Reserved9,
      eSystemType_V2_Reserved10
    };
    
    /// The different device types, mechanical chassis types
    enum eDeviceType
    {
      eDeviceType_D9900,  ///< 2RU DCM MKI
      eDeviceType_D9901,  ///< 1RU DCM MKI
      eDeviceType_D9902,  ///< 2RU DCM MKII
      eDeviceType_D9036,  ///< 1RU MVP
      eDeviceType_Reserved1,
      eDeviceType_Reserved2,
      eDeviceType_Reserved3,
      eDeviceType_Reserved4,
      eDeviceType_Reserved5,
      eDeviceType_Reserved6,
      eDeviceType_Reserved7,
      eDeviceType_Reserved8,
      eDeviceType_Reserved9,
      eDeviceType_Reserved10
    };
    
    /** General location of a physical or virtual port.
     *  is used to identify a physical port, unless it is explicitly noted otherwise.
     */
    struct IPS_Ref_t
    {
      unsigned short BoardNr; /**< The board location the board sits in.
                               * - BoardNr = 0 => Main board
                               * - BoardNr for the I/O boards when looking at the back of the device
                               *   <TABLE>
                               *   <TR><TD> 3</TD><TD> 4</TD>
                               *   <TR><TD> 1</TD><TD> 2</TD> 
                               *   </TABLE>
                               *   and for a MkII device with 2-layer boards:
                               *   <TABLE>
                               *   <TR><TD> 3/7</TD><TD> 4/8</TD>
                               *   <TR><TD> 1/5</TD><TD> 2/6</TD> 
                               *   </TABLE>
                               */

      unsigned short PortNr;  /**< The physical port.
                               * -  ASI, has 10 ports. PortNr range: 0..9.
                               * -  GbE, has 4 ports. PortNr range: 0..3. 
                               * The wildcard, 0xFFFF, if allowed means all ports on this board.
                               * If IPS_Ref_t is used to identify a virtual port (e.g. VLAN), PortNr can be > number of Physical ports
                               */
    };    
   
    /** General location of a TS
     */
    struct IPS_RefTS_t
    {
      IPS_Ref_t PhysRef; ///< See IPS_Ref_t.
      unsigned long Ref; /**< This is the TS index.
                          * - ASI, Ref = TS index = PortNr
                          * - GbE, 8VSB Ref = TS index != PortNr
                          */
    };
    
    /** Alarm reference (M&M, 1:1 device backup).
     */
    struct MM_ID_t 
    { 
      unsigned short MM_TypeID; ///< input/output + type of message or measurement
      IPS_RefTS_t Ref;          ///< board + port + TSIndex 
      unsigned short SubID1;
      unsigned short SubID2;
    };

    /// A sequence of MM_ID_t.
    typedef sequence<MM_ID_t> MM_IDList;

    /// A sequence of MM_TypeID's.
    typedef sequence<unsigned short> MM_TypeIDList;

#ifndef DISABLE_TIME_MGMT
    // TIME MANAGEMENT
    /////////////////////////////////////////////////////////////////////////////////////// 
    
    /** @defgroup time Time management
     *  This groups functions and compounds about time.  
     * @{
     */
    
    /** Structure to supply date and time information.
     */
    struct Time
    {
      long Year;        ///< From year 0 onwards.
      octet Month;      ///< From 1 to 12.
      octet DayOfMonth; ///< From 1 to 28, 29, 30 or 31.
  
      octet Hour;       ///< From 0 to 23.
      octet Minute;     ///< From 0 to 59.
      octet Second;     ///< From 0 to 59.
    };

    /** Synchronization types.
     *
     * @note On %DCM you can either disable clock synchronization or you can
     *   configure NTP clock synchronization. The synchronization type
     *   eClock_Sync_Type_DayTime is no longer supported. Do not pass this
     *   synchronization type to SetSynchronizationType() !
     */
    enum eClock_Sync_Type
    {
      eClock_Sync_Type_Disabled,
      eClock_Sync_Type_NTP,
      eClock_Sync_Type_DayTime
    };

    /** Synchronization types.
     *
     * On %DCM you can:
     * - disable clock synchronization or
     * - configure NTP clock synchronization or
     * - configure clock synchronization using SI tables.
     *
     * The synchronization type eClock_Sync_Type_DayTime_V2 is not
     * supported. Do not pass this synchronization type to one of the
     * SetSynchronizationType() functions!
     */
    enum eClock_Sync_Type_V2
    {
      eClock_Sync_Type_Disabled_V2,
      eClock_Sync_Type_NTP_V2,
      eClock_Sync_Type_DayTime_V2, ///< not supported
      eClock_Sync_Type_SI_Table_V2,
      eClock_Sync_Type_Reserved1, ///< not supported yet
      eClock_Sync_Type_Reserved2, ///< not supported yet
      eClock_Sync_Type_Reserved3  ///< not supported yet
    };

    /** Set the synchronization type.
     *
     * @param[in] Type Specifies the synchronization method to use.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded in case an internal error occurs (e.g. %DCM
     *   fails to write to file in which this setting is persistently stored).
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     * @exception OutOfRange     Never thrown.
     *
     * @note eClock_Sync_Type_DayTime is no longer supported.
     */
    void SetSynchronizationType(in eClock_Sync_Type Type)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OutOfRange);

    /** Set the synchronization type.
     *
     * @param[in] Type Specifies the synchronization method to use.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded in case an internal error occurs (e.g. %DCM
     *   fails to write to file in which this setting is persistently stored).
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     * @exception OutOfRange     Never thrown.
     *
     * @note eClock_Sync_Type_DayTime_V2 is not supported.
     */
    void SetSynchronizationType_V2(in eClock_Sync_Type_V2 Type)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OutOfRange);

    /** Get the synchronization type.
     *
     * @return Type The synchronization method currently in use.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded in case:
     * - an internal error occurs (e.g. %DCM fails to read the file in which
     *   this setting is persistently stored).
     * - current synchronization type is one of the types defined by
     *   eClock_Sync_Type_V2 which has no corresponding type defined by
     *   eClock_Sync_Type, e.g. eClock_Sync_Type_SI_Table_V2.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     */
    void GetSynchronizationType(out eClock_Sync_Type Type)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get the synchronization type.
     *
     * @return Type The synchronization method currently in use.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded in case:
     * - an internal error occurs (e.g. %DCM fails to read the file in which
     *   this setting is persistently stored).
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     */
    void GetSynchronizationType_V2(out eClock_Sync_Type_V2 Type)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Set date, time and timezone.
     * 
     * @param[in] CurrentTime   New time, specified in current timezone.
     * @param[in] OffsetMinutes New offset in minutes between local time zone and
     *     GMT. Range: -14 * 60 .... 12 * 60. Must be a multiple of 60 minutes.
     * 
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded
     * - One or more elements of CurrentTime is out of range.
     * - OffsetMinutes is out of range.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     * @exception OutOfRange     Never thrown.
     */
    void SetClock(in Time CurrentTime, in long OffsetMinutes) 
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OutOfRange);
    
    /** Set date and time.
     * 
     * @param[in] CurrentTime New time, specified in current timezone.
     * @param[in] TimeZone    New timezone name. Two different formats are allowed
     *   - \<Continent\>/\<City\>, e.g. Europe/Brussels.
     *   - \<std\>\<offset\>[\<dst\>[\<offset\>]][,\<rule\>],
     *     e.g. "EST5:00EDT,M3.2.0,M11.1.0" for Ottawa.
     * 
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded One or more elements of CurrentTime is out
     *                           of range.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     * @exception OutOfRange     Never thrown.
     *
     * @see See also The Open Group Base Specifications Issue 6, IEEE Std
     *   1003.1,
     *   <a href="http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html">
     *   8.3 Other Environment Variables, TZ variable.</a> for more information
     *   on the syntax of the timezone string.
     */
    void SetClock2(in Time CurrentTime, in string TimeZone)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OutOfRange);

    /** Get system date and time in the GMT timezone.
     * 
     * @return Returns the current system date and time.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Never thrown.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     */
    Time GetClock() 
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get system date, time and timezone.
     * 
     * @param[out] CurrentTime Current system date and time in local timezone.
     * @param[out] Timezone    Current timezone.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Never thrown.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     */
    void GetClock2(out Time CurrentTime, out string Timezone) 
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    typedef sequence<string> IP_List_t;

    /** Set the list of NTP servers to be used by %DCM.
     *
     * @param[in] IPAddresses IP addresses of NTP servers.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Address list is empty.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     * @exception OutOfRange     Never thrown.
     */
    void SetNTPServers(in IP_List_t IPAddresses)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OutOfRange);

    /** Get the list of NTP servers in use by %DCM.
     *
     * @param[out] IPAddresses IP addresses of NTP servers.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Never thrown.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     */
    void GetNTPServers(out IP_List_t IPAddresses)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    enum eNTP_TallyCodes
    {
      eNTP_TC_SpaceReject, ///< The peer is discarded as unreachable, synchonized to this server (synch loop) or outrageous synchronization distance.
      eNTP_TC_FalseTick,   ///< The peer is discarded by the intersection algorithm as a falseticker.
      eNTP_TC_Excess,      ///< The peer is discarded as not among the first ten peers sorted by synchronization distance.
      eNTP_TC_Outlyer,     ///< The peer is discarded by the clustering algorithm as an outlyer.
      eNTP_TC_Selected,    ///< The peer is a survivor, but not among the first six peers sorted by synchronization distance.
      eNTP_TC_SysPeer,     ///< The peer has been declared the system peer and lends its variables to the system variables.
      eNTP_TC_PPSPeer,     ///< The peer has been declared the system peer and lends its variables to thesystem variables.
      eNTP_TC_Candidat     ///< The peer is a survivor and a candidate for the combining algorithm.
    };
    
    enum eNTP_RefClockTypes
    {
      eNTP_RCT_Local,
      eNTP_RCT_Unicast,
      eNTP_RCT_Broadcast,
      eNTP_RCT_Multicast,
      eNTP_RCT_Invalid
    };

    struct NTP_Stats_t
    {
      eNTP_TallyCodes TallyCode;
      string RefID;                     ///< Reference Clock Identifier.
      octet Stratum;                    ///< Defines the distance to the reference clock.
      eNTP_RefClockTypes RefClockType; 
      long LastPoll;                    ///< Time that elapsed since last poll attempt 
      long PollInterval;                ///< Current interval between poll attempts, in seconds.
      string Reachability;              ///< Indicates the reachabilty status of the peer as an octal number. 
      double Delay;                     ///< Indicates the roundtrip delay of the peer clock relative to the local clock over the network path between them, in seconds.
      double Offset;                    ///< Indicates the offset of the peer clock relative to the local clock, in seconds.
      double Jitter;                    ///< The estimated time error of the system clock measured as an exponential average of RMS time differences.
    };

    struct NTP_Info_t
    {
      string IP;
      NTP_Stats_t Stats;
    };

    typedef sequence<NTP_Info_t> NTP_Info_List_t;

    /** Get the NTP statistics.
     *
     * @return NTP_Info_List_t List with statistics per server, including
     *                         the local clock (127.127.1.0).
     * 
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded If communication with the NTP server fails.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     *
     * @note For more information about NTP, see also
     * <a href="http://www.ee.udel.edu/~mills/ntp/html/ntpq.html">
     * The NTP Project</a>.
     */
    NTP_Info_List_t GetNTPStatistics()
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Structure defining the parameters for time sync via SI table acquisition.
     */
    struct Table_Sync_Info_t
    {
      IPS_RefTS_t RefTS; ///< input TS where table has to be retrieved from
      unsigned long TableId; ///< 0x70 for TDT of 0x73 for TOT or 0xCD for STT
      unsigned short Pid; ///< pid value. Typically 0x14 for TDT/TOT and 0x1FFB for STT
                          ///< If INVALID_PID_VALUE (0xFFFF) is specified then typical pid value
                          ///< will be used automatically
      short Offset; ///< value in ms that is added to the T*T time before applying it to the system clock.
                    ///< Can be a negative value! Value in seconds (steps of 1000ms) to correct GPS
                    ///< time to UTC time. Not supported for the moment and always reset to 0.
    };

    /** A list of Table_Sync_Info_t entries.
     * Only lists with one item will be supported in first release !!
     */
    typedef sequence<Table_Sync_Info_t> Table_Sync_Info_List_t;

    /** Set the necessary parameters for time sync using SI table acquisition and syncs the time.
     *
     * @param[in] MonitoringInterval Specifies the time between 2 updates of
     *                               the system clock in seconds.
     *
     * @param[in] SyncList Only one entry supported now. Provides info on the SI table
     *                     to be used.
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Invalid MonitoringInterval or Table_Syc_Info parameters supplied.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     * @exception OutOfRange     Never thrown.
     */
    void SetTableTimeSync(in unsigned long MonitoringInterval, in Table_Sync_Info_List_t SyncList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Get the parameters used for time sync via SI table acquisition.
     *
     * @param[out] MonitoringInterval Specified the time between 2 updates of
     *                                the system clock in seconds.
     *
     * @param[out] SyncList Only one entry supported now. Provides info on the SI table
     *                     to be used.
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Never thrown.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     * @exception OutOfRange     Never thrown.
     */
    void GetTableTimeSync(out unsigned long MonitoringInterval , out Table_Sync_Info_List_t SyncList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Will force an immediate time sync by starting immediate acquisition of the
     *  configured SI Table.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded When the clock sync type is not equal to eClock_Sync_Type_SI_Table_V2
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     * @exception OutOfRange     Never thrown.
     */
    void SyncNowOnTimeTable()
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    // *** Notifications ***
    // Changes on the clock or on the synchronisation information generate 
    // a SettingsTime notification

    /// @} End of time.
#else // DISABLE_TIME_MGMT
    typedef sequence<string> IP_List_t;
#endif // DISABLE_TIME_MGMT
    // CLIENT
    /////////////////////////////////////////////////////////////////////////////////////// 
    /** @defgroup client Client coordinator functions
     * Methods and compounds used to register/ unregister the clients.
     * @{
     */
    /// The different client types.
    enum ClientType
    {
      Client_Gui,
      Client_Mgmt,      ///< Identifies a mgmt system (should be able to receive messages)
      Client_SIServer,
      Client_Front
    };
    

    enum eSystemStartup
    {
      eSystemStartup_NotReady,
      eSystemStartup_Ready
    };
    /** Log on, needed to perform most of the operations.
     *
     * @param[in] Type type of client (use always Client_Gui).
     * @param[in] ClientName
     * @param[in] Password
     * @param[in] SecurityKey (not used).
     * @param[out] ClientUniqueNumber can be used to identify this client.
     * 
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded in case of
     * - A timeout occurred during IIOP processing.
     * - Invalid parameters.
     * @exception OpNotAllowed   Already logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     * @exception MaxClientsReached No more free connections left.
     *
     * @note failure in this request causes the connection to be ended.
	 * @note For version prior to v08.05, username "guest", password "guest" always worked. 
     * For v08.05 and above, use one of the OS accounts that have IIOP access.
     **/
    void LogOn(in ClientType Type, in string ClientName, in string Password, 
            in string SecurityKey, out long ClientUniqueNumber) 
        raises (MaxClientsReached, TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
            
    /** Log on to the notification channel, needed to receive notifications.
     *
     * @param[in] ClientUniqueNumber now used to specify the portnumber for receiving notifications,
     *        originally, this was used to link the notification channel to the request channel.
     *
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded in case of
     * - A timeout occurred during IIOP processing.
     * - Invalid parameters.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     *
     * @note failure in this request causes the connection to be ended.
     * @note original version of LogOnForNotif:
     *       - new connection for each notification
     *       - notifications don't contain an object key
     **/
    void LogOnForNotif(in long ClientUniqueNumber) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Second version of LogOnForNotif(): LogOnForNotif2.
     *
     * @param[in] ClientUniqueNumber now used to specify the portnumber for receiving notifications,
     *        originally, this was used to link the notification channel to the request channel.
     *
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded in case of
     * - A timeout occurred during IIOP processing.
     * - Invalid parameters.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     *
     * @note failure in this request causes the connection to be ended.
     * @note second version of LogOnForNotif:
     *       - fixed tcp-connection for sending over notifications (issue seen in %DCCM with multiple connections)
     *       - notifications don't contain an object key
     * @note originally put in for internal notifications in %DCM
     **/
    void LogOnForNotif2(in long ClientUniqueNumber) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Third version of LogOnForNotif(): LogOnForNotif3.
     *
     * @param[in] ClientUniqueNumber now used to specify the portnumber for receiving notifications,
     *        originally, this was used to link the notification channel to the request channel.
     * @param[in] ObjectKey object key expected in the notification.
     *
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded in case of
     * - A timeout occurred during IIOP processing.
     * - Invalid parameters.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     *
     * @note failure in this request causes the connection to be ended.
     * @note second version of LogOnForNotif:
     *       - fixed tcp-connection for sending over notifications (issue seen in %DCCM with multiple connections)
     *       - notifications contain an object key, specified in this operation
     * @note originally put in for sending notifications to an omniorb notification server
     **/
    void LogOnForNotif3(in long ClientUniqueNumber,
                        in ByteStream ObjectKey)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
      
    /** Register for a notification.
     * A notification will always be sent to all registered clients, except when
     * the notification is triggered by an IDL-operation, in which case the caller
     * won't receive the notification
     *
     * @param[in] ClientName (not used anymore).
     * @param[in] NotificationName name of the notification that the client would like to receive.
     *
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded in case of
     * - A timeout occurred during IIOP processing.
     * - unknown notification.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     **/
    void Register(in string ClientName, in string NotificationName) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
      
    /** Unregister for a notification (see Register()).
     *
     * @param[in] ClientName (not used anymore).
     * @param[in] NotificationName name of the notification that the client would like to stop receiving.
     *
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded in case of
     * - A timeout occurred during IIOP processing.
     * - unknown notification.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     **/
    void UnRegister(in string ClientName, in string NotificationName) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    struct NotifData_t
    {
      string Name;
      unsigned long Behaviour; ///< 0: send buffered, 1: send directly
    };
    typedef sequence<NotifData_t> NotifList_t;
    /** Get the list of available notifications.
     *
     * @param[out] NotifList list of available notifications.
     *
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded Internal error.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     **/
    void GetNotifList(out NotifList_t NotifList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
      
    /** Log off, stop being able to perform most of the operations.
     *
     * @param[in] ClientName (not used anymore).
     *
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded Never thrown.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     **/
    void LogOff(in string ClientName) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Check whether application is reachable via IIOP.
     * This call can be made when not logged on.
     *
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded Never thrown.
     * @exception OpNotAllowed   Thrown if this call is not supported in the
     *                           running software version and the call was made when
     *                           not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     **/
    void IsAlive() 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);        

    /** Check whether application is started up completely.
     * This is added for management systems that only want to log on when the system
     * is started up completely to avoid startup effects like boards not present yet.
     * This call can be made when not logged on.
     *
     * @return eSystemStartup the current startup state
     *
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded Never thrown.
     * @exception OpNotAllowed   Thrown if this call is not supported in the
     *                           running software version and the call was made when
     *                           not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     **/
    eSystemStartup IsSystemReady() 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);        

    /** Return the System Uptime, this is the total running time since manufacture of the chassis
     * 
     * @return unsigned long  time in hours
     * 
     * @exception TimeOut         Never thrown.
     * @exception OpNotSucceeded  Thrown if there is a problem with the reading of the EEPROM
     * @exception OpNotAllowed    Thrown if this call is not supported in the
     *                            running software version and the call was made when
     *                            not logged on.
     * @exception OpNotSupported  Thrown if this call is not supported in the
     *                            running software version.
     * @exception OperationFailed Thrown when an error occurs while reading the EEPROM, 
     *                            the message will contain the error
     * @version Supported since release 10.0
     *
     * @note This call is only supported on D9902 devices
     */
    unsigned long GetUptime()
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Make difference between possible applications running on the %DCM platform.
     *
     * @param[out] Type of the currently running application.
     * 
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded in case of
     * - A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   Never thrown.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     *                           
     * @deprecated Deprecated since version 9.0, use GetSystemType_V2 instead
     **/
    void GetSystemType(out eSystemType Type)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Make difference between possible applications running on the %DCM platform.
     *
     * @param[out] Type of the currently running application.
     * 
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded in case of
     * - A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   Never thrown.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     * @exception OperationFailed
     *                           
     * @version  Supported since release 9.0
     **/
    void GetSystemType_V2(out eSystemType_V2 Type)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);
    
    /** Make difference between possible device types
     *
     * @param[out] Type of the device
     * 
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded in case of
     * - A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   Never thrown.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     * @exception OperationFailed
     *                           
     * @version  Supported since release 9.0
     **/
    void GetDeviceType(out eDeviceType Type)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Make it possible to identify a DCM by the LEDs.
     *
     * @param[in] Duration number of seconds that the IdentifyMe mode should be active
     * 
     * @exception OpNotSucceeded Never thrown.
     * @exception OpNotAllowed   Never thrown.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     **/
    void IdentifyMe(in long Duration)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    
    /// @} End of client.
        
#ifndef DISABLE_SNMP 
    // SNMP
    /////////////////////////////////////////////////////////////////////////////////////// 
    /** @defgroup snmp SNMP specific
     * @{
     */
    
    /// SNMP trap destination settings.
    struct TrapDestination
    {
       string IPAddress;
       string TrapCommunity; ///< Max 40 char.
    };
    
    /// A sequence of TrapDestination entries.
    typedef sequence<TrapDestination> TrapDestinationList;
    
    /** Get the list of SNMP trap destinations.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Never thrown.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     */
    TrapDestinationList GetSNMPTrapDest() 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Either add a new or modify an existing SNMP trap destination.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Never thrown.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     */
    void AddSNMPTrapDest(in TrapDestination Destination) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Remove the specified SNMP trap destination.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded There was no trap destination for IPAddress
     *                           configured.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     */
    void RemoveSNMPTrapDest(in string IPAddress) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /// SNMP permission settings.
    enum SNMPOperationRights
    {
      SNMP_ReadOnly,
      SNMP_ReadWrite
    };
   
    /// SNMP read or write community settings.
    struct SNMPCommunity
    {
      string Community;           ///< Max 40 char.
      SNMPOperationRights Rights;
    };
    
    /// A sequence of SNMPCommunity entries.
    typedef sequence<SNMPCommunity> SNMPCommunityList;
    
    /** Get all configured SNMP communities.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Never thrown.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     */
    SNMPCommunityList GetSNMPCommunities() 
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Add a new SNMP community or modify an existing SNMP community.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Never thrown.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     * @exception OutOfRange     Thrown if the community string is empty or if
     *   another value has been specified for the community rights than
     *   SNMP_ReadOnly or SNMP_ReadWrite.
     */
    void AddSNMPCommunity(in SNMPCommunity Community) 
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OutOfRange);
    
    /** Remove one SNMP Community entry.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Thrown if the specified community was not
     *   added before via AddSNMPCommunity().
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     * @exception OutOfRange     Thrown if the community string is empty or if
     *   another value has been specified for the community rights than
     *   SNMP_ReadOnly or SNMP_ReadWrite.
     * @todo Community should be described
     */
    void RemoveSNMPCommunity(in string Community) 
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OutOfRange);
    
    /// SNMP host access restrictions (actually a list of strings.).
    typedef sequence<string> IPAddressList;
    
    /** Enable/Disable sending of Mystro MIB traps (addservice etc)
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Never thrown.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     * @exception OutOfRange     Never thrown.
     */
    void SetSNMP_MystroTrapsEnabled(in boolean bEnabled)  
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OutOfRange);

    /** Query whether sending of Mystro MIB traps is enabled.
     *
     * @param[out] bEnabled The return value.
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Never thrown.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     */
    void GetSNMP_MystroTrapsEnabled(out boolean bEnabled)  
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    
    /// @} End of snmp.
#endif // DISABLE_SNMP

    // CONFIGURATION OF THE BOARDS
    /////////////////////////////////////////////////////////////////////////////////////// 
    /** @defgroup genBoard General board configuration calls
     * Board functionality - used to retrieve Board information.
     * @{
     */
    
    /// Possible values IsBoardPresent() can return.
    enum PresenceStatus
    {
        NotPresent,
        Present,
        Present_Not_Initialized,
        Present_Error
    };
    
    /// Version number information.
    struct VersionParts
    {
        char VersionType;       ///< 'A' for a, 'B' for b, D for demo and V for release
        short MajorNumber;
        short MinorNumber;
        short BuildNumber;
    };

    /// Version info.
    struct VersionInfo
    {
        string ComponentName;   ///< MAX string length = 20     
        string VersionName;       ///< MAX string length = 20
        VersionParts VersParts;
    };

    /// A sequence off VersionInfo.
    typedef sequence<VersionInfo> VersionInfoList;

    /// Information data as returnd by GetSystemId(). 
    struct BoardIdentification
    {
      string BoardName;      
      string OrderNumber;
      string SerialNumber;
      string UserName;
      string SlotName;  ///< Max 40 chars e.g. Input, Output, Aggregate, ... (refers to the backplane name)
      string SlotId;      ///< Max 5 chars e.g. 1A (refers to the backplane id)
      VersionInfoList BoardVersion;        
    };
    typedef sequence<BoardIdentification> BoardIdentificationList;

    struct UniqueDeviceId_t
    {
      string   Id;     ///< The ID of the info field
      string   Info;   ///< Unique device identifier info field
    };
    
    /// A sequence of UniqueDeviceIdList entries.
    typedef sequence<UniqueDeviceId_t>UniqueDeviceIdList_t;
    
    /** Get the system version information.
     *
     * @return The system identification in BoardIdentification format.
     *
     * @exception OpNotSucceeded in case of internal error
     */
    BoardIdentification GetSystemId() 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Set the system unit name.
     *
     * @param[in] Name Specifies the used defined system name, string should be maximum 40 chars
     *
     * @exception OpNotSucceeded in case of internal error
     */
    void SetSystemName(in string Name) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Get the number of boards that a device can have, including mainboard.
     * The number of boards returned can be different for other types of chassis.
     *
     * @return The Nbr of boards including mainboard (boards can currently be present or not).
     *
     * @exception OpNotSucceeded in case of internal error
     */
    long GetNbrOfSlots() 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Measure the presence of a board on a particular board location
     * the SlotNbr ranges from 1 to NbrOfSlots.
     *
     * @param[in] SlotNbr [1..(Number of available slots returned by GetNbrOfSlots + 1)]
     *
     * @return A @ref PresenceStatus indicating whether the specified board is present or not.
     *
     * @exception OpNotSucceeded in case an invalid SlotNbr is used:
     *
     * @note The SlotNbr differs from the BoardNbr used in the other %DCM IDL calls
     * - SlotNbr is a long => Compatibility reasons with ROSA/Copernicus
     * - SlotNbr = %DCM BoardNbr + 1
     * - SlotNumber = 1 = %DCM main board
     * - SlotNumber = 2 = %DCM board 1
     * - SlotNumber = 3 = %DCM board 2
     * - ...
     * - SlotNumber = GetNbrOfSlots+1 = virtual board, returns the system information
     */
    PresenceStatus IsBoardPresent(in long SlotNbr) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the boardtype information
     * This call returns input, output, processor, etc. in BoardIdentification format.
     *
     * @param[in] SlotNbr [1..(Number of available slots returned by GetNbrOfSlots)]
     *
     * @return Requested board information
     *
     * @exception OpNotSucceeded in case of internal error
     * @exception OutOfRange in case an invalid SlotNbr is used:
     *
     * @note The SlotNbr differs from the BoardNbr used in the other %DCM IDL calls
     * - SlotNbr is a long => Compatibility reasons with ROSA/Copernicus
     * - SlotNbr = %DCM BoardNbr + 1
     * - SlotNumber = 1 = %DCM main board
     * - SlotNumber = 2 = %DCM board 1
     * - SlotNumber = 3 = %DCM board 2
     * - ...
     */
    BoardIdentification GetBoardId(in long SlotNbr) 
        raises(TimeOut, OutOfRange, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the extended boardtype information
     * This call returns a list of BoardIdentifications: input, output, processor, etc. in BoardIdentification format.
     *
     * Main board: returns a BoardIdentification for the mainboard only.
     * IO boards: returns a list of BoardIdentifications for the IO-board and the present Boards on the IO-board:
     *      - ASI: IO and (no) Transrater BoardIdentitfication.
     *      - GBE: IO and (no) Transrater and (no) FEC-board BoardIdentitfication.
     * 
     * @param[in] SlotNbr [1..(Number of available slots returned by GetNbrOfSlots)]
     *
     * @return list of  Requested board information
     *
     * @exception OpNotSucceeded in case of internal error
     * @exception OutOfRange in case an invalid SlotNbr is used:
     *
     * @note The SlotNbr differs from the BoardNbr used in the other %DCM IDL calls
     * - SlotNbr is a long => Compatibility reasons with ROSA/Copernicus
     * - SlotNbr = %DCM BoardNbr + 1
     * - SlotNumber = 1 = %DCM main board
     * - SlotNumber = 2 = %DCM board 1
     * - SlotNumber = 3 = %DCM board 2
     * - ...
     */
    BoardIdentificationList GetBoardIdExt(in long SlotNbr) 
        raises(TimeOut, OutOfRange, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Get the unique device identity information
     * This call returns information which can be shown on the GUI.
     *
     * @param[in] BoardNr The Board from which to retrieve information
     * @param[out] UniqueDeviceIdList Requested board information
     *
     * @return Requested board information
     *
     * @exception OpNotSucceeded in case of internal error
     * @exception OutOfRange in case an invalid BoardNumber is used:
     *
     */
    void GetUniqueDeviceId(in unsigned short BoardNr, out UniqueDeviceIdList_t UniqueDeviceIdList)
        raises(TimeOut, OutOfRange, OpNotSucceeded, OpNotAllowed, OpNotSupported);  


    /** Set the user-defined name of a board
     *
     * @param[in] SlotNbr [1..(Number of available slots returned by GetNbrOfSlots + 1)]
     *
     * @param[in] UserName new user name value, string should be maximum 40 chars
     *
     * @exception OpNotSucceeded in case an invalid SlotNbr is used:
     *
     * @note The SlotNbr differs from the BoardNbr used in the other %DCM IDL calls
     * - SlotNbr is a long => Compatibility reasons with ROSA/Copernicus
     * - SlotNbr = %DCM BoardNbr + 1
     * - SlotNumber = 1 = %DCM main board
     * - SlotNumber = 2 = %DCM board 1
     * - SlotNumber = 3 = %DCM board 2
     * - ...
     * - SlotNumber = GetNbrOfSlots+1 = virtual board, returns the system information
     */
    void SetUserName(in long SlotNbr, in string UserName) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported); // max 40 chars
    
        
    /// Possible options to Reboot the %DCM.  
    enum eRebootType {
      WarmReboot, ///< All settings remain intact.
      ColdReboot, ///< All settings cleared except IP address and licenses.
      CleanReboot ///< All settings cleared included Ip address and licenses.
    };
                       
    /** Reboot the DCM or a board
     * Single board reboots are only supported for active IP Adapter Video cards.
     * In case an IP Adapter card is cold rebooted, only the card's settings will be removed.
     * Mainboard's and other card's settings are preserved.
     *
     * @param[in] RefPhys The Slot (and Port) to apply the call on. The Port is ignored.
     *            Specify 0 or 0xFFFF as board number to reboot the whole chassis. Slotnumbers 1-n
     *            will reboot the board in the selected slot.
     * @param[in] RebootType contains warm or cold indication meaning a preserve or cleanup settings
     * @exception OpNotSucceeded in case an invalid board number was used or the target board is not
     *            an active IP Adapter Video board. A card being hotswapped out is considered inactive.
     */
    void RebootDCM(in IPS_Ref_t RefPhys, in eRebootType RebootType) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);     
 
    /// @} End of genBoard.

    /** @defgroup Logging Logging facilities on the DCM
      * @{
     **/
     
    /** Deprecated. Set level, type and module ID for logging.
     * @param[in] RefPhys The Slot (and Port) to apply the call on.
     * @param[in] level Contains a bitmask with a combination of modeLogSvrty
     * @param[in] type Contains a bitmask with a combination of modeLogType
     * @param[in] mid Contains a bitmask to enable/disable logging for individual modules
     */
    void LOG_SetLTM(in IPS_Ref_t RefPhys,
                    in unsigned long level, /* a mask, combination of modeLogSvrty */
                    in unsigned long type,  /* a mask, combination of modeLogType */
                    in unsigned long mid)   /* a mask, listing mid's */ 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
                                                            
    /** Indicates how much debugging information is generated for enabled modules
     *  A specific Tracelevel includes all levels above.
     **/
    enum eTraceLevel {
      eDebugAll,    //< Show all possible information
      eDebugMinor,  //< Only show less relevant debugging issues
      eDebugMajor,  //< Only show important debugging information
      eDebugNone    //< Only show normal operational information, like Events and Errors
    };
    
    /** Structure to get or set Debug Trace Level information.
      * When setting the Debug Trace Levels the ModuleName is ignored. */
    struct ModuleExceptionTrace_t
    {
      unsigned long ModuleId;          //< A number identifying the Module, unique boardwide, cannot change.
      string ModuleName;               //< The internal name of this Module, cannot change.
      boolean ExceptionTraceEnabled;   //< Indicates if tracing for this module is switched on/off
    };

    typedef sequence<ModuleExceptionTrace_t> ModuleExceptionTraceList_t;

    /** Get the current Trace level and the list of Module names and Modules Id's
     *
     * @param[in] BoardNumber The Board from which to retrieve information
     * @param[out] TraceLevel The current tracelevel on the board
     * @param[out] ModuleExceptionTraceList
     **/
    void GetModuleTraceLevel(in unsigned short BoardNumber, out eTraceLevel TraceLevel, out ModuleExceptionTraceList_t ModuleExceptionTraceList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the current Trace level and enable/disable a list of modules
     *
     * @param[in] BoardNumber The Board from which to retrieve information
     * @param[in] TraceLevel The desired tracelevel on the board
     * @param[in] ModuleExceptionTraceList A list indicating the Modules to enable/disable
     *
     * @exception OpNotSucceeded In case of
     * - setting an invalid TraceLevel
     * - an invalid ModuleId is sent
     **/
    void SetModuleTraceLevel(in unsigned short BoardNumber, in eTraceLevel TraceLevel, in ModuleExceptionTraceList_t ModuleExceptionTraceList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

     /** Log a string in the trace of a specific board.
     *
     * @param[in] BoardNumber The Board for which a trace message is sent. 
     * @param[in] LogTraces The string to log into the trace file of the BoardNumber.
     *
     * @exception OpNotSucceeded In case of
     * - Unexisting board.
     */
     void IDL_Trace(in unsigned short BoardNumber, in string LogTraces) 
         raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    /** @} End of Logging */
   
    ///////////////////////////////////////////////////////////////////////////////////////
    // APPLICATION SPECIFIC
    ///////////////////////////////////////////////////////////////////////////////////////  
    
    // Structures & enums
    /////////////////////////////////////////////////////////////////////////////////////// 
   
    // Application specific Configuration Management
    ///////////////////////////////////////////////////////////////////////////////////////
    
    /** @defgroup config Application Specific Configuration management
     * This groups enums, types and methods to control and display what's actually inside the box.
     * @{
     */
    
    
    /** Undefined board */
    const unsigned short INVALID_BOARD=0xffff;
    const unsigned short MAINBOARD=0;
    /** Undefined port */
    const unsigned short INVALID_PORT=0xffff;
    /** Only for input parameters.
     *  If you want all ports on a board. 
     */
    const unsigned short ANY_PORT=0xffff;

    // Board information structures & enums
    // ------------------------------------------------------------------------------------
    /** Structure to return board configuration.
     *
     * @version Release 1.0
     */
    struct BoardInfo_t
    {
      unsigned short BoardNumber; /**< The board location the board sits in.
                                   * Board numbering: cfr IPS_Ref_t
                                   */
      eBoardType BoardType;       ///< The type. See DCM_Types.idl
    };
    
    /** Structure to return board configuration.
     *
     * @version Release 6.9
     */
    struct BoardInfo_V2_t
    {
      unsigned short BoardNumber; /**< The board location the board sits in.
                                   * Board numbering: cfr IPS_Ref_t
                                   */
      eBoardType_V2 BoardType;    ///< The type. See DCM_Types.idl
    };

    /// A sequence of BoardInfo_t entries.
    typedef sequence<BoardInfo_t> BoardInfo_List_t;
    
    /// A sequence of BoardInfo_V2_t entries.
    typedef sequence<BoardInfo_V2_t> BoardInfo_List_V2_t;
    
    /// Types of ports or IO interfaces..
    enum eIOInterfaceType
    {
      IOInterfaceType_IP,     ///< Gigabit Ethernet.
      IOInterfaceType_ASI,     ///< ASI.
      IOInterfaceType_SDI     ///< SDI
    };
    
    /** 
     * Types of ports or IO interfaces - Version 2
     *
     * @version Release 8.1
     **/
    enum eIOInterfaceType_V2
    {
      IOInterfaceType_V2_IP,          ///< Gigabit Ethernet.
      IOInterfaceType_V2_ASI,         ///< ASI.
      IOInterfaceType_V2_SDI,         ///< SDI
      IOInterfaceType_V2_8VSB,        ///< 8VSB
      IOInterfaceType_V2_DVBS2,       ///< DVBS2
      IOInterfaceType_V2_AES,         ///< AES (AudioGW)
      IOInterfaceType_V2_Reserved7,   ///< Reserved for future use
      IOInterfaceType_V2_Reserved8,   ///< Reserved for future use
      IOInterfaceType_V2_Reserved9,   ///< Reserved for future use
      IOInterfaceType_V2_Reserved10,   ///< Reserved for future use
      IOInterfaceType_V2_Reserved11,   ///< Reserved for future use
      IOInterfaceType_V2_Reserved12,   ///< Reserved for future use
      IOInterfaceType_V2_Reserved13,   ///< Reserved for future use
      IOInterfaceType_V2_Reserved14,   ///< Reserved for future use
      IOInterfaceType_V2_Reserved15   ///< Reserved for future use
    };
    
        
    /// Configuration types of a port.
    enum eIOType
    {
      IOType_I0,            ///< A GbE port always is input/output.
      IOType_FixedIn,       ///< GbE port configured as input only (e.g. first port of port-pair in 2I2O mode).
      IOType_FixedOut,      ///< GbE port configured as output only (e.g. second port of port-pair in 2I2O mode).
      IOType_CfgIn,         ///< An ASI port set for input. 
      IOType_CfgOut         ///< An ASI port set for output.
    };


    /** Configuration types of a port. - version 2
     */
    enum eIOType_V2
    {
      IOType_V2_I0,            ///< A port wich is bidirectional (e.g Gbe).
      IOType_V2_FixedIn,       ///< A port that is input only (e.g first port of Gbe port-pair in 2I2O mode or 8VSB input port)
      IOType_V2_FixedOut,      ///< A port that is output only (e.g. second port of Gbe port-pair in 2I2O mode).
      IOType_V2_CfgIn,         ///< A port configured for input. 
      IOType_V2_CfgOut,        ///< A port configured for output.
      IOType_V2_Reserved6,    ///< Reserved for future use.
      IOType_V2_Reserved7,    ///< Reserved for future use.
      IOType_V2_Reserved8,    ///< Reserved for future use.
      IOType_V2_Reserved9,    ///< Reserved for future use.
      IOType_V2_Reserved10    ///< Reserved for future use.
    };

    


    /** Structure to get or set port information.
     * This structure is used by BoardCfgSet() and BoardCfgGetL() to set and get
     * configuration data of the ports.
     */
    struct BoardCfg_t
    {
      IPS_Ref_t Location;               ///< The board location and port.
      IPS_Ref_t BackupLocation;         ///< For ASI a backup input can be specified.
      string UserName;                  ///< A user defined name. Max. 40 characters.
      eIOInterfaceType IOInterfaceType; ///< The type of the port (ASI/GbE).
      eIOType IOType;                   ///< The direction of the port.
      boolean Enabled;                  ///< Whether this port is enabled or disabled.
      unsigned long PortProperty;       ///< Read only Bitmap used by GUI to display specific icons.
                                        /// Bit: 0 Individual GbE port streaming state
                                        /// Bit: 1 This port is an SFP port (GbE, Sdi, ...). A user can plug in an appropriate SFP.
                                        /// Bit: 2 This port is a DetMux RDCS TS port.
                                        /// Bit: 31 Monitoring port, restricted functionality
                                        /// Other bits: Future use. (0 for the moment) 
    };


    /** Enum to denote the port mode
	 * Note: Only ASI and Gbe ports can be set in AutoEnabled mode.
     */
    enum ePortEnabledMode
    {
        ePortMode_Enabled,           ///< Port is configured enabled
        ePortMode_Disabled,          ///< Port is configured disabled
        ePortMode_AutoEnabled,       ///< Port is configured auto enabled, will be enabled/disabled depending
                                    ///  on whether the device is active or in backup.
        ePortMode_Reserved4,         ///< Reserved for future use
        ePortMode_Reserved5,         ///< Reserved for future use
        ePortMode_Reserved6,         ///< Reserved for future use
        ePortMode_Reserved7,         ///< Reserved for future use
        ePortMode_Reserved8,          ///< Reserved for future use
        ePortMode_Reserved9,          ///< Reserved for future use
        ePortMode_Reserved10          ///< Reserved for future use
    };


    /** Structure to get or set port information. - version 2
     * This structure is used by BoardCfg_V2_Set() and BoardCfg_V2_GetL() to set and get
     * configuration data of the ports.
     * 
     * @version Release 8.1
     */
    struct BoardCfg_V2_t
    {
      IPS_Ref_t Location;                   ///< The board location and port.
      IPS_Ref_t BackupLocation;             ///< For ASI a backup input can be specified.
      string UserName;                      ///< A user defined name. Max. 40 characters.
      eIOInterfaceType_V2 IOInterfaceType;  ///< The type of the port (ASI/GbE).
      eIOType_V2 IOType;                    ///< The direction of the port.
      ePortEnabledMode PortEnabledMode;     ///< How the port mode is configured.
      boolean EnabledStatus;                ///< Whether the status of this port is enabled or disabled.
      unsigned long PortProperty;           ///< Read only Bitmap used by GUI to display specific icons.
                                            /// Bit: 0 Individual GbE port streaming state
                                            /// Bit: 1 This port is an SFP port (GbE, Sdi, ...). A user can plug in an appropriate SFP.
                                            /// Bit: 2 This port is a DetMux RDCS TS port.
                                            /// Bit: 31 Monitoring port, restricted functionality
                                            /// Other bits: Future use. (0 for the moment) 
    };


    
    enum ePortDisableMode
    {
      ePortDisable_PortOnly,    ///< If the port is disabled and the disable mode is set to port only, the link is enabled. 
      ePortDisable_FullLink     ///< If the port is disabled and the disable mode is set to full link, the link is disabled.
    };

    /// A sequence of BoardCfg_t entries.
    typedef sequence<BoardCfg_t> BoardCfg_List_t;

    /**
     * A sequence of BoardCfg_V2_t entries.
     */
    typedef sequence<BoardCfg_V2_t> BoardCfg_V2_List_t;

    /// A sequence of shorts used to filter ports.
    typedef sequence<unsigned short> PortList_t;
    
    /// A sequence of shorts used to filter boards
    typedef sequence<unsigned short> BoardList_t;

    /** Configuration values for Gbe port mode.
     * @version Release 8.0
     */
    enum eGbePortMode_t
    {
      ePortPairMode,         ///< ports are configured in bidirectional port pairs. 
      eIndividualPortMode,   ///< ports are configured in 2 input ports (1 and 3) and 2 output ports (2 and 4).
      eGbePortModeReserved1, ///< reserved for future use
      eGbePortModeReserved2, ///< reserved for future use
      eGbePortModeReserved3, ///< reserved for future use
      eGbePortModeReserved4, ///< reserved for future use
      eGbePortModeReserved5  ///< reserved for future use
    };

    
    // Board information IDLs
    // ------------------------------------------------------------------------------------
    /** Gets a list of present boards in the device and their board type.
     * This call will only return the board types used in eBoardType (ASI or GbE).
     * If other types of boards are present in the device, these boards are not returned.
     * For boards that are supported by DCM from release V6.9 onwards, the 
     * BoardGetL_V2 call should be used.
     *
     * @return BoardInfo_List_t A list of BoardInfo_t. 
     *
     * @exception OpNotSucceeded in case of internal error
     *
     * @note To get the version info, the @ref GetBoardId IDL should be used
     * @version Release 1.0
     */
    BoardInfo_List_t BoardGetL() 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Gets a list of present boards in the device and their board type.
     *
     * @return BoardInfo_List_V2_t A list of BoardInfo_V2_t. 
     *
     * @exception OpNotSucceeded in case of internal error
     *
     * @note To get the version info, the @ref GetBoardId IDL should be used
     * @version Release 6.9
     */
    BoardInfo_List_V2_t BoardGetL_V2() 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** (Deprecated) Gets the configuation of a number of ports.
     *
     * @param[in] BoardNumber An unsigned short to indicate the slot.
     * @param[in] PortList A sequence of ports to get information about. 
     *
     * @return BoardCfg_List_t A sequence of BoardCfg_t entries. 
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @exception OpNotSucceeded In case invalid references (BoardNumber, PortNbr) are used
     * @exception OpNotSucceeded when the port type is different from Asi, Gbe or SDI.
     *
     * @note Send an empty PortList to get info of all ports on the specified board. 
     * @deprecated Use BoardCfg_V2_GetL instead.
     */
    BoardCfg_List_t BoardCfgGetL(in unsigned short BoardNumber, in PortList_t PortList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** (Deprecated) Configure one port.
     *
     * @param[in] BoardCfg BoardCfg_t structure holding the information to set. 
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board.     
     * @exception OpNotSucceeded In case of
     * - Invalid references (BoardNumber, PortNumber,...).
     * - Invalid enum values (IOType, IOInterfaceType).
     * - changing the direction of an ASI port from IOType_CfgIn to IOType_CfgOut
     *   when input services are passed to an output or settings for input services are present
     * - Port name too long (> 40 char).
     *
     * @note 
     * - Switching a port from output to input: the device does the switch including
     *   deleting all routing information.
     * - Switching a port from input to output: the device does the switch if no services are passed 
     *   to an output, and no input service settings are present, otherwise an exception is generated.
     * - After switching the port from input -> output or vice versa, default
     *   settings will be applied.
     * - In port pair mode BoardCfg.enabled applies to the port pair (note that also reference of second 
     *   port can be used, but the settings of the first port will be used, e.g. some of the settings 
     *   provided in BoardCfg will be ignored). 
     * - In individual port mode (2I2O) mode each port can have a different value for BoardCfg.enabled.
     * - When this call is performed the port will be forced to enabled or disabled mode and the autoenabled 
     *   port mode settings might be lost.
     * @deprecated Use BoardCfg_V2_Set instead.
     */
    void BoardCfgSet(in BoardCfg_t BoardCfg) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Gets the configuation of a number of ports - version 2.
     *
     * @param[in] BoardNumber An unsigned short to indicate the slot.
     * @param[in] PortList A sequence of ports to get information about. 
     *
     * @return BoardCfg_V2_List_t A sequence of BoardCfg_V2_t entries. 
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @exception OpNotSucceeded In case invalid references (BoardNumber, PortNbr) are used 
     *
     * @note Send an empty PortList to get info of all ports on the specified board. 
     *
     * @version Release 8.1
     */
    BoardCfg_V2_List_t BoardCfg_V2_GetL(in unsigned short BoardNumber, in PortList_t PortList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Configure one port - version 2.
     *
     * @param[in] BoardCfg BoardCfg_V2_t structure holding the information to set. 
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board.     
     * @exception OpNotSucceeded In case of
     * - Invalid references (BoardNumber, PortNumber,...).
     * - Invalid enum values (IOType, IOInterfaceType).
     * - changing the direction of an ASI port from IOType_CfgIn to IOType_CfgOut
     *   when input services are passed to an output or settings for input services are present
     * - Port name too long (> 40 char).
     * - When in port pair mode and the port reference is a backup port.
     * - When you try to put a port of 8VSB, AudioGW, or VideoGW in AutoEnabled port mode.
     * @exception LicenseError When trying to enable a 8VSB port without a license available
     *
     * @note 
     * - Switching a port from output to input: the device does the switch including
     *   deleting all routing information.
     * - Switching a port from input to output: the device does the switch if no services are passed 
     *   to an output, and no input service settings are present, otherwise an exception is generated.
     * - After switching the port from input -> output or vice versa, default
     *   settings will be applied.
     * - In port pair mode BoardCfg.PortEnabledMode applies to the port pair. 
     * - In individual port mode (2I2O) mode each port can have a different value for BoardCfg.PortEnabledMode. 
     *
     * @version Release 8.1
     */
    void BoardCfg_V2_Set(in BoardCfg_V2_t BoardCfg) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OutOfRange, LicenseError);


    /** Configure the port disable mode for a GbE portset.
     *
     * @param[in] RefPhys The BoardNr and PortNr on which the mode must be set, only for GbE boards
     * @param[in] PortDisableMode The parameter of the port disable mode.
     *
     * @exception OpNotSupported When the board is not a GbE board, IP Video Adapter board or IP Audio Gateway board.
     * @exception OpNotSucceeded In case of
     * - Invalid references (BoardNumber, PortNumber,...), only valid on GbE board.
     * - Invalid enum values (PortDisableMode).
     *
     * @note 
     * - In port pair mode, port disable mode is set for both ports of the port pair when reference of first port is given.
     *   An OpNotSucceeded exception is returned if a reference of the second port in the port pair is provided. 
     * - In individual port mode (2I2O) mode it is possible to set the port disable mode for each individual port, 
     *   hence no exception is generated if the second port is given as port reference.
     */    
    void PortDisableModeSet(in IPS_Ref_t RefPhys, in ePortDisableMode PortDisableMode) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
      
    /** Request the port disable mode for a GbE portset.
     *
     * @param[in] RefPhys The BoardNr and PortNr on which the mode is requested, only for GbE boards
     * @param[out] PortDisableMode The requested port disable mode.
     *
     * @return PortDisableMode
     *
     * @exception OpNotSupported When the board is not a GbE board, IP Video Adapter board or IP Audio Gateway board.
     * @exception OpNotSucceeded In case of
     * - Invalid references (BoardNumber, PortNumber,...), only valid on GbE board.
     *
     * @note 
     * - In port pair mode only RefPhys of first port in port pair can be given (otherwise OpNotSucceeded is returned). 
     * - In 2I2O mode the physref of each port in the port pair can be provided.
     */      
    void PortDisableModeGet(in IPS_Ref_t RefPhys, out ePortDisableMode PortDisableMode) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Gets a list of all boards (hw) connected to a specified BoardNr.
     *
     * @param[in] BoardNr
     * @param[out] BoardList
     *
     * @return BoardList contains SlotNbr of connected boards
     *                       - for MB (BoardNr = 0): 1 = IO board in slot 1
     *                                               2 = IO board in slot 2 ...
     *                       - for IO (BoardNr > 0): 1 = transrater board
     *                                               2 = FEC board
     *                       - for IP Adapter (> 0): 1 = JPEG2K board
     * @exception OpNotSucceeded In case of invalid BoardNr
     */
    void BoardsConnected(in unsigned short BoardNr, out BoardList_t BoardList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    struct ComponentTemperature_t
    {
      string Name;         /**< Possible values:
                             * "FEC Die"     (I/O board, DaughterBoard 2)
                             * "FEC Ambient" (I/O board, DaughterBoard 2)
                             * "Ambient 1"   (Main board, DaughterBoard 0)
                             * "Ambient 2"   (Main board, DaughterBoard 0)
                             */
      long Temperature;    ///< The temperature of this component in degrees centigrade.
    };

    typedef sequence<ComponentTemperature_t> ComponentTemperature_List_t;

    struct BoardTemperature_t
    {
      unsigned short DaughterBoard; /**< The daughter board identification as returned in BoardsConnected.
                                     * 0: The board itself (main or I/O)
                                     * 1: Co-processor
                                     * 2: FEC
                                     */
      ComponentTemperature_List_t ComponentTemperature_List;
    };

    typedef sequence<BoardTemperature_t> BoardTemperature_List_t;

    /** Gets a list of all temperatures which can be measured.
     *
     * @param[in] BoardNr 0 for main board or 1..n for I/O boards.
     * @param[out] BoardTemperature_List list of components with their measured temperature.
     *
     * @exception OpNotSucceeded In case of invalid BoardNr
     */
    void BoardGetTemperatures(in unsigned short BoardNr, out BoardTemperature_List_t BoardTemperature_List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Gets the IP address, network mask, default gateway and MAC address for a mainboard interface.
     *
     * @param[in] RefPhys Specifies BoardNr & PortNr to get the IP params from.
     * @param[out] IPAddress
     * @param[out] SubNetMask 
     * @param[out] DefaultGw
     * @param[out] MacAddress 
     *
     * @return IPAddress Ip address of the interface
     * @return SubNetMask SubNetMask of the interface
     * @return DefaultGw Default gateway of the interface
     * @return MacAddress MAC address of the interface  
     *
     * @exception OpNotSupported When called for other boards than the mainboard
     * @exception OpNotSucceeded In case invalid references are used (RefPhys).
     *
     * @version Supported since release 5.1
     */
    void IPS_IP_ParamsMbGet(in IPS_Ref_t RefPhys, out string IPAddress, out string SubNetMask, out string DefaultGw, out string MacAddress) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);  
    
    /** Sets the IP address, network mask and default gateway for a mainboard interface.
      * When a valid gateway is specified, it replaces the currently existing default gateway.
      * To specify no gateway, use 0.0.0.0
      *
      * @param[in] RefPhys Specifies BoardNr & PortNr to set the IP params.
      * @param[in] IPaddress The new IP address
      * @param[in] SubNetMask The new netmask
      * @param[in] DefaultGw The default gateway or 0.0.0.0
      * @param[in] Apply Indicates if you only want to verify the setting or apply it as well
      * 
      * @exception OpNotSupported When called for other boards than the mainboard
      * @exception OpNotSucceeded In case invalid references are used (RefPhys).
      * @exception OpNotSucceeded In case an invalid IP address is given.
      * @exception OpNotSucceeded In case an invalid SubNetMask address is given.
      * @exception OpNotSucceeded In case an invalid Default gateway is given.
      *
      * @version Supported since release 8.5
      */
    void IPS_IP_ParamsMbSet(in IPS_Ref_t RefPhys, in string IPaddress, in string SubNetMask, in string DefaultGw, in boolean Apply)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Gets the IP address, network mask, default gateway and MAC address for a mainboard interface.
     *
     * @param[in] RefPhys Specifies BoardNr & PortNr to get the IP params from.
     * @param[out] IPAddress
     * @param[out] SubNetMask
     * @param[out] DefaultGw
     * @param[out] MacAddress
     *
     * @return IPAddress Ip address of the interface
     * @return SubNetMask SubNetMask of the interface
     * @return DefaultGw Default gateway of the interface
     * @return MacAddress MAC address of the interface
     *
     * @exception OpNotSupported When called for other boards than the mainboard
     * @exception OpNotSupported When called on DCM without IPv6 kernel stack
     * @exception OpNotSucceeded In case invalid references are used (RefPhys).
     *
     * @version Supported since release 8.2
     * @note !!!! EXPERIMENTAL - DO NOT USE !!!!
     */
    void IPS_IPv6_ParamsMbGet(in IPS_Ref_t RefPhys, out string IPAddress, out string SubNetMask, out string DefaultGw, out string MacAddress)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Sets the IP address, network mask, default gateway and MAC address for a mainboard interface.
     *
     * @param[in] RefPhys Specifies BoardNr & PortNr to set the IP params from.
     * @param[in] IPAddress
     * @param[in] SubNetMask
     * @param[in] DefaultGw
     *
     * @return IPAddress Ip address of the interface
     * @return SubNetMask SubNetMask of the interface
     * @return DefaultGw Default gateway of the interface
     *
     * @exception OpNotSupported When called for other boards than the mainboard
     * @exception OpNotSupported When called on DCM without IPv6 kernel stack
     * @exception OpNotSucceeded In case invalid references are used (RefPhys).
     *
     * @version Supported since release 8.2
     * @note !!!! EXPERIMENTAL - DO NOT USE !!!!
     */
    void IPS_IPv6_ParamsMbSet(in IPS_Ref_t RefPhys, in string IPAddress, in string SubNetMask, in string DefaultGw)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    struct IP_Subnet_t
    {
      /** Read only bitmap containing properties for this Subnet
       *  Bit 0: Read only  This subnet is automatically configured and cannot be changed
       *  Bit 1: Main      - This subnet is the main subnet
       */
      unsigned long Properties; 
      string         IP_Addr;
      unsigned short PrefixLength;
      string         DefaultGateway;
      IP_List_t      AliasList;
    };

    /// A sequence of IP_Subnet_t.
    typedef sequence<IP_Subnet_t> IP_SubnetList_t;

    /** Gets all the IP addresses, prefix lengths, default gateways, aliases and MAC address for a mainboard interface.
     *
     * @param[in] RefPhys Specifies BoardNr & PortNr to get the IP params from.
     * @param[out] IPConfig
     * @param[out] MacAddress 
     *
     * @return IPConfig IP configuration of the interface
     * @return MacAddress MAC address of the interface
     *
     * @exception OpNotSupported When called for other boards than the mainboard
     * @exception OpNotSucceeded In case invalid references are used (RefPhys).
     * @exception OperationFailed
     *
     * @version Supported since release 10.10
     */
    void IPS_IP_ParamsMbGet_V2(in IPS_Ref_t RefPhys, out IP_SubnetList_t IPConfig, out string MacAddress) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);  
    
    /** Sets all the IP addresses, prefix lengths, default gateways and aliases for a mainboard interface.
      * When a valid gateway is specified, it replaces the currently 
      * existing default gateway.
      * To specify no gateway, use "0.0.0.0" or "::"
      *
      * @param[in] RefPhys Specifies BoardNr & PortNr to set the IP params.
      * @param[in] IPConfig The new IP configuration
      * @param[in] Apply Indicates if you only want to verify the setting or apply it as well
      * 
      * @exception OpNotSupported When called for other boards than the mainboard
      * @exception OpNotSucceeded In case invalid references are used (RefPhys).
      * @exception OpNotSucceeded In case an invalid IP configuration is given.
      * @exception OperationFailed
      * 
      * @note Per protocol (IPv4 or IPv6) only one subnet may have a default gateway entered.  
              The default gateway for IPv4 doesn't need to be on the same interface as for IPv6.
      * 
      * @version Supported since release 10.10
      */
    void IPS_IP_ParamsMbSet_V2(in IPS_Ref_t RefPhys, in IP_SubnetList_t IPConfig, in boolean Apply)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    
    /** Set the given board in either individual port mode (2I2O) or port pairs mode
     * 
     * @param[in] BoardNr contains board number
     * @param[in] Mode    specifies the board mode to be set
     *
     * @exception OpNotSupported when board nbr does not match a Gbe IO board
     * @exception OpNotSucceed   when port mirroring or backup is active
     *
     * @version Supported since release 8.0
     */
    void SetGbePortMode(in unsigned short BoardNr, in eGbePortMode_t Mode)
      raises (TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Returns the Gbe port mode of the given board
     *
     * @param[in] BoardNr contains board number.
     *
     * @return configured Gbe port mode.
     *
     * @exception OpNotSupported : when board nbr does not match a Gbe IO board
     *
     * @version Supported since release 8.0
     */
    eGbePortMode_t GetGbePortMode(in unsigned short BoardNr)
      raises (TimeOut, OpNotAllowed, OpNotSupported);


    // NIC teaming: enums, structures and calls
    // ----------------------------------------
    

    /** NIC team configuration modes used in NicTeam_Settings.
     *
     * @version Release 11.10
     */
    enum eNicTeamMode
    {
      NicTeamMode_Revertive,    // Revertive mode
      NicTeamMode_Floating,     // Floating mode
      NicTeamMode_Reserved3,
      NicTeamMode_Reserved4,
      NicTeamMode_Reserved5,
      NicTeamMode_Reserved6,
      NicTeamMode_Reserved7,
      NicTeamMode_Reserved8,
      NicTeamMode_Reserved9
    };


    /** Management port link status, used in NicTeam_MemberStatus_t.
     *
     * @version Release 11.10
     */
    enum eLinkStatus
    {
      LinkStatus_Down,          // Link is down
      LinkStatus_Up,            // Link is up
      LinkStatus_Reserved3,
      LinkStatus_Reserved4,
      LinkStatus_Reserved5,
      LinkStatus_Reserved6,
      LinkStatus_Reserved7,
      LinkStatus_Reserved8,
      LinkStatus_Reserved9
    };


    // a sequence of IPS_Ref_t to identify NIC team members.
    typedef sequence<IPS_Ref_t> NicTeam_MemberList_t;


    /** Structure to get or set NIC team configuration.
     *
     * @version Release 11.10
     */
    struct NicTeam_Settings
    {
      boolean bNicTeam_Enabled;
      eNicTeamMode Mode;               // Currently fixed to Revertive
      NicTeam_MemberList_t MemberList; // Currently fixed to defaults. The team takes the settings of the first port in this list.
      unsigned long UpDelay;          // delay in ms, will be rounded to nearest multiple of 100ms. Range: [0-300000]
      unsigned long DownDelay;        // delay in ms, will be rounded to nearest multiple of 100ms. Range: [0-300000]
    };


    /** Structure describing the status of a NIC team member.
     *
     * @version Release 11.10
     */
    struct NicTeam_MemberStatus_t
    {
      IPS_Ref_t Port;
      eLinkStatus Status;
      unsigned long FailureCount;
    };


    // a sequence of NicTeam_MemberStatus_t.
    typedef sequence<NicTeam_MemberStatus_t> NicTeam_MemberStatusList_t;


    /** Structure to get NIC team status.
     *
     * @version Release 11.10
     */
    struct NicTeamStatus
    {
      IPS_Ref_t ActivePort;
      NicTeam_MemberStatusList_t MemberStatusList;
    };


    /** Get the NIC team status.
     *
     * @param[out] status The NIC team status.
     *
     * @exception OperationFailed When NIC teaming is disabled.
     *
     * @version Release 11.10
     *
     */
    void GetNicTeamStatus(out NicTeamStatus status)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);


    /** Get the NIC team configuration.
     *
     * @param[out] settings The NIC team configuration.
     *
     * @version Release 11.10
     *
     */
    void GetNicTeamSettings(out NicTeam_Settings settings)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);


    /** Set the NIC team configuration.
     *
     * @param[in] settings The NIC team configuration to set.
     *
     * @exception OperationFailed in case the configuration is invalid.
     *
     * @note This operation will cause the DCM to reboot if it enables or disables NIC
     * teaming or changes parameters while NIC teaming is enabled.
     *
     * @version Release 11.10
     *
     */
    void SetNicTeamSettings(in NicTeam_Settings settings)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    
    /// @} End of group config. 

    // MUX
    ///////////////////////////////////////////////////////////////////////////////////////  

    /** @defgroup mux Multiplexing
     * This contains types, enums and methods to configure the multiplexer part of the device.
     * @{
     */

    // General Mux Structures and enums
    // ------------------------------------------------------------------------------------
    /** @defgroup ts TS
     * This contains types, enums and methods to configure the TSs of the multiplexer part in the device.
     * @{
     */
    
    // TS Structures and enums
    // ------------------------------------------------------------------------------------
    
    /** Undefined Ref */
    const unsigned long INVALID_REF=0xffffffff;
    /** Only for input parameters. 
     *  If you want all TS on a port or board. 
     */
    const unsigned long ANY_REF=0xffffffff;
    /// A sequence of IPS_RefTS_t.
    typedef sequence<IPS_RefTS_t> IPS_RefTS_List_t;
        
    /// List of Ref's (In this case TS index's) to allow filtering.
    typedef sequence<unsigned long> Ref_List_t;

    /** Used by IPS_OutDefaultsSet() and IPS_OutDefaultsGet() 
     * indicating how the next socket must be generated.
     */
    enum eIPS_IncrScheme
    {
      IPS_Incr_IP,        ///< Take IP address + 1.
      IPS_Incr_Port1,     ///< Take UDP port + 1.
      IPS_Incr_Port2,     ///< Take UDP port + 2.
      IPS_Incr_IP1_Port1  ///< Take IP address + 1 and UDP port + 1.
    };

    /** The socket describes the IP address & UDP port on which a TS is played out.
     */
    struct IPS_UDP_Socket_t
    {
      string IP;           
      unsigned short Port; ///< Recommended UDP Port range: 1024 (0X400) .. 65535 (0xFFFF).
    };

    /** Transport stream type to guide interpretation and play out of elementary stream types.
     * This was formerly known as eOutputStandard.
     */
    enum eEsTypeStandard
    {
      eTransparent, ///< Can only be used as output standard.
      eDVB,         ///< Can only be used as input standard;
      eATSC,        ///< Can only be used as input standard
      eMOTOROLA,    ///< Can only be used as input standard;  Also known as Digicypher-II
      eForceUplink, ///< Can only be used as output standard
      eForceVideo,  ///< Can only be used as output standard; Previously known as SA mode.
      eForceAudio3  ///< Can only be used as output standard
    };
    
    const unsigned long BITMAP_INPUT_TS_EMMS_PRESENT           = 0x1;
    const unsigned long BITMAP_INPUT_TS_UNREF_PIDS_PRESENT     = 0x2;
    const unsigned long BITMAP_INPUT_TS_PRIV_DATA_EMMG         = 0x4;
    const unsigned long BITMAP_INPUT_TS_RTP_ON                 = 0x8;
    const unsigned long BITMAP_INPUT_TS_VLAN_ON               = 0x10; ///< May be senseless on input but let's try to be symmetrically.
    const unsigned long BITMAP_INPUT_TS_VBR_ON                = 0x20; ///< May be senseless on input but let's try to be symmetrically.
    const unsigned long BITMAP_INPUT_TS_ROUTED                = 0x40; ///< Will be set when any component is routed to an output. 
    const unsigned long BITMAP_INPUT_TS_INPUT_PRESENT         = 0x80; ///< Will be set when there is signal detected.
    const unsigned long BITMAP_INPUT_TS_ALARM_ACTIVE         = 0x100; ///< Will be set when Asi sync Loss of UDP Stream Loss detected.
    const unsigned long BITMAP_INPUT_TS_FEC_COL_PRESENT      = 0x200; ///< Will be set when FEC column stream is present.
    const unsigned long BITMAP_INPUT_TS_FEC_ROW_PRESENT      = 0x400; ///< Will be set when FEC row stream is present.    
    const unsigned long BITMAP_INPUT_TS_IN_BACKUP            = 0x800; ///< Will be set when TS is in Backup.    
    const unsigned long BITMAP_INPUT_TS_UNREF_PIDS_ROUTED   = 0x1000; ///< Will be set when unreferenced PIDs are routed.
    const unsigned long BITMAP_INPUT_TS_TSLOSS_ALARM_ACTIVE = 0x2000; ///< Will be set when TsLoss Alarm is active (backup trigger).

    /** Information of an incoming TS.
     */
    struct IPS_InputTS_t
    {
      IPS_RefTS_t RefIn;              ///< The location of the TS (Board, Port and Ref).
      IPS_UDP_Socket_t Socket;        ///< Unique IP-Address and UDP port combination.
      unsigned long TSID;             ///< TSID range: [0..65535]
      unsigned long ONID;             ///< ONID range: [0..65535]
      unsigned long NumberOfServices; ///< Number of services present on this input TS
      /** Read only Bitmap used by GUI to display specific icons (@see BITMAP_INPUT_TS_EMMS_PRESENT etc.)
       * - Bit 0: TRUE if EMM pids are present in the TS
       * - Bit 1: TRUE if unreferenced pids are present in the TS
       * - Bit 2: TRUE if PrivateDataEMMG pids are present in the TS
       * - Bit 3: TRUE if RTP is streamed (reserved for future use)
       * - Bit 4: TRUE if VLAN is used (reserved for future use)
       * - Bit 5: TRUE if VBR is used (reserved for future use)
       * - Bit 6: TRUE if TS is routed
       * - Bit 7: TRUE if TS is present at the input
       * - Bit 8: TRUE if UDP Stream Loss/ASI TS Sync Loss alarm is active. From V10.10 also if CC error is active.
       * - Bit 9: TRUE if FEC column stream is present.
       * - Bit10: TRUE if FEC row stream is present.
       * - Bit11: TRUE if TS is in Backup.
       * - Bit12: TRUE if unreferenced PIDs are routed.
       * - Bit13: TRUE if TsLoss Alarm is active (backup trigger).
       */
      unsigned long TS_InProperty;    
      eEsTypeStandard InputStandard; ///< Indicates how different PID (ES) types must be interpreted.
    };

    /** Gbe information of an incoming TS.
     */
    struct IPS_Gbe_InputTS_t
    {
      IPS_RefTS_t RefIn;              ///< The location of the TS (Board, Port and Ref).
      IPS_UDP_Socket_t Socket;        ///< Unique IP-Address and UDP port combination.
      string SourceIP;                ///< The source IP-Address of the incoming TS.
    };

    struct Debug_Gbe_InputTS_t
    {
      IPS_RefTS_t       RefIn;      ///< The location of the TS (Board, Port and Ref).
      IPS_UDP_Socket_t  Socket;     ///< Unique IP-Address and UDP port combination.
      string            SourceIP;   ///< The source IP-Address of the incoming TS.
      unsigned long     HwIndex;    ///< The hardware index for a stream
    };
    /// A sequence of IPS_Gbe_InputTS_t entries.
    typedef sequence<Debug_Gbe_InputTS_t>Debug_Gbe_InputTS_List_t;
    
    /** Information to change an incoming TS.
     */
    struct IPS_ChangeInputTS_t
    {
      IPS_RefTS_t RefIn;              ///< The location of the TS (Board, Port and Ref).
      eEsTypeStandard InputStandard; ///< Indicates how different PID (ES) types must be interpreted.
    };

    /// Describes if the TS is streaming or not.
    enum eIPS_StreamingState
    {
      IPS_Streaming_Active,
      IPS_Streaming_Paused
    };

    /// Describes when the TS should stream.
    enum enStreamingSetting_t
    {
      eStreamingSetting_On,         ///< TS should stream
      eStreamingSetting_Off,        ///< TS should not stream
      eStreamingSetting_Auto,       /**< TS should stream except for:
                                     * - ASI port - Auto will stop streaming as long as TS Out Stream loss alarm is active.
                                     * - Gbe port - Auto will stop streaming as long as TS Out Stream loss alarm is active.
                                     * - ASI port in DTF  - Auto will behave similar as On.
                                     * - For Transparent Loop Through TSs- Auto will behave similar as On.
                                     */ 
      eStreamingSetting_Reserved4,  ///< Reserved for future use
      eStreamingSetting_Reserved5,  ///< Reserved for future use
      eStreamingSetting_Reserved6,  ///< Reserved for future use
      eStreamingSetting_Reserved7,  ///< Reserved for future use
      eStreamingSetting_Reserved8,  ///< Reserved for future use
      eStreamingSetting_Reserved9,  ///< Reserved for future use
      eStreamingSetting_Reserved10  ///< Reserved for future use  
    };

    /// A sequence of IPS_InputTS_t entries.
    typedef sequence<IPS_InputTS_t> IPS_InputTS_List_t;
    
    /// A sequence of IPS_Gbe_InputTS_t entries.
    typedef sequence<IPS_Gbe_InputTS_t> IPS_Gbe_InputTS_List_t;

    /// A sequence of IPS_ChangeInputTS_t entries.
    typedef sequence<IPS_ChangeInputTS_t> IPS_ChangeInputTS_List_t;
    
    const unsigned long BITMAP_OUTPUT_TS_EMMS_PRESENT        = 0x1;
    const unsigned long BITMAP_OUTPUT_TS_UNREF_PIDS_PRESENT  = 0x2;
    const unsigned long BITMAP_OUTPUT_TS_PRIV_DATA_EMMG      = 0x4;
    const unsigned long BITMAP_OUTPUT_TS_RTP_ON              = 0x8;
    const unsigned long BITMAP_OUTPUT_TS_VLAN_ON             = 0x10;
    const unsigned long BITMAP_OUTPUT_TS_VBR_ON              = 0x20;
    const unsigned long BITMAP_OUTPUT_TS_FEC_COL_PRESENT     = 0x200; ///< Will be set when FEC column stream is enabled
    const unsigned long BITMAP_OUTPUT_TS_FEC_ROW_PRESENT     = 0x400; ///< Will be set when FEC row stream is enabled
    
    /** Information-Settings of an outgoing TS.
     */
    struct Debug_Gbe_OutputTS_t
    {
      IPS_RefTS_t       RefOut;     ///< The location of the TS (Board, Port and Ts Ident).
      IPS_UDP_Socket_t  DestSocket; ///< Unique destination IP-Address and UDP port combination.
      unsigned long     HwIndex;    ///< The hardware index for a stream
    };
    /// A sequence of Debug_Gbe_OutputTS_t entries.
    typedef sequence<Debug_Gbe_OutputTS_t>Debug_Gbe_OutputTS_List_t;
      
    struct IPS_OutputTS_t
    {
      IPS_RefTS_t Ref;              ///< The location of the TS (Board, Port and Ref).
      IPS_UDP_Socket_t Socket;      ///< Unique IPv4-Address and UDP port combination.
      unsigned long Bitrate; /**< Bitrate of the outgoing TS (in bps).
                              * - ASI port - Output Mode = packet - range: 0.1Mbps..200Mbps.
                              * - ASI port - Output Mode = byte - range: 0.1Mbps..155Mbps.
                              * - GbE port - range: 0.1 Mbps..950 Mbps (per udp port).
                              *
                              * @note The sum of all bitrates of TS's that are not paused on a GbE port
                              * can't be more than 950 Mbps.
                              */
      eIPS_StreamingState State;
      unsigned long TSID; ///< TSID range: 0..65535.
      unsigned long ONID; ///< ONID range: 0..65535.
      unsigned long NumberOfServices; ///< Number of services present on this output TS
      unsigned long TS_OutProperty; ///< Read only Bitmap used by GUI to display specific icons (@see BITMAP_OUTPUT_TS_EMMS_PRESENT etc.)
                                    ///< Bit  0: TRUE if EMM pids are present in the TS
                                    ///< Bit  1: TRUE if unreferenced pids are present in the TS
                                    ///< Bit  2: TRUE if PrivateDataEMMG pids are present in the TS
                                    ///< Bit  3: TRUE if RTP is streamed
                                    ///< Bit  4: TRUE if VLAN is enabled
                                    ///< Bit  5: TRUE if VBR is enabled
                                    ///< Bit  9: TRUE if FEC column stream is enabled
                                    ///< Bit 10: TRUE if FEC row stream is enabled
                                    ///< Bit 11: TRUE if SFN is enabled
                                    ///< Bit 12: TRUE if DetMux RDCS TS is enabled
      eEsTypeStandard OutputStandard; ///< Indicates how different PID (ES) types must be interpreted. 
    };

    /// A sequence of IPS_OutputTS_t entries.
    typedef sequence<IPS_OutputTS_t> IPS_OutputTS_List_t;

    /** Information-Settings of an outgoing TS.
     */
    struct IPS_OutputTS_V2_t
    {
      IPS_RefTS_t Ref;              ///< The location of the TS (Board, Port and Ref).
      IPS_UDP_Socket_t Socket;      ///< Unique IPv4-Address and UDP port combination.
      unsigned long Bitrate; /**< Bitrate of the outgoing TS (in bps).
                              * - ASI port - Output Mode = packet - range: 0.1Mbps..200Mbps.
                              * - ASI port - Output Mode = byte - range: 0.1Mbps..155Mbps.
                              * - GbE port - range: 0.1 Mbps..950 Mbps (per udp port).
                              *
                              * @note The sum of all bitrates of TS's that are not paused on a GbE port
                              * can't be more than 950 Mbps.
                              */
      enStreamingSetting_t Setting; /**< Streaming setting of the outgoing TS.
                                     * - ASI port - Auto will stop streaming as long as TS Out Stream loss alarm is active.
                                     * - Gbe port - Auto will stop streaming as long as TS Out Stream loss alarm is active.
                                     * - ASI port in DTF  - Auto will behave similar as On.
                                     */
      eIPS_StreamingState State;    /// Read only state       
      unsigned long TSID; ///< TSID range: 0..65535.
      unsigned long ONID; ///< ONID range: 0..65535.
      unsigned long NumberOfServices; ///< Number of services present on this output TS
      unsigned long TS_OutProperty; ///< Read only Bitmap used by GUI to display specific icons (@see BITMAP_OUTPUT_TS_EMMS_PRESENT etc.)
                                    ///< Bit  0: TRUE if EMM pids are present in the TS
                                    ///< Bit  1: TRUE if unreferenced pids are present in the TS
                                    ///< Bit  2: TRUE if PrivateDataEMMG pids are present in the TS
                                    ///< Bit  3: TRUE if RTP is streamed
                                    ///< Bit  4: TRUE if VLAN is enabled
                                    ///< Bit  5: TRUE if VBR is enabled
                                    ///< Bit  9: TRUE if FEC column stream is enabled
                                    ///< Bit 10: TRUE if FEC row stream is enabled
                                    ///< Bit 11: TRUE if SFN is enabled
                                    ///< Bit 12: TRUE if DetMux RDCS TS is enabled
      eEsTypeStandard OutputStandard; ///< Indicates how different PID (ES) types must be interpreted.
    };

    /// A sequence of IPS_OutputTS_V2_t entries.
    typedef sequence<IPS_OutputTS_V2_t> IPS_OutputTS_List_V2_t;

    /** Structure to find a specific TS by IP-address and UDP port.
     */
    struct IPS_LookupTS_t
    {   
      boolean bInput;           ///< Indicates if it is an input or output TS
      IPS_Ref_t Ref;            ///< The location to search (Board, Port). Board number is ignored.
      IPS_UDP_Socket_t Socket;  ///< Will be ignored on ASI board
    };

    /** Structure to find a specific TS by IP-address and UDP port.
     */
    struct IPS_ReferenceTS_t
    {
      IPS_LookupTS_t LookUpTS;
      unsigned long  Ref;  /** < This is really a TS index. If the LookUpTS cannot be found, 
                           0xFFFFFFFF will be filled in (= INVALID_ITF_REF) */
    };

    /// A sequence of IPS_LookupTS_t entries.
    typedef sequence<IPS_LookupTS_t> IPS_LookupTS_List_t;
    
    /// A sequence of IPS_ReferenceTS_t entries.
    typedef sequence<IPS_ReferenceTS_t> IPS_ReferenceTS_List_t;

    /** Used for PID passing by IPS_OutPID_AddL(), IPS_OutPID_GetL() and IPS_OutPID_DeleteL()
     */
    struct IPS_OutPID_Data_t
    {
      IPS_RefTS_t RefOut;
      IPS_RefTS_t RefIn;
      unsigned short InputPID;
      unsigned short OutputPID;
    };
  
    /// A sequence of IPS_OutPID_Data_t.
    typedef sequence<IPS_OutPID_Data_t> IPS_OutPID_DataList_t;

    /// PID types.
    enum ePID_Type
    {
      ePID_TypeEMM,
      ePID_TypeUnref,
      ePID_TypeForced,
      ePID_TypePrivateDataEMMG
    };


    struct IPS_OutPID_Data2_t
    {
      IPS_RefTS_t RefOut;
      IPS_RefTS_t RefIn;
      unsigned short InputPID;
      unsigned short OutputPID;
      boolean FixedPIDRemap;   ///< If Output PID is fixed, this variable is true.
      //ePIDPassingStatus PIDStatus;   ///< OPTIONAL : Measurement, can be different from setting.
      /*ePIDPassingStatus PIDSetting;  /**< OPTIONAL : Set by user, can only be ePID_StatusBlockedByUser or ePID_StatusPassed.
                                            Is changed through the IPS_PassBlockPids IDL call.*/

      unsigned long PID_Property;  ///< Read only Bitmap used by GUI to display specific icons
                                   ///< Bit 0: PID present in input TS or not
                                   ///<        TRUE means present
                                   ///<        FALSE: PID not present
                                   ///<        Remark: present or not present is based on SI
                                   ///<        For unreferenced pids based upon presence of input pid
                                   ///< Bit 1: ignore bit (used as scrambling bit in valid component/service)
                                   ///< Bit 4: input pid scrambled
                                   ///<        TRUE means scrambled
      long CASystemID;      ///< Only for EMMs: to which CA system does the EMM belong. 
    };
    /// A sequence of IPS_OutPID_Data2_t.
    typedef sequence<IPS_OutPID_Data2_t> IPS_OutPID_Data2List_t;

    struct IPS_InPID_Data_t
    {
      IPS_RefTS_t     RefIn;
      unsigned short  InputPID;
      long CASystemID;      ///< Only for EMMs: to which CA system does the EMM belong. 
    };
    /// A sequence of IPS_InPID_Data_t.
    typedef sequence<IPS_InPID_Data_t> IPS_In_PID_List_t;
    
    struct IPS_InPID_Data_V2_t
    {
      IPS_RefTS_t     RefIn;
      unsigned short  InputPID;
      long            CASystemID;    ///< Only for EMMs: to which CA system does the EMM belong. 
      unsigned long   PID_Property;  ///< Read-only bitmap used by GUI to display specific icons
                                     ///< Bit 0: input signal present (true) or not (false)
    };
    /// A sequence of IPS_InPID_Data_V2_t.
    typedef sequence<IPS_InPID_Data_V2_t> IPS_In_PID_List_V2_t;

    /// Identification of which PID to be created/deleted.
    /// Note this is duplicated by RefPid_t but must remain for backwards compatability
    struct InEMM_Ref_t
    {
      IPS_RefTS_t m_RefTS;        ///< The Slot, Port and Index of the input TS.
      unsigned short m_usPID;     ///< The reference to the input EMM pid
    };
    /// A sequence of InEMM_Ref_t.
    typedef sequence< InEMM_Ref_t > InEMM_RefList_t;

    /// Identification of EMMG EMMs
    struct EMM_Data_t
    {
      string        ProxyName;
      ePID_Type     Type;
      unsigned long ClientID;
      unsigned long ChannelID;
      unsigned long StreamID;
      unsigned long DataID;
      InEMM_Ref_t   EMM_Ref;
    };

    /// a sequence of EMM_Data_t
    typedef sequence< EMM_Data_t > EMM_DataList_t;

    enum eMpegStandard
    {
      eStdMpeg2,
      eStdDvb,
      eStdATSC
    };
    
    /* A identifer of a table (PAT,CAT...)
     * it is called Ref_SI_table_ext_t to avoid confusion 
     * with Ref_SI_table_t in Embedded Software (same struct without string)
     * GUI must send back exactly what it received.
     */
    struct Ref_SI_table_ext_t
    {
      eMpegStandard Standard;
      unsigned short table_id;
      unsigned short table_type; //not used for dvb, but necessary for atsc. Must be 0xFFFF when not used.
      string TableName; // is ignored in a set call
    };
    
    /// Pid passing and blocking statuses.
    enum ePIDPassingStatus
    {
      ePID_StatusBlockedByUser,           ///< Blocked through the IPS_PassBlockPids IDL call.
      ePID_StatusPassed,                  ///< Passed ES PIDs or Transparent SI PIDs, read/write. Cannot be changed for SI.
      ePID_StatusGenerated,               ///< Only for SI, readonly.
      ePID_StatusBlockedBySystem,         ///< Blocked through inheritance (parent is blocked so block the children).
      ePID_StatusNotPassed,               ///< PID removed from output, cannot be changed for SI (initial value).
      ePID_StatusTransparent,             ///< Only for SI, to be used through the Get/SetSI_Generation call.
      ePID_StatusTransparentRegeneration, ///< Only for SI, to be used through the Get/SetSI_Generation call.
      ePID_StatusStopped,                 ///< Stop playout of an SI Pid.
      ePID_StatusBlockedByDPI,            ///< Blocked by DPI because no valid rule was present in custom mode.
      ePID_StatusBlockedByTsRule,         ///< Blocked by TS rule because Service_AutoPassRules block new service components.      
      ePID_StatusBlockedBySvcRule         ///< Blocked by Service rule (e.g. blockCAInfo)
    };

    /// Pid passing and blocking statuses.
    enum ePIDPassingStatus_V2
    {
      ePID_Status_V2_BlockedByUser,           ///< Blocked through the IPS_PassBlockPids IDL call.
      ePID_Status_V2_Passed,                  ///< Passed ES PIDs or Transparent SI PIDs, read/write. Cannot be changed for SI.
      ePID_Status_V2_Generated,               ///< Only for SI, readonly.
      ePID_Status_V2_BlockedBySystem,         ///< Blocked through inheritance (parent is blocked so block the children).
      ePID_Status_V2_NotPassed,               ///< PID removed from output, cannot be changed for SI (initial value).
      ePID_Status_V2_Transparent,             ///< Only for SI, to be used through the Get/SetSI_Generation call.
      ePID_Status_V2_TransparentRegeneration, ///< Only for SI, to be used through the Get/SetSI_Generation call.
      ePID_Status_V2_Stopped,                 ///< Stop playout of an SI Pid.
      ePID_Status_V2_BlockedByDPI,            ///< Blocked by DPI because no valid rule was present in custom mode.
      ePID_Status_V2_BlockedByTsRule,         ///< Blocked by TS rule because Service_AutoPassRules block new service components.      
      ePID_Status_V2_BlockedBySvcRule,        ///< Blocked by Service rule (e.g. blockCAInfo)
      ePID_Status_V2_AutoPassed,              ///< Only for SI, read only, indicates subtable autopassing
      ePID_Status_V2_Reserved12,
      ePID_Status_V2_Reserved13,
      ePID_Status_V2_Reserved14,
      ePID_Status_V2_Reserved15,
      ePID_Status_V2_Reserved16,
      ePID_Status_V2_Reserved17,
      ePID_Status_V2_Reserved18,
      ePID_Status_V2_Reserved19,
      ePID_Status_V2_Reserved20,
      ePID_Status_V2_Reserved21,
      ePID_Status_V2_Reserved22,
      ePID_Status_V2_Reserved23,
      ePID_Status_V2_Reserved24,
      ePID_Status_V2_Reserved25,
      ePID_Status_V2_Reserved26,
      ePID_Status_V2_Reserved27,
      ePID_Status_V2_Reserved28,
      ePID_Status_V2_Reserved29,
      ePID_Status_V2_Reserved30,
      ePID_Status_V2_Reserved31,
      ePID_Status_V2_Reserved32,
      ePID_Status_V2_Reserved33,
      ePID_Status_V2_Reserved34,
      ePID_Status_V2_Reserved35,
      ePID_Status_V2_Reserved36,
      ePID_Status_V2_Reserved37,
      ePID_Status_V2_Reserved38,
      ePID_Status_V2_Reserved39
    };

    struct SI_Table_Period_t
    {
      Ref_SI_table_ext_t Ref;
      unsigned long Period; //ms. Min=100ms, max=60000ms=60s
    };
    typedef sequence<SI_Table_Period_t> SI_Table_Period_List_t;

    /// Generation mode for SI tables
    struct SI_Table_GenerationMode_t
    {
      Ref_SI_table_ext_t  Ref;
      ePIDPassingStatus   Mode; // generation mode
    };
    typedef sequence<SI_Table_GenerationMode_t> SI_Table_GenerationMode_List_t;

    struct TS_SI_Table_Periods_t
    {
      IPS_RefTS_t TS;
      SI_Table_Period_List_t Periods; 
    };
    typedef sequence <TS_SI_Table_Periods_t> TS_SI_Table_Periods_List_t;

    struct TableKeys_t
    {
      unsigned long TableId;
      unsigned long OnId;       ///< Set to 0xFFFFFFFF when not used.
      unsigned long TsId;       ///< Set to 0xFFFFFFFF when not used.
      unsigned long TableIdExt; ///< SID,.... Set to 0xFFFFFFFF when not used.
    };

    typedef sequence<TableKeys_t> TableKeys_List_t;
    
    /// Structure that represents required data to construct TOT descriptor
    struct TOT_Timezone_t
    {
      string  m_CountryCode;
      octet   m_CountryRegionId;
      string  m_Timezone;
    };
    
    typedef sequence<TOT_Timezone_t> TOT_Timezone_List_t;

    /// Structure that represents required data to construct all TOT descriptors on a specific TS
    struct TS_TOT_Timezone_t
    {
      IPS_RefTS_t         TS;
      TOT_Timezone_List_t Timezones;
    };

    typedef sequence<TS_TOT_Timezone_t> TS_TOT_Timezone_List_t;
    
    typedef sequence <char> RoutingFileData_t;
    
    /// Result of routing file upload operation (pre-config - IPS_ProcessRoutingFile)
    enum eRoutingStatusResult
    {
      eRoutingResultSuccess,                ///< No warnings or errors
      eRoutingStatusSuccessWithWarnings,    ///< Warnings occurred
      eRoutingStatusSuccessWithErrors,      ///< Errors occurred
      eRoutingStatusFatalError              ///< File could not be processed.
    };
    
    /// Severity of error that occured during routing file upload (pre-config - IPS_ProcessRoutingFile)
    enum eRoutingStatusSeverity
    {
      eRoutingStatusWarning,                ///< Warning (could be executed)
      eRoutingStatusError,                  ///< Error (line could not be executed)
      eRoutingStatusFatal                   ///< File could not be processed.
    };
          
    /// Structure that contains information about one error that occurred during routing file upload (pre-config - IPS_ProcessRoutingFile)
    struct RoutingStatusRecord_t
    {
      long LineNumber;                      ///< Line number on which error occurred
      eRoutingStatusSeverity Severity;      ///< Warning, Error, Fatal
      string Message;                       ///< Text description of the error.
    };
    
    typedef sequence <RoutingStatusRecord_t> RoutingStatusRecord_List_t;

    typedef sequence <char> charSequence;


    /// Note RefPid_t is effectively a copy of InEMM_Ref_t but that must remain for compatability
    struct IPS_RefPid_t
    { 
      IPS_RefTS_t RefTS;    ///< The location (slot, port) and stream.
      unsigned short Pid;  ///< Value of the PID.
    };
    /// A sequence of IPS_RefPid_t.
    typedef sequence<IPS_RefPid_t> IPS_RefPidList_t;

    /// PID range: 0..8190
    typedef sequence<unsigned short> PID_List_t;

    /// Identification of muxed pids
    struct CompPidES_t
    {
      IPS_RefPid_t InputPid;    ///< Value of the PID at the input TS.
      unsigned long Sid;    ///< Value of the SID at the output TS.
      octet streamtype;     ///< streamtype as it will be added in the PMT.  Value: 0..255
    };

    /// A sequence of CompPidES_t.
    typedef sequence<CompPidES_t> CompPidESList_t;

    struct CompPidES_V2_t
    {
      IPS_RefPid_t InputPid; ///< Value of the PID at the input TS.
                             ///< If in the pid ref, board and port are set to 0xFFFF and input TS ref is 0xFFFFFFFF,
                             ///< this means it is a dummy output elementary stream.  A reference for this
                             ///< ES will be created in the outgoing PMT. On the output TS, the input pid value
                             ///< will be used as unique identifier and preferred output pid for the dummy ES.      
      unsigned long Sid;    ///< Value of the SID at the output TS.
      octet streamtype;     ///< streamtype as it will be added in the PMT.  Value: 0..255
      eEsTypeStandard EsTypeStandard; ///< The standard of the input TS : DVB, ATSC or Motorola 
                                      ///< (necessary to correctly interpret the ES type during matching)
                                      ///< Will only be used for dummy ES, else the real input TS standard
                                      ///< be used.
    };

    /// A sequence of CompPidES_V2_t.
    typedef sequence<CompPidES_V2_t> CompPidESList_V2_t;

    /// MPTS pass through settings.
    struct TS_AutoPassRules
    {
       IPS_RefTS_t InputRef;        ///< The input TS to monitor/subscribe to.
       boolean PassDeleteUnref;     ///< read-write; true = unreferenced pids auto passed/deleted;
                                    /// false = no auto pass/delete of unreferenced pids
       boolean PassKeepEMMs;        ///< read-write; true = EMMs auto passed ;
                                    /// false = no auto pass of EMMs
       boolean PassKeepServices;    ///< read-write; true = services auto passed ;
                                    /// false = no auto pass of services
    };
    /// A sequence of TS_AutoPassRules.
    typedef sequence<TS_AutoPassRules> TS_AutoPassRules_List_t;

    /// MPTS Passthrough disable flags
    struct TS_AutoPassRulesDisableFlags

    {
       boolean UnrefRuleDisabled;   ///< read-only; true = the unref PID rule is disabled by system; 
                                    ///             false = the unref PID rule can be configured by the user;
       boolean EMM_RuleDisabled;    ///< read-only; true = the EMM rule is disabled by system; 
                                    ///             false = the EMM rule can be configured by the user;
       boolean ServiceRuleDisabled; ///< read-only; true = the service rule is disabled by system; 
                                    ///             false the service rule can be configured by the user;
    };

    /// Default Service component behaviour.
    struct DefaultAutoPassRules
    {
       boolean PassDeleteESs;       ///< read-write; true = ESs are auto passed/deleted; false = block of ESs; default true
       boolean PassDeleteECMs;      ///< read-write; true = ECMs are auto passed/deleted; false = block of ECMs; default true
       boolean PassDeleteES_ECMs;   ///< read-write; true = ES_ECMs are auto passed/deleted; false = block of ES_ECMs
    };
    
    /// Service component behaviour.
    struct Service_AutoPassRules
    {
       boolean PassDeleteESs;       ///< read-write; true = ESs are auto passed/deleted; false = block of ESs; default true
       boolean PassDeleteECMs;      ///< read-write; true = ECMs are auto passed/deleted; false = block of ECMs; default true
       boolean PassDeleteES_ECMs;   ///< read-write; true = ES_ECMs are auto passed/deleted; false = block of ES_ECMs
       boolean ES_RuleDisabled;     ///< read-only; true = ES rule is disabled and PassDeleteESs cannot be changed by the user; 
                                    ///             false = PassDeleteESs can be configured by the user;
       boolean ECM_RuleDisabled;    ///< read-only; true = ECM rule is disabled and PassDeleteECMs cannot be changed by the user; 
                                    ///             false = PassDeleteECMs can be configured by the user;
       boolean ES_ECM_RuleDisabled; ///< read-only; true = ES_ECM rule is disabled and PassDeleteES_ECMs cannot be changed by the user; 
                                    ///             false = PassDeleteES_ECMs can be configured by the user;
    };

    // Auto-pass SI (EITo)
    struct SI_AutoPassRules_t
    {
      IPS_RefTS_t InputRef;           ///< TS from which to auto-pass
      unsigned short InputPid;        ///< PID from which to auto-pass
      unsigned long TableId;          ///< TID to auto-pass - Use 0x4F for EITo p/f
      unsigned short OutputPid;       ///< PID on which to play out autopassed tables
      TableKeys_List_t ExceptionList; ///< List of tables which will not be auto-passed.
    };

    typedef sequence<SI_AutoPassRules_t> SI_AutoPassRules_List_t;

    /// NIT in PAT mode
    enum eNitInPat
    {
      NitInPatOff,  ///< NIT never in PAT
      NitInPatOn,   ///< NIT always in PAT
      NitInPatAuto  ///< NIT in PAT when present (NIT mode != blocked) (default default)
    };

    /// Insert CAT Descriptors
    enum eInsertCATDescriptors
    {
      eInsertCATDescriptorsOnlyGenerated,        ///< Only when mode is generated
      eInsertCATDescriptorsGeneratedAndImported  ///< Also when imported (not when pure import)
    };
    struct OutTS_InsertCATDescriptors_t
    {
      IPS_RefTS_t RefTsOut;
      eInsertCATDescriptors InsertCATDescriptors;
    };
    typedef sequence<OutTS_InsertCATDescriptors_t> OutTS_InsertCATDescriptors_List_t;

    /// @deprecated Use V2 structure instead
    enum eTimeBaseSelectionMode
    {
      eTBS_Auto,                    ///< VBR mode, Firmware freely chooses a PCR PID and is allowed to switch
      eTBS_AutoReferredPCR,         ///< VBR mode, Software selects a PMT referenced PCR PID and locks it
      eTBS_ForcedPCR,               ///< VBR mode  User requests to use and lock the PCR PID referenced in the given Service Id.
      eTBS_CBR_Auto,                ///< CBR mode, firmware chooses a PCR PID and is allowed to switch
      eTBS_CBR_AutoReferredPCR,     ///< CBR mode, Software selects a PMT referenced PCR PID and locks it
      eTBS_CBR_ForcedPCR            ///< CBR mode, User requests to use and lock the PCR PID referenced in the given Service Id.
    };

    /// @deprecated Use V2 structure instead
    struct TimeBaseSelectionMode_t
    {
      eTimeBaseSelectionMode Mode;
      unsigned long SID;            ///< Only for eTBS_ForcedPCR: the ServiceId to be used/that is in use
      boolean FollowDefaultRule;    ///< Indicates if the TS follows the board level default.
    };

    /// @deprecated Use V2 structure instead
    struct InTS_TimeBaseSelectionMode_t
    {
      IPS_RefTS_t RefTSIn;
      TimeBaseSelectionMode_t TBS_Mode;
    };

    struct BoardDejitterCfg_t
    {
      unsigned short VbrLatency;        ///< The VBR dejitter latency in msec, should be 110ms <= latency <= 180
      unsigned short CbrLatency;        ///< The CBR dejitter latency in msec, should be 10 <= latency <= 110
      boolean        EnableCbrLatency;  ///< If true, CBR dejittered streams will use the CBR latency
    };

    enum eTimeBaseSelectionMode_V2
    {
      eTBS_V2_Auto,                    ///< VBR mode, Firmware freely chooses a PCR PID and is allowed to switch
      eTBS_V2_AutoReferredPCR,         ///< VBR mode, Software selects a PMT referenced PCR PID and locks it
      eTBS_V2_ForcedPCR,               ///< VBR mode  User requests to use and lock the PCR PID referenced in the given Service Id.
      eTBS_V2_CBR_Auto,                ///< CBR mode, firmware chooses a PCR PID and is allowed to switch
      eTBS_V2_CBR_AutoReferredPCR,     ///< CBR mode, Software selects a PMT referenced PCR PID and locks it
      eTBS_V2_CBR_ForcedPCR,           ///< CBR mode, User requests to use and lock the PCR PID referenced in the given Service Id.
      eTBS_V2_Reserved1,
      eTBS_V2_Reserved2,
      eTBS_V2_Reserved3,
      eTBS_V2_Reserved4,
      eTBS_V2_Reserved5,
      eTBS_V2_Reserved6,
      eTBS_V2_Reserved7,
      eTBS_V2_Reserved8,
      eTBS_V2_Reserved9
    };

    struct TimeBaseSelectionMode_V2_t
    {
      eTimeBaseSelectionMode_V2 Mode;
      unsigned long SID;            ///< Only for eTBS_ForcedPCR: the ServiceId to be used/that is in use
      boolean FollowDefaultRule;    ///< Indicates if the TS follows the board level default.
      boolean FastLockMode;
    };

    struct InTS_TimeBaseSelectionMode_V2_t
    {
      IPS_RefTS_t RefTSIn;
      TimeBaseSelectionMode_V2_t TBS_Mode;
    };

    /// @deprecated Use V2 structure instead
    typedef sequence<InTS_TimeBaseSelectionMode_t>    InTS_TimeBaseSelectionMode_List_t;

    typedef sequence<InTS_TimeBaseSelectionMode_V2_t> InTS_TimeBaseSelectionMode_List_V2_t;

#ifndef DISABLE_MUX_TS

    // TS IDLs
    // ------------------------------------------------------------------------------------
    /** Gets the TS indexes for a number of transport streams.
     *  If an input TS is looked up, this one will automatically be created when not found.
     *  This function can also be used for IP Video gateway and IP Audio Gateway boards.
     *
     * @param[in] BoardNumber An unsigned short to indicate the slot.
     * @param[in] LookUpTS_List A sequence of board/port/UDP port, ... for which TS Index is
     * to be returned.
     *
     * @return A IPS_ReferenceTS_List_t, a sequence of IPS_ReferenceTS_t entries with corresponding TSindex.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded when BoardNumber or Ref is invalid. 
     * - When looking up an INPUT GBE TS only a multicast ip address or else 0.0.0.0 should be used
     * - When a unicast IP address other than 0.0.0.0 is given to lookup an input TS, this is 
     * internally converted to 0.0.0.0
     * - 0.0.0.0 is used to identify the current unicast address of the GBE port
     */
    IPS_ReferenceTS_List_t IPS_Lookup_TSs(in unsigned short BoardNumber, in IPS_LookupTS_List_t LookUpTS_List) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed, OutOfRange);
    
    /** Gets the TS indexes for a number of transport streams.
     *  NO automatic creation will be done in any case.
     *  This function can also be used for IP Video gateway and IP Audio Gateway boards.
     *
     * @param[in] BoardNumber An unsigned short to indicate the slot.
     * @param[in] LookUpTS_List A sequence of board/port/UDP port, ... for which TS Index is
     * to be returned.
     *
     * @return A IPS_ReferenceTS_List_t, a sequence of IPS_ReferenceTS_t entries with corresponding TSindex.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded when BoardNumber or Ref is invalid. 
     */
    IPS_ReferenceTS_List_t IPS_FindTSs(in unsigned short BoardNumber, in IPS_LookupTS_List_t LookUpTS_List) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Reserves input TS
     * If a TS is created and not used (no services or PIDs passed from that TS or TS has no input settings) 
     * and the TS is not present at the input, it will be deleted after two minutes.
     * With this call it is possible to prevent that the TS will be deleted if it is not present.at the input
     *
     * @param[in] TS specifies BoardNr, PortNr.and TS
     * @param[in] Reserve Reserve flag: different from 0 if TS needs to be kept
     *                              0 (zero) if TS can be deleted if not present at the input
     * 
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @todo exception OpNotSucceeded When called for ASI boards or in case invalid references
     *                               (RefTS) are used. For the moment no exceptions are returned.
     * 
     */
    void ReserveInputTS(in IPS_RefTS_t TS, in unsigned long  Reserve)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get a list of incoming transport streams.
     *
     * @param[in] PhysRef The BoardNr and PortNr of which you want the information.
     * @param[in] RefList A Ref_List_t, sequence of Ref's (longs) you want info about.
     *
     * @return IPS_InputTS_List_t A sequence of IPS_InputTS_t entries.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid references( PhysRef, RefList) are used.
     *
     * @note 
     * - A value of 0xFFFF for port means all ports.
     * - An empty RefList means all refs.
     */
    IPS_InputTS_List_t IPS_InTS_GetL(in IPS_Ref_t PhysRef, in Ref_List_t RefList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
   
  /** Get a list of Gbe information of incoming transport streams.
     *
     * @param[in] PhysRef The BoardNr and PortNr of which you want the information.
     * @param[in] RefList A Ref_List_t, sequence of Ref's (longs) you want info about.
     *
     * @return IPS_Gbe_InputTS_List_t A sequence of IPS_Gbe_InputTS_t entries.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid references( PhysRef, RefList) are used.
     *
     * @note 
     * - A value of 0xFFFF for port means all ports.
     * - An empty RefList means all refs.
     */
    IPS_Gbe_InputTS_List_t IPS_Gbe_InTS_GetL(in IPS_Ref_t PhysRef, in Ref_List_t RefList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
  /** Get a list of Gbe information of incoming transport streams.
      *  Call mainly meant for troubleshooting information.
      * For each input transport stream, the "hardware index" is also returned now.
     *
     * @param[in] PhysRef The BoardNr and PortNr of which you want the information.
     * @param[in] RefList A Ref_List_t, sequence of Ref's (longs) you want info about.
     *
     * @return  A sequence of Debug_Gbe_InputTS_t entries.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid references( PhysRef, RefList) are used.
     *
     * @note 
     * - A value of 0xFFFF for port means all ports.
     * - An empty RefList means all refs.
     * @version Release 8.5     
     */    
    Debug_Gbe_InputTS_List_t DebugGbeStreamInGetL(in IPS_Ref_t PhysRef, in Ref_List_t RefList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
       
/**
     * Input Transport stream reason for existence bitmap. 
     * The bits in the bitmap indicate the specific reasons :
     * - bit 0: IsPassedToOutput
     * - bit 1: IsBackupSource
     * - bit 2: TwoMinuteTimerRunning
     * - bit 3: HasSpecificServiceLossSettings
     * - bit 4: HasSpecificTsLossSettings
     * - bit 5: HasSpecificFEC_Settings
     * - bit 6: HasCompactCA_Settings
     * - bit 7: HasTsBackupSettings
     * - bit 8: HasSpecificStandardSetting
     * - bit 9: HasSpecificTimeBaseSelection
     * - bit 10: SignalPresent
     * - bit 11: HasPriorityBitSettings
     * - bit 12: HasInterpreterSettings
     * - bit 13: HasThresholdMonSettings
     * - bit 14: HasHitlessMergeSettings
     */
  struct InTsExistenceReasons_t
  {
    IPS_RefTS_t   RefTs;
    unsigned long ExistenceBitmap;
  };

  /// A sequence of InTsExistenceReasons_t.
  typedef sequence<InTsExistenceReasons_t> InTsExistenceReasonsList_t;
 
 /** Get reason of existence for some input TS.
     * 
     * @param[in] RefPhys    The port the Input TS are attached to. 
     * @param[in] RefTsList  List of References of InputTs for which to return the existence reason. 
     * Empty list equals all InputTs attached to RefPhys.
     * @param[out] lst List of RefTs/ExistenceBitmap pairs
     * 
     * @exception OpNotSupported When called for main board.
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist.
     * - RefTs does not match RefPhys
     *
     * @version Release 6.5
     */
  void InputTsExistenceGetL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList, out InTsExistenceReasonsList_t lst)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
 /** Get a list of Gbe information of outgoing transport streams.
      *  Call mainly meant for troubleshooting information.
      * For each input transport stream, the "hardware index" is also returned.
     *
     * @param[in] PhysRef The BoardNr and PortNr of which you want the information.
     * @param[in] RefList A Ref_List_t, sequence of Ref's (longs) you want info about.
     *
     * @return  A sequence of ebug_Gbe_OutputTS_t entries.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid references( PhysRef, RefList) are used.
     *
     * @note 
     * - A value of 0xFFFF for port means all ports.
     * - An empty RefList means all refs.
     * @version Release 8.5     
     */    
    Debug_Gbe_OutputTS_List_t DebugGbeStreamOutGetL(in IPS_Ref_t PhysRef, in Ref_List_t RefList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);        
        
    /** Create a number of TS on given Slot and Port based on the defined defaults (IPS_OutDefaultsSet(), IPS_OutDefaultsGet()).
     *
     * @param[in] RefPhys The BoardNr and PortNr on which TSs need to be added.
     * @param[in] NbrOutTS The number of TS's to create.
     * @param[out] OutputTSList Parameters of the new TS's.
     *
     * @exception OpNotSupported When called for other boards than GbE ones (Main, asi, ..).
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys).
     * - Maximum number of supported TSs/board is reached.
     * - Maximum number of supported TSs/GBE port is reached.
     *
     */
    void IPS_OutTS_AddL(in IPS_Ref_t RefPhys, in unsigned long NbrOutTS, out IPS_OutputTS_List_t OutputTSList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Create a number of TS on given Slot and Port based on the defined defaults (IPS_OutDefaultsSet(), IPS_OutDefaultsGet()).
     *
     * @param[in] RefPhys The BoardNr and PortNr on which TSs need to be added.
     * @param[in] NbrOutTS The number of TS's to create.
     * @param[out] OutputTSList Parameters of the new TS's.
     *
     * @exception OpNotSupported When called for other boards than GbE ones (Main, asi, ..).
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys).
     * - Maximum number of supported TSs/board is reached.
     * - Maximum number of supported TSs/GBE port is reached.
     *
     * @version  Release 8.5
     */
    void IPS_OutTS_AddL_V2(in IPS_Ref_t RefPhys, in unsigned long NbrOutTS, out IPS_OutputTS_List_V2_t OutputTSList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Change the parameters of one or more existing outgoing TS.
     *
     * @param[in] RefPhys The BoardNr and PortNr of which parameters need to be changed.
     * @param[in] OutputTSList List of IPS_OutputTS_t entries.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys).
     * - Inconsistency between RefPhys.BoardNr & OutputTSList[x].Ref.BoardNr.
     * - Inconsistency between RefPhys.PortNr & OutputTSList[x].Ref.PortNr in case RefPhys.PortNr != 0xFFFF.
     * - Out of range values (Bitrate, UDPPort, TSID, ONID).
     * - Invalid enum value (State, eEsTypeStandard).
     * @todo : exception LicenseError when ONID/TSID change is forbidden due to duplicate TS's with scrambling licenses.
     *         (is an OpNotSucceeded exception for the moment)
     *
     * @note The maximum bitrate allowed on an ASI I/O board depends on the output mode of the ASI port.
     */
    void IPS_OutTS_ChangeL(in IPS_Ref_t RefPhys, in IPS_OutputTS_List_t OutputTSList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);
     
    /** Change the parameters of one or more existing outgoing TS.
     *
     * @param[in] RefPhys The BoardNr and PortNr of which parameters need to be changed.
     * @param[in] OutputTSList List of IPS_OutputTS_V2_t entries.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys).
     * - Inconsistency between RefPhys.BoardNr & OutputTSList[x].Ref.BoardNr.
     * - Inconsistency between RefPhys.PortNr & OutputTSList[x].Ref.PortNr in case RefPhys.PortNr != 0xFFFF.
     * - Out of range values (Bitrate, UDPPort, TSID, ONID).
     * - Invalid enum value (State, eEsTypeStandard).
     * @todo : exception LicenseError when ONID/TSID change is forbidden due to duplicate TS's with scrambling licenses.
     *         (is an OpNotSucceeded exception for the moment)
     *
     * @note The maximum bitrate allowed on an ASI I/O board depends on the output mode of the ASI port.
     * @version  Release 8.5
     */
    void IPS_OutTS_ChangeL_V2(in IPS_Ref_t RefPhys, in IPS_OutputTS_List_V2_t OutputTSList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);

    /** Change the parameters of one or more existing incoming TS.
     * 
     * @param[in] RefPhys The BoardNr and PortNr of which parameters need to be changed.
     * @param[in] InputTSList List of IPS_ChangeInputTS_List_t entries.
     * 
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys).
     * - Inconsistency between RefPhys.BoardNr & InputTSList[x].Ref.BoardNr.
     * - Inconsistency between RefPhys.PortNr & InputTSList[x].Ref.PortNr in case RefPhys.PortNr != 0xFFFF.
     * - Invalid enum value (eEsTypeStandard).
     * 
     */
    void IPS_InTS_ChangeL(in IPS_Ref_t RefPhys, in IPS_ChangeInputTS_List_t InputTSList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get a list of outgoing transport streams and their parameters.
     * 
     * @param[in] RefPhys The BoardNr and PortNr you want information about.
     * @param[in] RefList A sequence of Ref's you want info about.
     * 
     * @return IPS_OutputTS_List_t, a sequence of IPS_OutputTS_t entries.
     * 
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid references (RefPhys, RefList) are used.
     * @note 
     * - A value of 0xFFFF for port means all ports.
     * - An empty list means all refs.
     * - The IPS_OutTS_Get version of this method is no longer supported.
     */
    IPS_OutputTS_List_t IPS_OutTS_GetL(in IPS_Ref_t RefPhys, in Ref_List_t RefList )
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get a list of outgoing transport streams and their parameters.
     *
     * @param[in] RefPhys The BoardNr and PortNr you want information about.
     * @param[in] RefList A sequence of Ref's you want info about.
     *
     * @return IPS_OutputTS_List_V2_t, a sequence of IPS_OutputTS_V2_t entries.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid references (RefPhys, RefList) are used.
     * @note
     * - A value of 0xFFFF for port means all ports.
     * - An empty list means all refs.
     * - The IPS_OutTS_Get version of this method is no longer supported.
     *
     * @version  Release 8.5   
     */
    IPS_OutputTS_List_V2_t IPS_OutTS_GetL_V2(in IPS_Ref_t RefPhys, in Ref_List_t RefList )
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    struct GbeIO_IP_Settings_t
    {
      IPS_RefTS_t       Ref; ///< Reference to the output stream
      IPS_UDP_Socket_t  DestSocket;   ///< Unique destination IPv4 or IPv6-Address and UDP port combination.
      IPS_UDP_Socket_t  SrcSocket;    ///< for future use
      unsigned short    TrafficClass_TOS; ///< for future use - default value 0
      unsigned short    HopLimit_TTL; ///< for future use - default value 64
      unsigned long     IPv6_FlowLabel; ///< for future use - default value 0
    };

    /// A sequence of GbeIO_IPv6_t entries.
    typedef sequence<GbeIO_IP_Settings_t> GbeIO_IP_Settings_List_t; 

    /** Change the IPv4 or IPv6 header parameters of one or more existing outgoing Gbe IO streams.
     *
     * @param[in] RefPhys The BoardNr and PortNr of which parameters need to be changed.
     * @param[in] OutputGbeIO_StreamList List of GbeIO_IP_Header_t entries.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys).
     * - Inconsistency between RefPhys.BoardNr & OutputTSList[x].Ref.BoardNr.
     * - Inconsistency between RefPhys.PortNr & OutputTSList[x].Ref.PortNr in case RefPhys.PortNr != 0xFFFF.
     * - Out of range values ( UDPPort).
     *
     * @version  Release 8.2     
     */
  void GbeIO_OutStreamIP_ChangeL(in IPS_Ref_t RefPhys, in GbeIO_IP_Settings_List_t OutputGbeIO_StreamList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);
        
 /** Get the IPv4 or IPv6 parameters for a list of outgoing transport streams
     * 
     * @param[in] RefPhys The BoardNr and PortNr you want information about.
     * @param[in] RefList A sequence of Ref's you want info about.
     * 
     * @return OutputGbeIO_StreamList List of GbeIO_IP_Header_t entries.
     * 
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid references (RefPhys, RefList) are used.
     * @note 
     * - A value of 0xFFFF for port means all ports.
     * - An empty list means all refs.
     * @version  Release 8.2
     */
  GbeIO_IP_Settings_List_t GbeIO_OutStreamIP_GetL(in IPS_Ref_t RefPhys, in Ref_List_t RefList )
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

        
    
    /** Get a filtered list of outgoing transport streams and their parameters.
     * 
     * @param[in] RefPhys The BoardNr and PortNr you want information about.
     * @param[in] RefList A sequence of Ref's you want info about.
     * @param[in] ScrambledOnly Return only TS's where scrambling of services can be done
     * 
     * @return An IPS_OutputTS_List_t list, a sequence of IPS_OutputTS_t entries.
     * 
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid references (RefPhys, RefList) are used.
     * 
     * @note 
     * - A value of 0xFFFF for port means all ports.
     * - An empty list means all refs.
     */
    IPS_OutputTS_List_t IPS_OutTS_GetFilteredL(in IPS_Ref_t RefPhys, in Ref_List_t RefList, in boolean ScrambledOnly )
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get a filtered list of outgoing transport streams and their parameters.
     *
     * @param[in] RefPhys The BoardNr and PortNr you want information about.
     * @param[in] RefList A sequence of Ref's you want info about.
     * @param[in] ScrambledOnly Return only TS's where scrambling of services can be done
     *
     * @return An IPS_OutputTS_List_V2_t list, a sequence of IPS_OutputTS_V2_t entries.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid references (RefPhys, RefList) are used.
     *
     * @note
     * - A value of 0xFFFF for port means all ports.
     * - An empty list means all refs.
     *
     * @version  Release 8.5
     */
    IPS_OutputTS_List_V2_t IPS_OutTS_GetFilteredL_V2(in IPS_Ref_t RefPhys, in Ref_List_t RefList, in boolean ScrambledOnly )
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Delete a list of TSs.
     * 
     * @param[in] RefPhys BoardNr & PortNr where TSs need to be deleted.
     * @param[in] RefList list of IPS_RefTS_t, references to the TSs that need to be deleted.
     * 
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case
     * - Invalid references are used (RefPhys, RefList).
     * - Inconsistency between RefPhys.BoardNr & RefList[x].BoardNr.
     * - Inconsistency between RefPhys.PortNr & RefList[x].PortNr in case RefPhys.PortNr != 0xFFFF.
     * 
     * @note
     * - Services are also deleted when output TS gets deleted.
     * - The IPS_OutTS_Delete version of this method is no longer supported.
     * - When called on an ASI board, a new TS is created for the ports where the TS is deleted
     */
    void IPS_OutTS_DeleteL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set defaults for new TS created with IPS_OutTS_AddL().
     * 
     * @param[in] RefPhys Specifies the BoardNr & PortNr on which to apply these defaults.
     * @param[in] Socket Default ip address & UDP port.
     * @param[in] lBitrate Default bitrate values: range 0.1 Mbps..200Mbps
     * @param[in] Incr Default incremental scheme.
     * 
     * @exception OpNotSupported When called for other boards than GbE ones (Main, ASI,...).
     * @exception OpNotSucceeded In case of
     * - Out of range values (Ip address, UDP port, Bitrate).
     * - Invalid enum values.
     * 
     * @note If a new TS is created, the software will check if the default (IP address, UDP port)
     *       already exist.  If not, a new TS is created with default IP address and UDP port.
     *       If the IP address, UDP port already exist, the incemental scheme is used to find an
     *       IP address, UDP port combination that is free.
     * @note Output defaults are stored per board: PortNumber in RefPhys is ignored.
     * @note IP address and UDP port combination is not unique over different I/O boards.
     */
    void IPS_OutDefaultsSet(in IPS_Ref_t RefPhys, in IPS_UDP_Socket_t Socket, in long lBitrate, in eIPS_IncrScheme Incr)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get current set of defaults for a new TS.
     * 
     * @param[in] RefPhys BoardNr & PortNr of which we want the information.
     * 
     * @param[out] Socket Default ip address & UDP port.
     * @param[out] lBitrate Default bitrate value.
     * @param[out] Incr Default incremental scheme.
     * 
     * @note Output defaults are stored per board: the PortNumber in RefPhys is ignored.
     * 
     * @exception OpNotSupported When called for other boards than GbE ones (Main, ASI,...).
     */
    void IPS_OutDefaultsGet(in IPS_Ref_t RefPhys, out IPS_UDP_Socket_t Socket, out long lBitrate, out eIPS_IncrScheme Incr) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the default source UDP port number for a new TS.
     * 
     * @param[in] Board An unsigned short to indicate the slot.
     * @param[in] SourceUdp The default source UDP port number.
     * 
     * @exception OpNotSupported When called for other boards than GbE ones (Main, asi, ..).
     * @exception OpNotSucceeded in case of
     * - Invalid reference Board
     */
    void SetDefault_SourceUdp(in unsigned short Board, in unsigned short SourceUdp)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the current default source UDP port number for a new TS.
     * 
     * @param[in] Board An unsigned short to indicate the slot.
     * 
     * @param[out] SourceUdp The default source UDP port number.
     * 
     * @exception OpNotSupported When called for other boards than GbE ones (Main, asi, ..).
     * @exception OpNotSucceeded in case of
     * - Invalid reference Board 
     */
    void GetDefault_SourceUdp(in unsigned short Board, out unsigned short SourceUdp)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set defaults eEsTypeStandard for input and output for new TS.
     * 
     * @param[in] RefPhys Specifies the BoardNr & PortNr on which to apply these defaults.
     * @param[in] eIn, eOut eEsTypeStandard values for input and output.
     * 
     * @exception OpNotSupported When called for other than IO boards (Main).
     * @exception OpNotSucceeded In case of
     * - Invalid enum values.
     * - For input the new value must be one of eDVB, eATSC, eMOTOROLA.
     * - For output the new value must be one of eTransparent, eForceUplink, eForceVideo 
     *   or eForceAudio3,.
     * 
     * @note Defaults are stored per board: PortNumber in RefPhys is ignored.
      */
    void IPS_SetDefaultStandard(in IPS_Ref_t RefPhys, in eEsTypeStandard eIn, in eEsTypeStandard eOut)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get current default eEsTypeStandard for input and output.
     * 
     * @param[in] RefPhys BoardNr & PortNr of which we want the information.
     * @param[out] eIn eEsTypeStandard value for input.
     * @param[out] eOut eEsTypeStandard value for output.
     * 
     * @note Defaults are stored per board: the PortNumber in RefPhys is ignored.
     * 
     * @exception OpNotSupported When called for other than IO boards (Main).
     */
    void IPS_GetDefaultStandard(in IPS_Ref_t RefPhys, out eEsTypeStandard eIn, out eEsTypeStandard eOut) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** this gets the current defaults for all supported SI tables
     * 
     * @param[in] RefPhys The slot(board) and port to apply the call on.
     *     Port must be 0xFFFF (boardsetting)
     * @param[out] Periods
     * 
     * @return Periods List of all SI tables for all standards + periods
     * 
     * @exception OpNotSupported When called for other than IO boards (Main).
     * @exception OpNotSucceeded when RefPhys is invalid
     */
    void GetSI_DefaultPlayoutPeriods(in IPS_Ref_t RefPhys, out SI_Table_Period_List_t Periods)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
     
     /** this sets the defaults for any subset of the supported SI tables (or for all)
     * 
     * @param[in] RefPhys The slot(board) and port to apply the call on.
     *     Port must be 0xFFFF (boardsetting)
     * @param[in] Periods list of SI_Playout_List_t
     * 
     * @exception OpNotSupported When called for other than IO boards (Main).
     * @exception OpNotSucceeded Periods[i].Ref invalid or RefPhys invalid
     * @exception OutOfRange Periods[i].Period above maxiumum or below minimum
     */
    void SetSI_DefaultPlayoutPeriods(in IPS_Ref_t RefPhys, in SI_Table_Period_List_t Periods)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OutOfRange);
     
     /** this gets the playout periods for all supported SI tables for one or more TS
     * 
     * @param[in] RefPhys The slot(board) and port to apply the call on.
     *     Port can be 0xFFFF (all ports) but can also be a specific port.
     * @param[in] TS_List List of all TS-es we want info upon. Empty->every TS matching RefPhys.
     * @param[out] Periods
     * 
     * @return Periods List of all SI tables for all standards + periods for the requested TS
     * 
     * @exception OpNotSupported When called for other than IO boards (Main).
     * @exception OpNotSucceeded RefTS: TS_List[i].PhysRef does not match RefPhys (BoardNr and/or portnr)
     *                           or RefPhys is invalid
     * @exception OpNotSucceeded TS in TS_list non existent or invalid
     */
    void OutTS_GetSI_PlayoutPeriods(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t TS_List, out TS_SI_Table_Periods_List_t Periods)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    
    /** this gets the playout periods for all supported SI tables for one or more TS
     * 
     * @param[in] RefPhys The slot(board) and port to apply the call on.
     *     Port must be 0xFFFF (boardsetting)
     * @param[in] Periods List of all periods to set
     * 
     * @exception OpNotSupported When called for other than IO boards (Main).
     * @exception OpNotSucceeded RefTS: Periods[i].TS.PhysRef does not match RefPhys (BoardNr and/or portnr)
     *                           or RefPhys is invalid
     * @exception OpNotSucceeded Periods[i].TS non existent or invalid
     * @exception OutOfRange Periods[i].Period above maxiumum or below minimum
     */
    void OutTS_SetSI_PlayoutPeriods(in IPS_Ref_t RefPhys, in TS_SI_Table_Periods_List_t Periods)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OutOfRange);


    /**
     * This gets the default generation mode of all supported SI tables for one or more TS.
     *
     * @param[in]     RefPhys   The slot (board) and port to apply the call on.
     *                          (Port mux be 0xFFFF, because boardsetting)
     * @param[out]    Modes     list with generation modes for tables (only supported for TDT and TOT)
     *
     * @exception     OpNotSupported  RefPhys invalid
     **/
    void GetSI_DefaultGenerationModes(in IPS_Ref_t RefPhys, out SI_Table_GenerationMode_List_t Modes)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OutOfRange);


    /**
     * This sets the default generation mode of all supported SI tables for one or more TS.
     *
     * @param[in]     RefPhys   The slot (board) and port to apply the call on.
     *                          (Port mux be 0xFFFF, because boardsetting)
     * @param[in]     Modes     list with generation modes for tables (only supported for TDT and TOT)
     *
     * @exception     OpNotSupported  RefPhys invalid
     **/
    void SetSI_DefaultGenerationModes(in IPS_Ref_t RefPhys, in SI_Table_GenerationMode_List_t Modes)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OutOfRange);

    
    /** This sets the TOT descriptor timezones for one or more TS's.
     *
     * @param[in]     RefPhys         reference to board, port
     * @param[in]     Timezones       list of TS's with corresponding timezones
     * 
     * @exception     OpNotSucceeded  in case of invalid references (RefTS)
     **/
    void SetTOT_Timezones(in IPS_Ref_t RefPhys, in TS_TOT_Timezone_List_t Timezones)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OutOfRange);


    /** This gets the TOT descriptor timezones for one or more TS's.
     *
     * @param[in]     RefPhys         reference to board, port
     * @param[in]     TS_List         list of TS's
     * @param[out]     Timezones       A TS_TOT_Timezone_List_t list of TS's with corresponding timezones.
     * 
     * @return Timezones       list of TS's with corresponding timezones
     * 
     * @exception     OpNotSucceeded in case of invalid references (RefTS)
     **/
    void GetTOT_Timezones(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t TS_List, out TS_TOT_Timezone_List_t Timezones)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OutOfRange);
   
        
    /** Gets the list of PID's on a OutputTS.
     *
     * @param[in] RefTS BoardNr & PortNr for which to get the PIDs. If RefTS.Ref==0xFFFFFFFF, then all output TS's are processed.
     * @param[in] PID_Type An ePID_Type to specify the type of the PID to get.
     * @param[out] PID_DataList
     *
     * @return PID_DataList A sequence of IPS_OutPID_Data2_t entries.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of
     * - Invalid references are used (RefTS)
     * @todo OpNotSucceeded should be returned on invalid enum ePID_Type. Now 0 pids will be returned
     *       when the supplied PID_Type is invalid.
     * @todo An Unknown exception is returned when this call is executed on an input TS. This should be 
     *       an OpNotSucceeded exception
     */ 
    void IPS_OutPID_GetL(in IPS_RefTS_t RefTS, in ePID_Type PID_Type, out IPS_OutPID_Data2List_t PID_DataList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Gets the list of PID's on a InputTS.
     *
     * @param[in] RefTS BoardNr & PortNr for which to get the PIDs.
     *                  - If RefTS.Ref==0xFFFFFFFF  (i.e. wildcard), then all output TS's on the specified port are processed.
     *                  - If Ref.PortNr == INVALID_PORT (i.e. wildcard) all ports are processed.
     * @param[in] PID_Type An ePID_Type to specify the type of the PID to get.
     * @param[out] PID_DataList
     *
     * @return PID_DataList A sequence of IPS_InPID_Data_t entries.
     *
     * @exception OpNotSucceeded In case of
     * - Invalid references are used (RefTS which cannot be found)
     * @todo OpNotSucceeded should be returned on invalid enum ePID_Type. Now 0 pids will be returned
     *       when the supplied PID_Type is invalid.
     * @todo When this call is executed on an output TS an OpNotSucceeded exception should be returned.
     *       Now no exception is returned.
     */ 
    void IPS_InPID_GetL(in IPS_RefTS_t RefTS, in ePID_Type PID_Type, out IPS_In_PID_List_t PID_DataList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Gets the list of PID's on a InputTS (including property bits).
     *
     * @param[in] RefTS BoardNr & PortNr for which to get the PIDs.
     *                  - If RefTS.Ref==0xFFFFFFFF  (i.e. wildcard), then all output TS's on the specified port are processed.
     *                  - If Ref.PortNr == INVALID_PORT (i.e. wildcard) all ports are processed.
     * @param[in] PID_Type An ePID_Type to specify the type of the PID to get.
     * @param[out] PID_DataList List of PIDs with property bits.
     *
     * @return PID_DataList A sequence of IPS_InPID_Data_V2_t entries.
     *
     * @exception OpNotSucceeded In case of
     * - Invalid references are used (RefTS which cannot be found)
     * @todo OpNotSucceeded should be returned on invalid enum ePID_Type. Now 0 pids will be returned
     *       when the supplied PID_Type is invalid.
     * @todo When this call is executed on an output TS an OpNotSucceeded exception should be returned.
     *       Now no exception is returned.
     * 
     * @version  Release 7.5
     */
    void IPS_InPID_GetL_V2(in IPS_RefTS_t RefTS, in ePID_Type PID_Type, out IPS_In_PID_List_V2_t PID_DataList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);        

    /** Routes a number of EMM pids to an output TS.
     *
     * @param[in] RefTS_Out BoardNr & PortNr & TSRef to which EMMs should be routed.
     * @param[in] PID_DataList A sequence of InEMM_Data_t entries.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of
     * - Invalid reference is used (RefTS_Out)
     * @todo Extra check for a valid pidvalue should be added. Return OpNotSucceeded when
     *       pidvalue is illegal. Now this is accepted ...
     */ 
    void IPS_OutEMM_AddL(in IPS_RefTS_t RefTS_Out, in InEMM_RefList_t PID_DataList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Removes the routing for a number of EMM pids to an output TS.
     *
     * @param[in] RefTS_Out BoardNr & PortNr & TSRef for which EMMs should no longer be routed.
     * @param[in] PID_DataList A sequence of InEMM_Data_t entries.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of
     * - Invalid reference is used (RefTS_Out)
     * @todo Extra check if EMM to be deleted can be found. Return OpNotSucceeded when
     *       specified EMM cannot be found. Now always succes is returned.
     */ 
    void IPS_OutEMM_DelL(in IPS_RefTS_t RefTS_Out, in InEMM_RefList_t PID_DataList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Gets the list of additional information of all EMM's/PD's at the output.
     *  Call only meant for the main board.
     *
     * @param[in] EMM_RefList A sequence of InEMM_Data_t entries.
     * @param[out] EMM_DataList
     *
     * @return EMM_DataList A sequence of EMM_Data_t entries.
     *
     * @todo exception OpNotSucceeded In case of
     * - Invalid references are passed RefTS_t or illegal pidvalues
     */ 
    void InEMM_GetL(in InEMM_RefList_t EMM_RefList, out EMM_DataList_t EMM_DataList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

  struct ForbiddenPidRange_t
  {
    unsigned short LowerPidValue;  ///< Lower limit of the forbidden pid range 
    unsigned short UpperPidValue;  ///< Upper limit of the forbidden pid range (should be > LowerPidValue)
  };
  
  /// A sequence of ForbiddenPidRange_t entries
  typedef sequence<ForbiddenPidRange_t> ForbiddenPidRange_List_t;

  /** Sets a number of default Forbidden Output PID ranges (PIDs that may not be used at the Output). 
     * The   maximum number of total ranges is set to 5, each range should be distinct from another.
     * The maximum width of the range is defined as 1000. 
     * Each time a new output transport stream is created, it will take over the default forbidden pid ranges.
     * Any old ranges already present will be replaced with the newly provided list.
     *
     * @param[in] SlotNumber  Slot number      
     * @param[in] RangeList    The list of forbidden pid ranges to be added or removed
     *
     * @exception OpNotSupported When SlotNumber = 0 = Main board.
     * @exception OpNotSucceeded In case of too many ranges added, ranges overlap, range too wide
     * - 
     * @version Release 8.0     
     */  
  void SetDefaultForbiddenPidRanges(in unsigned short SlotNumber,  in ForbiddenPidRange_List_t RangeList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    
 /** Gets the default forbidden pid ranges.
     *
     * @param[in]   SlotNumber  Slot number      
     * @param[out]  RangeList    The list of forbidden pid ranges
     *
     * @exception OpNotSupported When SlotNumber = 0 = Main board.
     * @exception OpNotSucceeded In case of 
     * - 
     * @version Release 8.0     
     */  
  void GetDefaultForbiddenPidRanges(in unsigned short SlotNumber, out ForbiddenPidRange_List_t RangeList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
  
  /** Sets a number of Forbidden Output PID ranges (PIDs that may not be used at the Output).
     * to a specific output transport stream.
     * The   maximum number of total ranges is set to 5, each range should be distinct from another.
     * The maximum width of the range is defined as 1000. 
     * Any old ranges already present will be replaced with the newly provided list.
     *
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the output transport stream.
     * @param[in] RangeList    The list of forbidden pid ranges to be added or removed
     *
     * @exception OpNotSupported When SlotNumber = 0 = Main board.
     * @exception OpNotSucceeded In case of too many ranges added, ranges overlap, range too wide, output TS cannot be found
     * - 
     * @version Release 8.0     
     */  
  void SetForbiddenPidRanges(in IPS_RefTS_t RefTS,  in ForbiddenPidRange_List_t RangeList)    
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
 /** Gets the forbidden pid ranges for a specific output transport stream
     *
     * @param[in]   RefTS          The referenceto the output transport stream      
     * @param[out]  RangeList    The list of forbidden pid ranges
     *
     * @exception OpNotSupported When SlotNumber = 0 = Main board.
     * @exception OpNotSucceeded In case of output TS cannot be found
     * - 
     * @version Release 8.0     
     */  
  void GetForbiddenPidRanges(in IPS_RefTS_t RefTS, out ForbiddenPidRange_List_t RangeList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
   
    /** Passes a list of (unreferenced) PID's to an OutputTS.
     *
     * @param[in] RefPhys BoardNr & PortNr on which to apply these PIDs.
     * @param[in] PID_DataList A sequence of IPS_OutPID_Data_t entris with the PIDs to add.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys, PID_DataList).
     * - Inconsistency between RefPhys.BoardNr & PID_DataList[x].Ref.BoardNr.
     * - Inconsistency between RefPhys.PortNr & PID_DataList[x].Ref.PortNr in case RefPhys.PortNr != 0xFFFF.
     */ 
    void IPS_OutPID_AddL(in IPS_Ref_t RefPhys, in IPS_OutPID_DataList_t PID_DataList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Deletes the list of PID's on a OutputTS.
     *
     * @param[in] RefPhys BoardNr & PortNr on which to delete these PIDs.
     * @param[in] PID_DataList A sequence of IPS_OutPID_Data_t entries with the PIDs to delete.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys, PID_DataList).
     * - Inconsistency between RefPhys.BoardNr & PID_DataList[x].Ref.BoardNr.
     * - Inconsistency between RefPhys.PortNr & PID_DataList[x].Ref.PortNr in case RefPhys.PortNr != 0xFFFF.
     */ 
    void IPS_OutPID_DeleteL(in IPS_Ref_t RefPhys, in IPS_OutPID_DataList_t PID_DataList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Process the upload of a routing file.
     * This function is used for pre-configuration of the %DCM.
     * The data that is being sent is a CSV file. An example of such a file can be
     * retrieved from the %DCM. The current configuration can also be retrieved
     * from the %DCM using the function @ref IPS_RetrieveRoutingFile. Refer to these
     * files for the format of the CSV file.
     * This function will parse the configuration file and then return.
     * The new routings will be applied after this function has already returned.
     * Applying the setting can take a long time (up to 30 min for large files).
     * While the settings are being applied, new calls to @ref IPS_ProcessRoutingFile will
     * return with an exception code OpNotSucceeded.
     * To determine the progress of applying the routings, the function
     * @ref IPS_RoutingFileProgress can be used. Once the function @ref IPS_RoutingFileProgress
     * returns with Finished set to true, the function @ref IPS_RoutingFileStatus can be
     * used to obtain the result of the operation.
     * If the uploaded file is invalid (a fatal error occurs during parsing),
     * the function @ref IPS_RoutingFileProgress will immediately return with Finished set
     * to true.
     *
     * @param[in] FileData RoutingFileData A sequence of char corresponding to the data in the routing file.
     *
     * @exception OpNotSucceeded Processing of a previous @ref IPS_ProcessRoutingFile call has not finished yet.
     *
     * @see IPS_RoutingFileProgress
     * @see IPS_RoutingFileStatus
     * @see IPS_RetrieveRoutingFile
     */ 
    void IPS_ProcessRoutingFile(in RoutingFileData_t FileData)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Inidicates the progress of the upload of a routing file.
     * Call this function repeatedly after calling @ref IPS_ProcessRoutingFile until
     * Finished is set to true. The parameter CurrentValue allows to display
     * progress information in a user interface, and will increase from
     * 0 up to TotalValue.
     * The parameter TotalValue currently contains the number of routings to
     * be processed, but this behavior should not be relied on.
     *
     * @param[out] Finished Has processing finished yet?
     * @param[out] CurrentValue Value that goes up from 0 to TotalValue
     * @param[out] TotalValue Scaling factor for the progress information
     *
     * @see IPS_ProcessRoutingFile
     */ 
    void IPS_RoutingFileProgress(out boolean Finished, out long CurrentValue, out long TotalValue)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Inidicates the status of the upload of a routing file.
     * This function will always return the information about the last call to @ref IPS_ProcessRoutingFile
     * that was made (or success and empty list of no such call was made).
     * When calling this function before @ref IPS_RoutingFileProgress returns with Finished
     * set to true, a partial list of errors will be returned (all errors which have been
     * encountered so far).
     *
     * @param[out] Result An enumeration indicating if the upload was succesful or not.
     * @param[out] StatusRecords A sequence of RoutingStatusRecords indicating the line number of the error, severity and a
     *             message indicating the reason of the failure.
     * @see IPS_RoutingFileProgress
     * @see IPS_ProcessRoutingFile
     */ 
    void IPS_RoutingFileStatus(out eRoutingStatusResult Result, out RoutingStatusRecord_List_t StatusRecords)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Retrieve the current routing in CSV format.
     * The file retrieved is in the same format as is to be used for the call @ref IPS_ProcessRoutingFile.
     *
     * @param[in] Separator The character used to separate fields (usually , or ;).
     * @param[in] DecimalPoint The character used to represent a decimal point (usually . or ,).
     * @param[in] EOLMarker The character sequence used to separate lines, usually CR, LF or CR+LF.
     * @param[out] FileData The data in CSV format.
     *
     * @exception OpNotSucceeded An IIOP call to an I/O board has failed.
     *
     * @see IPS_ProcessRoutingFile
     */     
    void IPS_RetrieveRoutingFile(in char Separator, 
                                 in char DecimalPoint, 
                                 in charSequence EOLMarker, 
                                 out RoutingFileData_t FileData)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get the Auto Pass Rules for an Output TS (MPTS Pass Through).
     *
     * @param[in] RefOutTS The output TS.
     * @param[out] AutoPassRulesList A list of the rules that are currently used.
     * @param[out] AutoPassRulesDisableFlags The flags that are set by the system.
     *
     * @exception OpNotSucceeded TS if
     * - Invalid output references are used.    
     * - TS does not exist or is not for output.
     */
    void OutTS_GetTSAutoPassRules(in IPS_RefTS_t RefOutTS, out TS_AutoPassRules_List_t AutoPassRulesList,
                                  out TS_AutoPassRulesDisableFlags AutoPassRulesDisableFlags)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Set the Auto Pass Rules for an Output TS (MPTS Pass Through).
     * Specify from which Input TS all Services, EMMs and/or 
     * Unreferenced PIDs should be passed to this Output TS.
     *
     * @param[in] RefOutTS The output ts.
     * @param[in] AutoPassRulesList A list of the rules that should be used.
     *
     * @exception OpNotSucceeded 
     * - Invalid output references are used.    
     * - TS does not exist or is not for output.
     * - The TS_AutoPassRules.InputRef member does not exist or is not for input.
     * - User tries to enable one of the options while the corresponding Disabled flag is set.
     */
    void OutTS_SetTSAutoPassRules(in IPS_RefTS_t RefOutTS, in TS_AutoPassRules_List_t AutoPassRulesList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Set the board default auto pass rules for service component passing.
     * These settings are copied to any newly created output TS.
     * @param[in] BoardNr The slot the settings refer to.
     * @param[in] rules The new DefaultAutoPassRules.
     */
    void SetDefaultAutoPassRules(in unsigned short BoardNr, in DefaultAutoPassRules rules)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Get the board default auto pass rules for service component passing.
     * These are the current settings.
     * @param[in] BoardNr The slot the settings refer to.
     * @param[in] rules The current DefaultAutoPassRules.
     */
    void GetDefaultAutoPassRules(in unsigned short BoardNr, out DefaultAutoPassRules rules)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);    
        
    /** Get current service component auto pass rules.
     *  The service components (ES, ECM, ES_ECM) follow the input (pass/delete) or are blocked.
     *
     * @param[in]  RefOutTS The output TS defined by @ref IPS_RefTS_t.
     * @param[out] AutoPassRules defined by @ref Service_AutoPassRules.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case 
     * - Invalid output references are used     
     * - TS does not exist or is not for output.
     */
    void OutTS_GetServiceAutoPassRules(in IPS_RefTS_t RefOutTS, out Service_AutoPassRules AutoPassRules)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Set service component auto pass rules.
     *  The service components (ES, ECM, ES_ECM) follow the input (pass/delete) or are blocked.
     *
     * @param[in] RefOutTS The output TS defined by @ref IPS_RefTS_t.
     * @param[in] AutoPassRules defined by @ref Service_AutoPassRules.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case 
     * - Invalid output references are used     
     * - TS does not exist or is not for output.
     * - User tries to enable one of the options while the corresponding AutoPassRules.Disabled flag is set.
     */        
    void OutTS_SetServiceAutoPassRules(in IPS_RefTS_t RefOutTS, in Service_AutoPassRules AutoPassRules)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set SI subtable auto pass rules.
     *
     * @param[in] RefOutTS The output TS defined by @ref IPS_RefTS_t.
     * @param[in] SI_AutoPassRules_List Subtables to auto-pass and excpetions.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case 
     * - Invalid output references are used     
     * - TS does not exist or is not for output.
     *
     * @version Release 7.1
     */        
    void OutTS_SetSubtableAutoPass(in IPS_RefTS_t RefOutTS, in SI_AutoPassRules_List_t SI_AutoPassRules_List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get current SI subtable auto pass rules.
     *
     * @param[in]  RefOutTS The output TS defined by @ref IPS_RefTS_t.
     * @param[out] SI_AutoPassRules_List Subtables to auto-pass and excpetions.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case 
     * - Invalid output references are used     
     * - TS does not exist or is not for output.
     *
     * @version Release 7.1
     */
    void OutTS_GetSubtableAutoPass(in IPS_RefTS_t RefOutTS, out SI_AutoPassRules_List_t SI_AutoPassRules_List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /// NIT in PAT setting for specific TS
    struct OutTS_NitInPat_t
    {
      IPS_RefTS_t RefTsOut;
      eNitInPat NitInPat;
    };
    typedef sequence<OutTS_NitInPat_t> OutTS_NitInPat_List_t;

    /** Set TS NIT in PAT mode
     *
     * @param[in] RefPhys The port on which to configure TSs
     * @param[in] OutTS_NitInPat_List A list of TSs with their setting
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board or DCM version < 4.5
     * @exception OpNotSucceeded in case 
     * - Invalid output references are used     
     * - TS does not exist or is not for output.
     */        
    void OutTS_NitInPat_SetL(in IPS_Ref_t RefPhys, in OutTS_NitInPat_List_t OutTS_NitInPat_List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get TS NIT in PAT mode
     *
     * @param[in] RefPhys The port from which to retrieve settings
     * @param[in] RefTsList List of TSs for which to retrieve settings
     * @param[in] OutTS_NitInPat_List A list of TSs with their setting
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board or DCM version < 4.5
     * @exception OpNotSucceeded in case 
     * - Invalid output references are used     
     * - TS does not exist or is not for output.
     */        
    void OutTS_NitInPat_GetL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList, out OutTS_NitInPat_List_t OutTS_NitInPat_List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set default Nit in PAT mode settings to be used for newly created output TSs
     * Defaults are attached to a board.
     * The change takes effect when a new TS is created.
     * 
     * @param[in] BoardNumber The BoardNumber of which parameters need to be changed.
     * @param[in] NitInPat The new default setting.
     *
     * @exception OpNotSupported This call is not supported in the running software version.
     * @exception OpNotSucceeded In case of
     * - BoardNumber does not exist
     * - NitInPat out of range
     **/
    void SetDefault_NitInPat(in unsigned short BoardNumber, in eNitInPat NitInPat)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Get default Nit in Pat mode setting
     * Defaults are attached to a board.
     *
     * @param[in] BoardNumber The BoardNumber you want information about.
     * @param[out] NitInPat The current default.
     *
     * @exception OpNotSupported This call is not supported in the running software version.
     * @exception OpNotSucceeded In case of
     * - BoardNumber does not exist
     **/
    void GetDefault_NitInPat(in unsigned short BoardNumber, out eNitInPat NitInPat)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set TS Insert CAT Descriptors mode
     *
     * @param[in] RefPhys The port on which to configure TSs
     * @param[in] OutTS_InsertCATDescriptors_List A list of TSs with their setting
     *
     * @exception OpNotSupported in case
     * - BoardNr = 0 = Main board
     * - DCM version < 9.10
     * - called for board which doesn't have physical output (e.g. transcoder baord)
     * @exception OperationFailed in case 
     * - Invalid output references are used     
     * - TS does not exist or is not for output.
     * @exception OpNotSucceeded: Unspecified error.
     *
     * @version Release 9.10
     */        
    void OutTS_InsertCATDescriptors_SetL(in IPS_Ref_t RefPhys, in OutTS_InsertCATDescriptors_List_t OutTS_InsertCATDescriptors_List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Get TS Insert CAT Descriptors mode
     *
     * @param[in] RefPhys The port from which to retrieve settings
     * @param[in] RefTsList List of TSs for which to retrieve settings
     * @param[in] OutTS_InsertCATDescriptors_List A list of TSs with their setting
     *
     * @exception OpNotSupported in case
     * - BoardNr = 0 = Main board
     * - DCM version < 9.10
     * - called for board which doesn't have physical output (e.g. transcoder baord)
     * @exception OperationFailed in case 
     * - Invalid output references are used     
     * - TS does not exist or is not for output.
     * @exception OpNotSucceeded: Unspecified error.
     *
     * @version Release 9.10
     */        
    void OutTS_InsertCATDescriptors_GetL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList, out OutTS_InsertCATDescriptors_List_t OutTS_InsertCATDescriptors_List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Set default Insert CAT Descriptors mode settings to be used for newly created output TSs
     * Defaults are attached to a board.
     * The change takes effect when a new TS is created.
     * 
     * @param[in] BoardNumber The BoardNumber of which parameters need to be changed.
     * @param[in] InsertCATDescriptors The new default setting.
     *
     * @exception OpNotSupported in case
     * - BoardNr = 0 = Main board
     * - DCM version < 9.10
     * - called for board which doesn't have physical output (e.g. transcoder baord)
     * @exception OperationFailed In case
     * - BoardNumber does not exist
     * - InsertCATDescriptors out of range
     * @exception OpNotSucceeded Unspecified error
     *
     * @version Release 9.10
     **/
    void SetDefault_InsertCATDescriptors(in unsigned short BoardNumber, in eInsertCATDescriptors InsertCATDescriptors)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);


    /** Get default Insert CAT Descriptors mode setting
     * Defaults are attached to a board.
     *
     * @param[in] BoardNumber The BoardNumber you want information about.
     * @param[out] InsertCATDescriptors The current default.
     *
     * @exception OpNotSupported in case
     * - BoardNr = 0 = Main board
     * - DCM version < 9.10
     * - called for board which doesn't have physical output (e.g. transcoder baord)
     * @exception OperationFailed In case
     * - BoardNumber does not exist
     * @exception OpNotSucceeded Unspecified error
     *
     * @version Release 9.10
     **/
    void GetDefault_InsertCATDescriptors(in unsigned short BoardNumber, out eInsertCATDescriptors InsertCATDescriptors)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Set the Time Base Selection Mode for a list of input TSs.
     *
     * @param[in] RefPhys The port on which to configure TSs
     * @param[in] TBS_List A list of input TSs with their setting
     *
     * @exception OpNotSupported When BoardNr does not identify a Gbe board
     * @exception OpNotSucceeded in case
     * - Invalid input references are used
     * - Inconsistency between RefPhys.PortNr and TBS_List[x].RefTSIn.Ref.PortNr in case RefPhys.PortNr != 0xFFFF.
     * - TS does not exist or is not for input
     *
     * @deprecated Since version 10.30, use TimeBaseSelectionMode_V2_SetL instead
     */
    void TimeBaseSelectionMode_SetL(in IPS_Ref_t RefPhys, in InTS_TimeBaseSelectionMode_List_t TBS_List)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the Time Base Selection Mode for a list of input TSs.
     *
     * @param[in] RefPhys The port from which to retrieve settings
     * @param[in] RefTsList List of TSs for which to retrieve settings
     * @param[out] TBS_List A list of Input TSs with their setting
     *
     * @exception OpNotSupported When BoardNr does not identify a Gbe board
     * @exception OpNotSucceeded in case
     * - Invalid input references are used
     * - Inconsistency between RefPhys.PortNr and RefTsList[x].Ref.PortNr in case RefPhys.PortNr != 0xFFFF.
     * - TS does not exist or is not for input
     *
     * @deprecated Since version 10.30, use TimeBaseSelectionMode_V2_GetL instead
     */
    void TimeBaseSelectionMode_GetL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList, 
        out InTS_TimeBaseSelectionMode_List_t TBS_List)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Revert the Time Base Selection Mode to default for a list of input TSs.
     *
     * @param[in] RefPhys The port for which to change to settings
     * @param[in] RefTsList List of TSs for which to delete the settings
     *
     * @exception OpNotSupported When BoardNr does not identify a Gbe board
     * @exception OpNotSucceeded in case
     * - Invalid input references are used
     * - Inconsistency between RefPhys.PortNr and RefTsList[x].Ref.PortNr in case RefPhys.PortNr != 0xFFFF.
     * - TS does not exist or is not for input
     */
    void TimeBaseSelectionMode_DelL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set default Time Base Selection Mode to be used for newly created input TSs. Defaults
     * are set at the board level. eTBS_ForcedPCR and eTBS_CBR_ForcedPCR are not an option here, since this requires
     * a Service Id as well. The board level default takes effect when a new input TS is created.
     *
     * @param[in] BoardNumber The BoardNumber of which parameters need to be changed.
     * @param[in] TBS_Mode The new default setting
     *
     * @exception OpNotSupported This call is not supported in the running software version.
     * @exception OpNotSucceeded In case of
     * - BoardNumber does not identify a Gbe board
     * - The requested default mode is eTBS_ForcedPCR or is out of range.
     *
     * @deprecated Since version 10.30, use SetDefaultTBSMode_V2 instead
     */
    void SetDefaultTimeBaseSelectionMode(in unsigned short BoardNumber, in eTimeBaseSelectionMode TBS_Mode)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get default Time Base Selection Mode that is used for newly created input TSs.
     *
     * @param[in] BoardNumber The BoardNumber of which parameters need to be queried.
     * @param[out] TBS_Mode The current default.
     *
     * @exception OpNotSupported This call is not supported in the running software version.
     * @exception OpNotSucceeded In case of
     * - BoardNumber does not identify a Gbe board
     *
     * @deprecated Since version 10.30, use GetDefaultTBSMode_V2 instead
     */
    void GetDefaultTimeBaseSelectionMode(in unsigned short BoardNumber, out eTimeBaseSelectionMode TBS_Mode)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the board default VBR and CBR latency. Currently the VBR latency should always be 110ms.
     *  Changing the board default applies to all existing input TS's.
     *
     * @param[in] BoardNumber The BoardNumber of which parameters need to be changed.
     * @param[in] CfgIn The new default setting
     *
     * @exception OpNotSupported This call is not supported in the running software version.
     * @exception OpNotSucceeded In case of
     * - BoardNumber does not identify a Gbe board
     * - The requested latency is out of range.
     *
     * @version  Release 6.5 
     */
    void BoardDejitterCfgSet(in unsigned short BoardNumber, in BoardDejitterCfg_t CfgIn)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
     
    /** Get the board default VBR and CBR latency. Currently the VBR latency will always be 110ms.
     *
     * @param[in] BoardNumber The BoardNumber of which parameters need to be changed.
     * @param[in] CfgOut The new default setting
     *
     * @exception OpNotSupported This call is not supported in the running software version.
     * @exception OpNotSucceeded In case of
     * - BoardNumber does not identify a Gbe board
     *
     * @version  Release 6.5 
     **/
    void BoardDejitterCfgGet(in unsigned short BoardNumber, out BoardDejitterCfg_t CfgOut)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the Time Base Selection Mode for a list of input TSs.
     *
     * @param[in] RefPhys The port on which to configure TSs
     * @param[in] TBS_List A list of input TSs with their setting
     *
     * @exception OpNotSupported When BoardNr does not identify a Gbe board
     * @exception OperationFailed in case
     * - Invalid input references are used
     * - Inconsistency between RefPhys.PortNr and TBS_List[x].RefTSIn.Ref.PortNr in case RefPhys.PortNr != 0xFFFF.
     * - TS does not exist or is not for input
     * @exception OpNotSucceeded: Unspecified error
     *
     * @version Supported since release 10.30
     */
    void TimeBaseSelectionMode_V2_SetL(in IPS_Ref_t RefPhys, in InTS_TimeBaseSelectionMode_List_V2_t TBS_List)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Get the Time Base Selection Mode for a list of input TSs.
     *
     * @param[in] RefPhys The port from which to retrieve settings
     * @param[in] RefTsList List of TSs for which to retrieve settings
     * @param[out] TBS_List A list of Input TSs with their setting
     *
     * @exception OpNotSupported When BoardNr does not identify a Gbe board
     * @exception OperationFailed in case
     * - Invalid input references are used
     * - Inconsistency between RefPhys.PortNr and RefTsList[x].Ref.PortNr in case RefPhys.PortNr != 0xFFFF.
     * - TS does not exist or is not for input
     * @exception OpNotSucceeded : Unspecified error
     *
     * @version Supported since release 10.30
     */
    void TimeBaseSelectionMode_V2_GetL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList, 
        out InTS_TimeBaseSelectionMode_List_V2_t TBS_List)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Set default Time Base Selection Mode to be used for newly created input TSs. Defaults
     * are set at the board level. eTBS_ForcedPCR and eTBS_CBR_ForcedPCR are not an option here, since this requires
     * a Service Id as well. The board level default takes effect when a new input TS is created.
     *
     * @param[in] BoardNumber The BoardNumber of which parameters need to be changed.
     * @param[in] TBS_Mode The new default setting
     * @param[in] FastLock Should alwyas be set to false.
     *
     * @exception OpNotSupported This call is not supported in the running software version.
     * @exception OperationFailed in case
     * - BoardNumber does not identify a Gbe board
     * - The requested default mode is eTBS_ForcedPCR or is out of range.
     * @exception OpNotSucceeded : Unspecified error
     *
     * @version Supported since release 10.30
     */
    void SetDefaultTBSMode_V2(in unsigned short BoardNumber, in eTimeBaseSelectionMode_V2 TBS_Mode, in boolean FastLock)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get default Time Base Selection Mode that is used for newly created input TSs.
     *
     * @param[in] BoardNumber The BoardNumber of which parameters need to be queried.
     * @param[out] TBS_Mode The current default.
     * @param[out] FastLock Indicates board wide fast lock option, will always be false for the moment.
     *
     * @exception OpNotSupported This call is not supported in the running software version.
     * @exception OperationFailed in case
     * - BoardNumber does not identify a Gbe board
     * @exception OpNotSucceeded : Unspecified error
     *
     * @version Supported since release 10.30
     */
    void GetDefaultTBSMode_V2(in unsigned short BoardNumber, out eTimeBaseSelectionMode_V2 TBS_Mode, out boolean FastLock)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Input Transport stream setting that defines how the priority bit
     *  in the MPEG header of the incoming packets should be manipulated
     */
    enum ePriorityBitMode
    {
      eTPB_Transparent,    ///< Priority bit will be left unchanged as present on the input.
      eTPB_ForceToZero,   ///< Priority bit will be forced to zero;
      eTPB_ForceToOne    ///< Priority bit will be forced to one
    };

    /// Compact CA descriptor setting (per input TS)
    struct  PriorityBitMode_t
    {
      ePriorityBitMode  Mode;
      boolean           FollowDefaultRule; ///< readonly flag indicating if default priority bit settings are used
    };

    /** Information to change the priority bit of the MPEG packets of an incoming TS.
     */
    struct InTS_PriorityBit_t
    {
      IPS_RefTS_t 	RefIn;              ///< The location of the input TS (Board, Port and Ref).
      PriorityBitMode_t PriorityBitSetting; ///< Indicates how the priority bit should be handled.
    };

    /// A sequence of ChangePrioBitInputTS _t entries.
    typedef sequence<InTS_PriorityBit_t> InTS_PriorityBit_List_t;

    /** Change the transport priority bit behavior for one or more existing incoming TS.
     * 
     * @param[in] RefPhys                The port for which parameters need to be changed.
     * @param[in] InTS_PriorityBit_List  List of ChangePrioBitInputTS_t entries.
     * 
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of
     * - Inconsistency between RefPhys & InputTSList[x].Ref.BoardNr.
     * - Inconsistency between PortNr & InputTSList[x].Ref.PortNr in case RefPhys.PortNr != 0xFFFF.
     * - Invalid enum value (ePrioBitSetting_t).
     * @exception LicenseError In case PRIORITY_BIT_ADAPTATION license is missing.
     * 
     * @version  Release 7.5
     */
    void InTS_PriorityBits_SetL(in IPS_Ref_t RefPhys, in InTS_PriorityBit_List_t InTS_PriorityBit_List) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);

    /** Get the list of transport priority bit settings for a number of incoming transport streams.
     *
     * @param[in] RefPhys    The port of which you want the information.
     * @param[in] RefTsList  A Ref_List_t, sequence of TS Ref's you want info about.
     *
     * @return InTS_PriorityBit_List_t  A sequence of ChangePrioBitInputTS_t entries.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid references(RefList) are used.
     *
     * - An empty ReTsfList means all TS refs.
     * @version  Release 7.5
     */
    InTS_PriorityBit_List_t InTS_PriorityBits_GetL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Revert the Priority Bit setting to default for a list of input TSs.
     *
     * @param[in] RefPhys    The port for which to change to settings
     * @param[in] RefTsList  List of TSs for which to delete the settings
     *
     * @exception OpNotSupported When called for other than IO boards (Main).
     * @exception OpNotSucceeded in case
     * - Invalid input references are used
     * - TS does not exist or is not for input
     * @exception LicenseError In case PRIORITY_BIT_ADAPTATION license is missing.
     */
    void InTS_PriorityBits_DelL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);

    /** Set default priority setting for new input TS.
     * 
     * @param[in] SlotNbr             Specifies the BoardNr on which to apply these defaults.
     * @param[in] PriorityBitSetting  ePrioBitSetting_t values for new input TSs.
     * 
     * @exception OpNotSupported When called for other than IO boards (Main).
     * @exception OpNotSucceeded In case of
     * - Invalid enum values.
     * - For board wide setting the new value must be one of eTransparent, eForceToOne or eForceToZero.
     * @exception LicenseError In case PRIORITY_BIT_ADAPTATION license is missing.
     * 
     * @version  Release 7.5
     */
    void SetDefaultPriorityBit(in unsigned short SlotNbr, in ePriorityBitMode PriorityBitSetting)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);
    
    /** Get current default PrioBitSetting.
     * 
     * @param[in]  SlotNbr             BoardNr of which we want the information.
     * @param[out] PriorityBitSetting  the default Priority Bit Setting.
     * 
     * @exception OpNotSupported When called for other than IO boards (Main).
     * @version  Release 7.5
     */
    void GetDefaultPriorityBit(in unsigned short SlotNbr, out ePriorityBitMode PriorityBitSetting) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Set the Pass Motorola C0/C1 table setting.
     * 
     * @param[in]  BoardNumber The board number of which we want the information.
     * @param[in]  Pass        The new setting to apply.
     * 
     * @exception OpNotSupported When called for other than IO boards (Main).
     * @version  Release 7.5
     */        
    void SetPassMotorolaTables(in unsigned short BoardNumber, in boolean Pass)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get current Pass Motorola C0/C1 table setting.
     * 
     * @param[in]  BoardNumber The board number of which we want the information.
     * @param[out] Pass        The current setting.
     * 
     * @exception OpNotSupported When called for other than IO boards (Main).
     * @version  Release 7.5
     */        
    void GetPassMotorolaTables(in unsigned short BoardNumber, out boolean Pass)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);        



    struct IPS_OutputTS_LT_t
    {
      IPS_RefTS_t OutRef;           ///< The location of the OutputTS (Board, Port and Ref).
      IPS_RefTS_t InRef;            ///< The location of the InputTS (Board, Port and Ref).
      IPS_RefTS_t ActiveInRef;      ///< The location of the ActiveInputTS (Board, Port and Ref).
      IPS_UDP_Socket_t Socket;      ///< Unique IP-Address and UDP port combination.
      eIPS_StreamingState State;
      unsigned long TS_OutProperty; ///< Read only Bitmap used by GUI to display specific icons. 
                                    ///< Bit  3: TRUE if RTP is streamed
                                    ///< Bit  4: TRUE if VLAN is enabled
                                    ///< Bit  9: TRUE if FEC column stream is enabled
                                    ///< Bit 10: TRUE if FEC row stream is enabled
    };

    /// A sequence of IPS_OutputTS_LT_t entries.
    typedef sequence<IPS_OutputTS_LT_t> IPS_OutputTS_LT_List_t;

    struct IPS_OutputTS_LT_V2_t
    {
      IPS_RefTS_t OutRef;           ///< The location of the OutputTS (Board, Port and Ref).
      IPS_RefTS_t InRef;            ///< The location of the InputTS (Board, Port and Ref).
      IPS_RefTS_t ActiveInRef;      ///< The location of the ActiveInputTS (Board, Port and Ref).
      IPS_UDP_Socket_t Socket;      ///< Unique IP-Address and UDP port combination.
      enStreamingSetting_t Setting; /**< Streaming setting of the outgoing TS.
                                     * - Auto will behave similar as On.
                                     */            
      eIPS_StreamingState State;    /// Read only state 
      unsigned long TS_OutProperty; ///< Read only Bitmap used by GUI to display specific icons.
                                    ///< Bit  3: TRUE if RTP is streamed
                                    ///< Bit  4: TRUE if VLAN is enabled
                                    ///< Bit  9: TRUE if FEC column stream is enabled
                                    ///< Bit 10: TRUE if FEC row stream is enabled
    };

    /// A sequence of IPS_OutputTS_LT_V2_t entries.
    typedef sequence<IPS_OutputTS_LT_V2_t> IPS_OutputTS_LT_List_V2_t;

    /** Create a number of Transparent Loop Through TSs on given Slot and Port. 
     *
     * @param[in] RefPhys The BoardNr and PortNr on which TSs need to be added.
     * @param[in] OutputTSList Parameters of the new TS's. if IP and UDP is Invalid, boarddefault will be used.
     *
     * @exception OpNotSupported When called for other boards than GbE or ASI ones (Main, Transcoder, ..).
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys).
     * - Maximum number of supported TSs/board is reached.
     * - Maximum number of supported TSs/port is reached.
     * - ASI SFN MKII board which is in Deterministic Remux mode
     *
     * @note 
     * On a loop through output TS only limited settings are possible:
     * It is possible to change IP related settings on a GbE TS (Ip address, UDP port, TOS, TTL, 
     * VLAN and FEC). Other TS settings are not supported by a loop through TS and these IDL calls 
     * will then return an OpNotSucceeded exception
     *
     * @version  Release 5.1
     * @note 
     * From release 8.2 more strict checking is done : trying to create a second loop through
     * on an ASI output port will now return an OpNotSucceeded instead of overwrting any older
     * loop through transport stream.
     *      
     */
    void IPS_OutTS_LT_AddL(in IPS_Ref_t RefPhys,in IPS_OutputTS_LT_List_t OutputTSList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Create a number of Transparent Loop Through TSs on given Slot and Port.
     *
     * @param[in] RefPhys The BoardNr and PortNr on which TSs need to be added.
     * @param[in] OutputTSList Parameters of the new TS's. if IP and UDP is Invalid, boarddefault will be used.
     *
     * @exception OpNotSupported When called for other boards than GbE or ASI ones (Main, Transcoder, ..).
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys).
     * - Maximum number of supported TSs/board is reached.
     * - Maximum number of supported TSs/port is reached.
     * - ASI SFN MKII board which is in Deterministic Remux mode
     *
     * @note
     * On a loop through output TS only limited settings are possible:
     * It is possible to change IP related settings on a GbE TS (Ip address, UDP port, TOS, TTL,
     * VLAN and FEC). Other TS settings are not supported by a loop through TS and these IDL calls
     * will then return an OpNotSucceeded exception
     *
     * @version  Release 8.5
     */
    void IPS_OutTS_LT_AddL_V2(in IPS_Ref_t RefPhys,in IPS_OutputTS_LT_List_V2_t OutputTSList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Change the parameters of one or more existing outgoing TS.
     *
     * @param[in] BoardNumber The BoardNr which parameters need to be changed.
     * @param[in] OutputTSList List of IPS_OutputTS_LT_t entries.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys).
     * - Inconsistency between RefPhys.BoardNr & OutputTSList[x].Ref.BoardNr.
     * - Inconsistency between RefPhys.PortNr & OutputTSList[x].Ref.PortNr in case RefPhys.PortNr != 0xFFFF.
     * - Out of range values (UDPPort).
     * - Invalid enum value (State).
     *
     */
    void IPS_OutTS_LT_ChangeL(in unsigned short BoardNumber,in IPS_OutputTS_LT_List_t OutputTSList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Change the parameters of one or more existing outgoing TS.
     *
     * @param[in] BoardNumber The BoardNr which parameters need to be changed.
     * @param[in] OutputTSList List of IPS_OutputTS_LT_V2_t entries.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys).
     * - Inconsistency between RefPhys.BoardNr & OutputTSList[x].Ref.BoardNr.
     * - Inconsistency between RefPhys.PortNr & OutputTSList[x].Ref.PortNr in case RefPhys.PortNr != 0xFFFF.
     * - Out of range values (UDPPort).
     * - Invalid enum value (State).
     *
     * @version  Release 8.5
     */
    void IPS_OutTS_LT_ChangeL_V2(in unsigned short BoardNumber,in IPS_OutputTS_LT_List_V2_t OutputTSList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get a list of outgoing Transparent Loop Through TSs and their parameters.
     * 
     * @param[in] RefPhys The BoardNr and PortNr you want information about.
     * @param[in] RefList A sequence of Ref's you want info about.
     * 
     * @return IPS_OutputTS_LT_List_t, a sequence of IPS_OutputTS_LT_t entries.
     * 
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid references (RefPhys, RefList) are used.
     * @note 
     * - A value of 0xFFFF for port means all ports.
     * - An empty list means all refs.
     */
    IPS_OutputTS_LT_List_t IPS_OutTS_LT_GetL(in IPS_Ref_t RefPhys, in Ref_List_t RefList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Get a list of outgoing Transparent Loop Through TSs and their parameters.
     *
     * @param[in] RefPhys The BoardNr and PortNr you want information about.
     * @param[in] RefList A sequence of Ref's you want info about.
     *
     * @return IPS_OutputTS_LT_List_V2_t, a sequence of IPS_OutputTS_LT_V2_t entries.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid references (RefPhys, RefList) are used.
     * @note
     * - A value of 0xFFFF for port means all ports.
     * - An empty list means all refs.
     *
     * @version  Release 8.5
     */
    IPS_OutputTS_LT_List_V2_t IPS_OutTS_LT_GetL_V2(in IPS_Ref_t RefPhys, in Ref_List_t RefList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    struct PortTsSvcProps_t 
    {
      IPS_Ref_t RefPhys;
      
      /**
       * Bit map of aggregated TS Properties on a port
       *
       * Bit mapping for input TS properties
       * * Bit 8:  TRUE if UDP Stream Loss/ASI TS Sync Loss alarm is active. 
       *   From V10.10 also if CC error is active (Mask: BITMAP_INPUT_TS_ALARM_ACTIVE)
       * * Bit 13: TRUE if TsLoss Alarm is active (backup trigger) 
       *   (Mask: BITMAP_INPUT_TS_TSLOSS_ALARM_ACTIVE)
       *
       * For output TSs bitmap is zero
       *
       */
      unsigned long TsProps;
      /*
       * Bit map of aggregated Service Properties on a port
       *
       * Bit mapping for input Svc properties
       * Bit 3: TRUE if Service Loss Alarm is active (Mask: BITMAP_SERVICE_ALARM_ACTIVE)
       *
       * Bit mapping for output Svc properties
       * Bit 6: True if Service Loss Alarm is active (Mask: BITMAP_OUTPUT_SERVICE_ALARM_ACTIVE)
       * 
       */
      unsigned long SvcProps; 
    };
    typedef sequence<PortTsSvcProps_t> PortTsSvcProps_List_t;

    /** Get the aggregated TS and Service Properties per Input Port
     *
     * @param[in] RefPhys The BoardNr and PortNr you want information about.
     *
     * @return PortTsSvcProps_List_t, sequence of aggregated properties for all TS and services per port
     *
     * @exception OpNotSupported when BoardNr = 0 = Main board
     * @exception OperationFailed when given port is not an input port
     * @exception OperationFailed when 0xFFFF (all ports) is passed as port number
     * @exception OperationFailed when property collection fails
     *
     *
     * @version Release 11.10
     */
     PortTsSvcProps_List_t PortInTsSvcPropsGetL(in IPS_Ref_t RefPhys)
       raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported,OperationFailed);

    /** Get the aggregated TS and Service Properties per Output Port
     *
     * @param[in] RefPhys The BoardNr and PortNr you want information about.
     *
     * @return PortTsSvcProps_List_t, sequence of aggregated properties for all TS and services per port
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board
     * @exception OperationFailed When given port is not an output port
     * @exception OperationFailed when property collection fails
     *
     * @note 
     * - A value of 0xFFFF for port means all ports.
     *
     * @version Release 11.10
     */
     PortTsSvcProps_List_t PortOutTsSvcPropsGetL(in IPS_Ref_t RefPhys)
       raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported,OperationFailed);



    /// @} end of group ts


#endif // DISABLE_MUX_TS

    /** @defgroup services Service
     * This contains types, enums and methods to configure the TS Services of the multiplexer part in the device.
     * @{
     */


    
    // Service Structures and enums
    // ------------------------------------------------------------------------------------
    /** service id type */
    typedef unsigned long ServiceId_t;

    /** SID reference.
     */
    struct IPS_Service_t
    {
      IPS_RefTS_t Ref;   ///< Identifies the unique location (Board, Port, TS).
      ServiceId_t SID; ///< SID range: 0..65535
    };
    /** Undefined sid */
    const ServiceId_t INVALID_SID=0xffffffff;

    /** Input parameter: 
     * Service creation: If you don't want any particular SID 
     */
    const ServiceId_t ANY_SID=0xffffffff;

    /// A sequence of IPS_Service_t.
    typedef sequence<IPS_Service_t> IPS_Service_List_t;

    /// alternate source id type
    typedef unsigned long AlternateSrcId_t;
    
    /** List of service ID's to use as a filter in IPS_InServiceGetL() and IPS_OutServiceGetL().
     * @note This used to be a list of short which was inconsistent. SID is an unsigned long.
     */
    typedef sequence<ServiceId_t> ServiceIdList_t;

    typedef sequence<octet> DvbString_t;
    
    
    const unsigned long BITMAP_INPUT_PRESENT               = 0x1;
    const unsigned long BITMAP_SCRAMBLED_BY_DCM            = 0x2;
    const unsigned long BITMAP_ACTIVE                      = 0x4;
    const unsigned long BITMAP_MERGED_SERVICE              = 0x8; ///< For output services
    const unsigned long BITMAP_SERVICE_ALARM_ACTIVE        = 0x8; ///< For input services
    const unsigned long BITMAP_SCRAMBLED_ON_INPUT          = 0x10;
    const unsigned long BITMAP_OUTPUT_SERVICE_ALARM_ACTIVE = 0x40; ///< For output services
    const unsigned long BITMAP_INPUT_SIGNAL_PRESENT        = 0x80000000;
    /** Incoming service information.
     */
    struct IPS_Service_In_t
    {
      IPS_RefTS_t RefIn;
      ServiceId_t InputSID;
      unsigned long ServiceInProperty;   ///< Read only Bitmap used by GUI to display specific icons (@see BITMAP_INPUT_PRESENT etc.)
                                         ///< Bit 0: TRUE if Service is present in input TS
                                         ///< Bit 3: TRUE if Service Loss Alarm is active.                                          
                                         ///< Bit 4: TRUE if at least one of the input PIDs is scrambled
                                         ///< Bit 31: TRUE if Service contains VBI (future) (same bit as in TC_ServiceData_t)
                                         ///< @note: present or not present is based on SI.
      DvbString_t SystemName;            ///< Maximum string length 255 characters
      DvbString_t UserName;              ///< Maximum string length 255 characters
      eEsTypeStandard m_EsTypeStandard;  ///< The standard of the input TS.
    };
    
    /// A sequence of IPS_Service_In_t.
    typedef sequence<IPS_Service_In_t> IPS_ServiceIn_List_t;
    
  /** EIT Schedule flag.
   * 
   * when set to "eEitSch_ForceEitSchedulePresent" indicates that EIT schedule
   *  information for the service is present in the current TS.
   */
    enum eEitSchedule
    {
      eEitSch_Transparent,
      eEitSch_ForceEitScheduleNotPresent,
      eEitSch_ForceEitSchedulePresent
    };

   /** EIT Present Following present flag.
    * 
    * when set to "eEitPF_ForceEitPresentFollowingPresent" indicates that EIT_present_following
    * information for the service is present in the current TS,
    */
    enum eEitPresentFollow
    {
      eEitPF_Transparent,
      eEitPF_ForceEitPresentFollowingNotPresent,
      eEitPF_ForceEitPresentFollowingPresent
    };

   /** The Conditional Access (CA) Mode.
    * 
    * when set to "eCA_ForceNotScrambled" indicates that all the component streams 
    * of the service are not scrambled. When set to "eCA_ForceScrambled" it indicates
    * that access to one or more streams may be controlled by a CA system.
    */
    enum eCaMode
    {
      eCA_Transparent,
      eCA_ForceNotScrambled,
      eCA_ForceScrambled
    };

   /** The Running status - This indicates the status of the service.
    */
    enum eRunningStatus
    {
      eRS_Undefined,
      eRS_NotRunning,
      eRS_StartSoon,
      eRS_Pausing,
      eRS_Running,
      eRS_Future,
      eRS_Transparent //defined for output only
    };

/** The Service Type
 * 
 * NOTE: as of V04-05-22: eST_Undefined was at place 0, but it has been replaced by
 * eST_Transparent because the enum has been expanded.
 */
    enum eServiceType
    {
      eST_Transparent,
      eST_DigitalTv,
      eST_DigitalRadio,
      eST_Teletext,
      eST_NVODReference,
      eST_NVODTimeShifted,
      eST_Mosaic,
      eST_Pal,
      eST_Secam,
      eST_Dd2Mac,
      eST_FmRadio,
      eST_Ntsc,
      eST_DataBroadcast,
      eST_Reserved,
      eST_RcsMap,
      eST_RcsFls,
      eST_DvbMhp,
      eST_Mpeg2HD,
      eST_Reserved18,
      eST_Reserved19,
      eST_Reserved20,
      eST_Reserved21,
      eST_AdvancedSD,
      eST_AdvancedSD_NVOD_TimeShifted,
      eST_AdvancedSD_NVOD_Reference,
      eST_AdvancedHD,
      eST_AdvancedHD_NVOD_TimeShifted,  
      eST_AdvancedHD_NVOD_Reference
    };
    
    /** Structure that contains data about the Service Description Table of a service.
     */
    struct IPS_SDT_Data_t
    {
      boolean InputSDTPresent;       ///< RO flag
      boolean OutputSDTPresent;      ///< RW flag. false = Follow Input; true = Overrule
      boolean EITscheduleIn;         ///< RO provides EIT_schedule_flag of input (Present = 1)
      eEitSchedule EITschOut;        ///< RW (Transparent, Schedule Present, Schedule Not Present)
      boolean EITpresFollowIn;       ///< RO provides EIT_present_following flag of input (Present = 1)
      eEitPresentFollow EITpfOut;    ///< RW (Transparent, Sch. PF Present, Sch. PF Not Present)
      boolean FreeCAmode;            ///< RO provides free_CA_mode of input (Scrambled = 1)
      eCaMode CAmodeOut;             ///< RW (Transparent, Not Scrambled, CA Present)
      eRunningStatus RunStatusIn;    ///< RO provides running status of input
      eRunningStatus RunStatusOut;   ///< RW (Transparent or configurable status)
      eServiceType ServiceTypeIn;    ///< RO provides service type of input
      eServiceType ServiceTypeOut;   ///< RW (Transparent or configurable)
      boolean UseOutputUserName;     ///< User forced change of output service name
      DvbString_t OutputUserName;    ///< Maximum string length 255 characters
      boolean UseOutputServiceProviderName; ///< User forced change of output service provider name
      DvbString_t ServiceProviderNameIn;
      DvbString_t ServiceProviderNameOut;
    };
      
    /** 
     */
    struct IPS_ServiceData_Out_t
    {
      IPS_RefTS_t RefOut;
      ServiceId_t OutputSID; /**< ID of an outgoing service
                                * - 0xFFFFFFFF: Don't care or not allocated yet.
                                * - 0..65536
                                */
      unsigned long ServiceOutProperty;   ///< Read only Bitmap used by GUI to display specific icons (@see BITMAP_INPUT_PRESENT etc.)
                                          ///< Bit 0: Service present at input (true) or not (false). 
                                          ///< Bit 1: Service scrambled by %DCM (true)
                                          ///< Bit 2: Service Active (Session Based)
                                          ///< Bit 3: Service is merged by %DCM
                                          ///< Bit 4: at least one of the source input PIDs of this service is scrambled  
                                          ///< Bit 5: TRUE if output service is in backup
                                          ///< Bit 6: TRUE if output service loss is active
                                          ///< Bit 7: True if output service is streaming
                                          ///< Bit 8: True if Service Redundancy Alarm is active
                                          ///< Other bits for future use.
      boolean FixedRemap;         ///< User forced change of output service ID
      boolean HDService;          /**< Read/Write:  Holds true if service is High definition service
                                   * false for Standard definition service.*/
      boolean DVB_ScramblingLicense; /**< Read/Write: Holds true if service wants/has DVB_SCRAMBLING license
                                      *                 false if no license*/
      IPS_SDT_Data_t SDTData;
      IPS_Service_In_t Service;   ///< Reference to the incoming service
    };
    
    /// A sequence of IPS_ServiceData_Out_t entries.
    typedef sequence<IPS_ServiceData_Out_t> IPS_ServiceDataOut_List_t;

    /** 
     * A reference to a service. 
     */
    struct IPS_RefSvc_t
    {
      IPS_RefTS_t RefOut;      ///< RefTS of the service TS, not necessarily an output TS as the name wrongly suggests
      unsigned long SvcIdent;  ///< For the moment this value equals the service ID
    };
    /// A sequence of IPS_RefSvc_t entries.
    typedef sequence<IPS_RefSvc_t> IPS_RefSvc_List_t;

    typedef sequence<unsigned short> SidList_t;

    /** 
     * A definition of an input service as used on the output.
     */
    struct IPS_Service_In_V2_t
    {
      IPS_Service_t Service;
      DvbString_t Name;       ///< Read only: The name of the service.
    };

   /** Extended information about an output service.
    */
    struct IPS_ServiceData_Out_V2_t
    {
      IPS_RefSvc_t  ServiceOut;         ///< Identifies the output service
      ServiceId_t NewOutputSID;       /**< Requested Service ID for an outgoing service
                                         * - Legal values are 1..65535 */
      unsigned long ServiceOutProperty; ///< Read only Bitmap used by GUI to display specific icons 
                                        ///< Bit 0: Service present at input (true) or not (false). 
                                        ///< Bit 1: Service scrambled by DCM (true means scrambled)
                                        ///< Bit 2: Service Active (Session Based)
                                        ///< Bit 3: Service is merged
                                        ///< Bit 4: at least one of the source input PIDs of this service is scrambled  
                                        ///< Bit 5: True if output service is in backup
                                        ///< Bit 6: True if output service loss is active
                                        ///< Bit 7: True if output service is streaming
                                        ///< Bit 8: True if Service Redundancy Alarm is active
                                        ///< Other bits for future use.
      boolean FixedRemap;               ///< User forced change of output service ID
      boolean HDService;                /**< Read/Write:  Holds true if service is High definition service
                                         * false for Standard definition service.*/
      boolean DVB_ScramblingLicense;    /**< Read/Write: Holds true if service wants/has DVB_SCRAMBLING
                                         *   license; false if no license */
      IPS_SDT_Data_t SDTData;
      IPS_Service_In_V2_t MainInputService;   ///< Read only : Reference to the main input service that was used to create the output service
      IPS_Service_In_V2_t ActiveInputService; ///< Read only : can be different from main input service e.g. when service is in backup, ...
    };
    
    /// A sequence of IPS_ServiceData_Out_V2_t entries.
    typedef sequence<IPS_ServiceData_Out_V2_t> IPS_ServiceDataOut_List_V2_t;

   /** Extended information about an output service.
    */
    struct IPS_ServiceData_Out_V3_t
    {
      IPS_RefSvc_t  ServiceOut;         ///< Identifies the output service
      ServiceId_t NewOutputSID;       /**< Requested Service ID for an outgoing service
                                         * - Legal values are 1..65535 */
      unsigned long ServiceOutProperty; ///< Read only Bitmap used by GUI to display specific icons 
                                        ///< Bit 0: Service present at input (true) or not (false). 
                                        ///< Bit 1: Service scrambled by DCM (true means scrambled)
                                        ///< Bit 2: Service Active (Session Based)
                                        ///< Bit 3: Service is merged
                                        ///< Bit 4: at least one of the source input PIDs of this service is scrambled  
                                        ///< Bit 5: True if output service is in backup
                                        ///< Bit 6: True if output service loss is active
                                        ///< Bit 7: True if output service is streaming
                                        ///< Bit 8: True if Service Redundancy Alarm is active
                                        ///< Other bits for future use.
      boolean FixedRemap;               ///< User forced change of output service ID
      boolean HDService;                /**< Read/Write:  Holds true if service is High definition service
                                         * false for Standard definition service.*/
      boolean DVB_ScramblingLicense;    /**< Read/Write: Holds true if service wants/has DVB_SCRAMBLING
                                         *   license; false if no license */
      IPS_SDT_Data_t SDTData;
      IPS_Service_In_V2_t MainInputService;   ///< Read only : Reference to the main input service that was used to create the output service
      IPS_Service_In_V2_t ActiveInputService; ///< Read only : can be different from main input service e.g. when service is in backup, ...
      AlternateSrcId_t ActiveSourceId;        ///< Read only: the source ID of the currently active alternate source
    };
    
    /// A sequence of IPS_ServiceData_Out_V3_t entries.
    typedef sequence<IPS_ServiceData_Out_V3_t> IPS_ServiceDataOut_List_V3_t;

    /** Outgoing service information
     */
    struct ServiceBlockCAInfo_t
    {
      IPS_Service_t RefServ;
      boolean blockCAInfo;         /**< Indicates if the CA info needs to be blocked for the service
                                    * If true, the EIT, SDT and PMT table is updates and ECM components are blocked. */
    };
    
    /// A sequence of ServiceBlockCAInfo_t entries
    typedef sequence<ServiceBlockCAInfo_t> ServiceBlockCAInfo_List_t;

    /**
     * Structure with service data for a transcoder board.
     */
    struct TC_ServiceData_t
    {
      IPS_RefSvc_t RefSvc;          ///< Read only : The RefSvc of this service, either main or PIP (PIP not supported in Version 7.01)
      IPS_RefSvc_t ParentRefSvc;    ///< Read only : The RefSvc of the main service. If RefSvc == ParentRefSvc, this is a main service. For PIP RefSvc <> ParentRefSvc.
      ServiceId_t SID;              ///< Read only : The SID of the service
      unsigned long TC_Property;    ///< Read only Bitmap used by GUI to display
                                    ///< Bit 0: Service present at input (true) or not (false).
                                    ///< Bit 4: at least one of the source input PIDs of this service is scrambled
                                    ///< Bit 5: TRUE if service is in backup
                                    ///< Bit 6: TRUE if Service Loss Alarm is active.
                                    ///< Bit 29: TRUE if service can't be deleted (e.g. because it's passed to an output)
                                    ///< Bit 30: TRUE if transcoding is enabled on one of the components of the Service
                                    ///<         TRUE if service on a MFP board is processing (transrating/transcoding) audio or video
                                    ///< Bit 31: TRUE if Service contains VBI (future) (same bit as in IPS_Service_In_t)
                                    ///   - Other bits for future use.
      IPS_Service_In_V2_t MainInputService;   ///< Read only : Reference to the main input service that was used to create the service
      IPS_Service_In_V2_t ActiveInputService; ///< Read only : can be different from main input service e.g. when service is in backup, ...
      DvbString_t UserTag;                    ///< Maximum string length 255 characters
    };

    /// A sequence of TC_ServiceData_t entries.
    typedef sequence<TC_ServiceData_t> TC_ServiceData_List_t;

    /// The type of tracking criterium.
    enum enuTrackTypeV2
    {
      eTrackV2_ComponentTag,
      eTrackV2_Pcr,
      eTrackV2_StreamType,
      eTrackV2_EsPid,    ///< m_usInputPid <> INVALID_PID_VALUE, m_usInputECM_PID == INVALID_PID_VALUE.
      eTrackV2_EcmPid,   ///< m_usInputECM_PID <> INVALID_PID_VALUE, m_usInputPid == INVALID_PID_VALUE.
      eTrackV2_EsEcmPid, ///< m_usInputECM_PID <> INVALID_PID_VALUE, m_usInputPid <> INVALID_PID_VALUE.
      eTrackV2_EcmCasId,
      eTrackV2_EsEcmCasId
    };

   /************************
    * @note : 
    *   @version DCM V9.0 : if ulDescriptorTag is set to 0xA1 or 0xA2 and oStreamType 
	*                   to 0xC0 in a component rule, DCM software will assume that EISS
    *                   (ETV Integrated Signalling Stream) (ulDescriptorTag = 0xA2) or 
	*                   Baseline EBIF (ETV Binary Interchange Format) (ulDescriptorTag = 0xA1)
    *                   matching is intended.
    *                   As a consequence the software will also check that a Registration Descriptor 
    *                   with content "ETV1" is present with the component before an actual match to
    *                   the TrackingCriterium will occur.
    */
    struct TrackingCriterium_t
    {
      enuTrackTypeV2  enTrackType;
      octet           oComponentTag;
      octet           oStreamType;
      string          strLanguage;
      unsigned long   ulDescriptorTag;
      unsigned short  usInputPid;
      unsigned short  usParentEsOutputPid;
      unsigned short  usCasId;
    };

    struct MergeCriterium_t
    {
      TrackingCriterium_t TrackingCriterium;
      IPS_RefPidList_t MergedComponents;    ///< a list of IPS_RefPid_t's of components merged in by this TrackingCriterium
    };

    typedef sequence<MergeCriterium_t> MergeCriteriumList_t;

    struct ComponentMergeCriterium_t
    {
      AlternateSrcId_t AlternateSrcId;
      IPS_RefSvc_t  ServiceIn;
      MergeCriteriumList_t MergeCriteriumList; ///< For the set call this is the new
                                               /// complete list of merge criteria
                                               /// for an input service
    };

    typedef sequence<ComponentMergeCriterium_t> ComponentMergeCriteriumList_t;



#ifndef DISABLE_MUX_SVC
    // Service IDLs
    // ------------------------------------------------------------------------------------
    /** Gets the list of services on an input TS that are passed to an output 
     * or currently present in the incoming transport stream.
     * Remark that input services which have Service Loss specific settings
     * that are not present in the input transport stream and not passed to any 
     * output are NOT returned in this call. Use the call GetServiceLossTriggers
     * to retrieve this info for these services.
     *
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the TS. 
     * @param[in] InputSidList A list of Service ID's to get info about.
     *
     * @return IPS_ServiceIn_List_t List of IPS_Service_In_t entries.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid input references are used (RefTS, InputSidList).
     *
     * @note 
     * - A value of 0xFFFFFFFF for Ref means get services on all TS's on a physical port.
     * - An empty InputSidList list returns information about all services.
     * - SystemName is the SDT name. If the SDT name doesn't exist (or is empty)
     *   the UserName field becomes the displayed name.
     */
     IPS_ServiceIn_List_t IPS_InServiceGetL(in IPS_RefTS_t RefTS, in ServiceIdList_t InputSidList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the list of services on an output TS.
     *
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the TS. 
     * @param[in] OutputSidList A list of Service ID's to get info about.
     *
     * @return IPS_ServiceDataOut_List_t List of IPS_ServiceOut_t entries
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid output references are used (RefTS, OutputSidList).
     *
     * @note
     * - A value of 0xFFFFFFFF for Ref means get services on all TS's on a physical port. @n
     * - Also for DPI it will be necessary to set/get a separate user name. @n
     * - An empty OutputSidList list returns information about all services. @n
     * - SystemName will be the displayed name for the input service, the UserName field is not used and will be empty. @n
     * - If UseOutputUserName is unchecked, the SystemName will be the output SDT name. @n
     * - If UseOutputUserName is checked, OutputUserName will be the output SDT name. @n
     * - The SDT flags reflect the input SDT values (if present), and the other fields reflect the current settings. @n
     * - The SDT service provider name will be the input name unless UseOutputServiceProviderName is checked.
     */
    IPS_ServiceDataOut_List_t IPS_OutServiceGetL(in IPS_RefTS_t RefTS, in ServiceIdList_t OutputSidList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Delete a list of services in one or more TS on the same board.
     *
     * @param[in] RefPhys A BoardNr, PortNr and Ref specifying the TS.
     * @param[in] ServiceList A list of services to delete.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case
     * - Invalid references are used (RefTS, ServiceList).
     * - Inconsistency between RefTS.PhysRef.BoardNr & ServiceList[x].Ref.PhysRef.BoardNr.
     * - Inconsistency between RefTS.PhysRef.PortNr & ServiceList[x].Ref.PhysRef.PortNr in case RefTS.RefPhys.PortNr != 0xFFFF.
     * - Inconsistency between RefTS.Ref & ServiceList[x].Ref.Ref in case RefTS.RefPhys.Ref != 0xFFFF.
     *
     * @note Services are also deleted when OutputTS gets deleted.
     */
    void IPS_OutServiceDeleteL(in IPS_Ref_t RefPhys, in IPS_Service_List_t ServiceList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Add a list of services to one or more outgoing TS on the same RefPhys.
     *
     * @param[in] RefPhys BoardNr and PortNr specifying the port to add services.
     * @param[in] ServiceDataList Specifies on which ref to add and which service to be added
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case of
     * - Invalid references are used (RefPhys,...)
     * - Inconsistency between RefPhys.BoardNr & ServiceDataList[x].RefOut.PhysRef.BoardNr.
     * - Inconsistency between RefPhys.PortNr & ServiceDataList[x].RefOut.PhysRef.PortNr in case RefPhys.PortNr != 0xFFFF.
     * - Out of range SIDs
     *
     * @note 
     * - Pre-configuration is possible.
     * - An OutputSID value will be assigned by the software when the OutputSID value is set to 
     *   0xFFFFFFFF in the IDL call.  If another value is supplied it will be used for the OutputSID
     *   unless the value is already in use (no remapping will occur for a conflict).
     * - SystemName, UserName, OutputUserName are not used in this function and should be NULL.
     * - FixedRemap and UseOutputUserName are not used in this function and should be NULL.
     * - The SDT fields (EIT flags, CA, runningstatus) are not used in this function and should be NULL.
     */
    void IPS_OutServiceAddL(in IPS_Ref_t RefPhys, in IPS_ServiceDataOut_List_t ServiceDataList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set service details via a list on an input TS.
     *
     * @param[in] RefPhys BoardNr and PortNr specifying the port of the service.
     * @param[in] ServiceDataList A list of IPS_Service_In_t specifying the service to be modified,
     * holding the ServiceInProperty bitmap and UserName for each service.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid input references are used (RefPhys, ServiceDataList).
     *
     * @note
     * - UserName field is only valid and changeable when input ServiceName is NULL.
     */
    void IPS_InServiceSetL(in IPS_Ref_t RefPhys, in IPS_ServiceIn_List_t ServiceDataList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set service details via a list on an output TS.
     *
     * @param[in] RefPhys BoardNr and PortNr specifying the port of the service.
     * @param[in] ServiceDataList A list of IPS_Service_In_t. They uniquely identify the output service and
     * specify the ServiceOutProperty, FixedRemap, OutputSID and/or UseOutputUserName, OutputUserName for each service.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid input references are used (RefPhys, ServiceDataList).
     * @exception LicenseError in case of
     * - no licenses left
     * - already existing TS with same ONID/TSID has services with license
     *
     * @note
     * - Read/ Write fields of ServiceOutProperty can be set via this call.
     * - Read only fields are ignored.
     * - OutputUserName change is specified via UseOutputUserName boolean.
     * - OutputSID change is specified via FixedRemap boolean.
     * - EIT output flag changes are specified via corresponding enum setting
     * -    EITschOut
     * -    EITpfOut
     * -    CAmodeOut     
     * -    RunStatusOut
     * -    ServiceType
     * - ServiceProviderNameOut change is specified via UseOutputServiceProviderName boolean.
     */
    void IPS_OutServiceSetL(in IPS_Ref_t RefPhys, in IPS_ServiceDataOut_List_t ServiceDataList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);
    
     struct IPS_MergedInService_t
     {
       IPS_Service_t Service;   
       unsigned long ServiceProperty; // * - Bit 0: Service present at input (true) or not (false). 
     };
     typedef sequence<IPS_MergedInService_t> IPS_MergedInServiceList_t;

    /** Merge list of input services into an output service.
     *
     * @param[in] OutService The service in which the input services must be merged.
     * @param[in] ServiceMergeList A list of input services to be merged.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case
     * - invalid input references are used (RefPhys, OutService, ServiceMergeList).
     * - already merged in service in ServiceMergeList
     *
     * @note already merged in services are not touched
     */
    void IPS_OutServiceAddMergeL(in IPS_Service_t OutService, in IPS_Service_List_t ServiceMergeList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** remove list of merged services from an output service.
     *
     * @param[in] OutService The service from which the merged services must be removed.
     * @param[in] ServiceMergeList A list of merged services to be removed.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case
     * - invalid input references are used (RefPhys, OutService, ServiceMergeList).
     * - not found merged in service in ServiceMergeList
     *
     * @note an empty ServiceMergeList means delete all merged in services
     */
    void IPS_OutServiceDelMergeL(in IPS_Service_t OutService, in IPS_Service_List_t ServiceMergeList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** get list of merged services from an output service.
     *
     * @param[in] OutService The service from which the merged services must be retrieved.
     * @param[out] ServiceMergeList A list of retrieved merged services.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid input references are used (RefPhys, OutService).
     */
    void IPS_OutServiceGetMergeL(in IPS_Service_t OutService, out IPS_MergedInServiceList_t ServiceMergeList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    typedef sequence<AlternateSrcId_t> AlternateSrcIdList_t;

    struct AltSrcMergedSetting_t
    {
      AlternateSrcId_t AlternateSrcId;
      IPS_MergedInServiceList_t MergedInServiceList;
    };

    /// A sequence of AlternateSvcMergedList_t elements
    typedef sequence<AltSrcMergedSetting_t> AltSrcMergedSettingList_t;

    /**
     * Add merged source settings to an output service.
     *
     * @param [in] SvcOut The SvcOut on which the settings should be applied
     * @param [in] AltSrcMergedSetting the settings
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case
     * - invalid input references are used (SvcOut)
     * - an AlternateSrcId does not exist
     * - an merged service is added twice to the same alternate source
     *
     * @note Existing merged services are untouched
     *
     * @version Release 7.1
     */
    void IPS_OutServiceAddMergeL_V2(in IPS_Service_t SvcOut, in AltSrcMergedSetting_t AltSrcMergedSetting)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** get list of merged services for a specific output service
     *
     * @param [in] SvcOut The SvcOut on which the settings are
     * @param [in] AlternateSrcIdList The IDs of the alternate sources for which settings are requested.
                   If empty, then settings of all services on the TS are returned.
     * @param [out] AltSrcMergedSetting the settings
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid input references are used (RefPhys, OutService).
     *
     * @version Release 7.1
     */
    void IPS_OutServiceGetMergeL_V2(in IPS_Service_t SvcOut, in AlternateSrcIdList_t AlternateSrcIdList, out AltSrcMergedSettingList_t AltSrcMergedSetting)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** remove list of merged services from output services.
     *
     * @param [in] SvcOut The SvcOut on which the settings should be applied
     * @param [in] AltSrcMergedSetting the settings that must be deleted
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case
     * - invalid input references are used (RefPhys, OutService, ServiceMergeList).
     * - not found merged in service in ServiceMergeList
     *
     * @note
     * - an empty AlternateSourceMergedList for an Output Service means delete all merged services for this Output Service
     *
     * @version Release 7.1
     */
    void IPS_OutServiceDelMergeL_V2(in IPS_Service_t SvcOut, in AltSrcMergedSetting_t AltSrcMergedSetting)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);




    /** Sets the list of merged component tracking criteria for an output service.
     * The MergeCriteriumList of the AlternateService/ServiceIn combinations present
     * in the ComponentMergeList will be updated with the new values. All MergeCriteriumLists
     * of AlternateService/ServiceIn combinations not present in the ComponentMergeList
     * stay unaffected
     *
     * @param[in] OutService : The service in which the input component(s) must 
     *                         be merged.
     * @param[in] ComponentMergeList : A list of input service component tracking
     *                         criteria.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case : 
     * - Invalid input references are used (RefPhys, OutService).
     * - Invalid reference (OutService).
     * - Trying to apply the same rule more than once.
     * - trying to set several MergeCriteriumLists for the same 
     *   AlternateService/ServiceIn combination
     *
     * @note
     * - The MergedComponents entry in the MergeCriterium_t is ignored in the Set call.
     * - An empty MergeCriteriumList for a AlternateService/Servicein combination in
     *   the ComponentMergeList will delete the component merge criteria for the specific ServiceIn.
     * - An empty ComponentMergeCriteriumList will delete all component merge tracking
     *   criteria for all AlternateService/ServiceIn combinations of the OutService.
     *
     * @version Release 7.1
     */
    void IPS_OutServiceSetComponentMergeL(in IPS_Service_t OutService,
                                          in ComponentMergeCriteriumList_t ComponentMergeList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Get a list of all merged component tracking criteria from an output service.
     *
     * @param[in] OutService : The service from which the merged component criteria
     *                         must be retrieved.
     * @param[out] ComponentMergeList :  A list of retrieved merged services.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid input references are used
     *                           (RefPhys, OutService).
     *
     * @version Release 7.1
     */
    void IPS_OutServiceGetComponentMergeL(in IPS_Service_t OutService,
                                          out ComponentMergeCriteriumList_t ComponentMergeList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);



    /** Gets matching output service for an input service and output TS
     * 
     * @param[in] OutputTS 
     * @param[in] InputService 
     * @param[out] OutputLookedUpService
     * 
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid input references are used (RefPhys, OutTS, Service).
     * @return OutputService 
     */
    void IPS_LookupOutService(in IPS_RefTS_t OutputTS, in IPS_Service_t InputService, out IPS_Service_t OutputLookedUpService)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
				
    typedef unsigned long SourceType_t; ///< bitmap : bit 0 means it is an alternate source
                                        ///<          bit 1 means it is a TS backup source
                                        ///<          bit 2 means it is a service backup source
                                        ///<          bit 3 means it is a merged service source
                                        ///<          bit 4 means it is a merged component source
                                        ///<          bit 5 means it is a LPI or Ad source
                                        ///<          bit 6 means it is an EBIF source
                                        ///<          no bits set means it is the main service that was routed

    typedef sequence< SourceType_t > IPS_Serv_Source_List_t; 

    struct IPS_Serv_Dest_t 
    { 
      IPS_Service_t OutputService; 
      IPS_Serv_Source_List_t SourceList; 
    }; 

    typedef sequence <IPS_Serv_Dest_t> IPS_Serv_Dest_List_t; 

    /** Find where a certain input service is routed to.
     *
     * @param[in] InputService: The IPS_Service_t of the source you want to find the destinations for
     *
     * @return IPS_Serv_Dest_List_t List if IPS_Serv_Dest_t entries
     *
     * @exception OperationFailed In case invalid input references are used.
     *
     * @note
     * - No wildcard support on the input service, you can only find the destinations of one input service. @n
     */
    IPS_Serv_Dest_List_t GetDestinations(in IPS_Service_t InputService) 
      raises (TimeOut, OperationFailed, OpNotAllowed, OpNotSupported);


    /** Retrieves for every service in the given list, if the BlockCA option is turned on.
     *
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the TS.
     * @param[in] OutputSidList A list of Service ID's to get info about.
     * 
     * @return List of ServiceBlockCAInfo_List_t entries
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid output references are used (RefTS, OutputSidList).
     */
    ServiceBlockCAInfo_List_t ServiceBlockCAInfoGetL(in IPS_RefTS_t RefTS, in ServiceIdList_t OutputSidList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Enables/disables blocking of CA info for a list of services
     *
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the TS.
     * @param[in] ServiceBlockCAInfoList A list of services and the option to set on each service
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid input references are used (RefTS, InputSidList).
     */
    void ServiceBlockCAInfoSetL(in IPS_RefTS_t RefTS, in ServiceBlockCAInfo_List_t ServiceBlockCAInfoList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set service details via a list on an output TS.
     *
     * @param[in] RefPhys BoardNr and PortNr specifying the port of the service.
     * @param[in] ServiceDataList A list of IPS_ServiceDataOut_List_V2_t. They uniquely identify
     * the output service and specify the ServiceOutProperty, FixedRemap, OutputSID and/or
     * UseOutputUserName, OutputUserName for each service.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid references are used (RefPhys, ServiceDataList).
     * @exception LicenseError in case of
     * - no licenses left
     * - already existing TS with same ONID/TSID has services with license
     *
     * @note
     * - Read/Write fields of ServiceOutProperty can be set via this call.
     * - Read only fields are ignored.
     * - OutputUserName change is specified via UseOutputUserName boolean.
     * - OutputSID change is specified via FixedRemap boolean.
     * - EIT output flag changes are specified via corresponding enum setting
     * -    EITschOut
     * -    EITpfOut
     * -    CAmodeOut     
     * -    RunStatusOut
     * -    ServiceType
     * - ServiceProviderNameOut change is specified via UseOutputServiceProviderName boolean.
     */
    void IPS_OutServiceSetL_V2(in IPS_Ref_t RefPhys, in IPS_ServiceDataOut_List_V2_t ServiceDataList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);
    
    /** Get the list of services on an output TS.
     *
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the TS. 
     * @param[in] OutputSidList A list of Service ID's to get info about.
     *
     * @return IPS_ServiceDataOut_List_V2_t List of IPS_ServiceData_Out_V2_t entries
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid output references are used (RefTS, OutputSidList).
     *
     * @note
     * - A value of 0xFFFFFFFF for Ref means get services on all TS's on a physical port. @n
     * - Also for DPI it will be necessary to set/get a separate user name. @n
     * - An empty OutputSidList list returns information about all services. @n
     * - SystemName will be the displayed name for the input service, the UserName field is not used and will be empty. @n
     * - If UseOutputUserName is unchecked, the SystemName will be the output SDT name. @n
     * - If UseOutputUserName is checked, OutputUserName will be the output SDT name. @n
     * - The SDT flags reflect the input SDT values (if present), and the other fields reflect the current settings. @n
     * - The SDT service provider name will be the input name unless UseOutputServiceProviderName is checked.
     */
    IPS_ServiceDataOut_List_V2_t IPS_OutServiceGetL_V2(in IPS_RefTS_t RefTS, in ServiceIdList_t OutputSidList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the list of services on an output TS.
     *
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the TS. 
     * @param[in] OutputSidList A list of Service ID's to get info about.
     *
     * @return IPS_ServiceDataOut_List_V3_t List of IPS_ServiceData_Out_V3_t entries
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid output references are used (RefTS, OutputSidList).
     *
     * @note
     * - A value of 0xFFFFFFFF for Ref means get services on all TS's on a physical port.
     * - Also for DPI it will be necessary to set/get a separate user name.
     * - An empty OutputSidList list returns information about all services.
     * - SystemName will be the displayed name for the input service, the UserName field is not used and will be empty.
     * - If UseOutputUserName is unchecked, the SystemName will be the output SDT name.
     * - If UseOutputUserName is checked, OutputUserName will be the output SDT name.
     * - The SDT flags reflect the input SDT values (if present), and the other fields reflect the current settings.
     * - The SDT service provider name will be the input name unless UseOutputServiceProviderName is checked.
     */
    IPS_ServiceDataOut_List_V3_t IPS_OutServiceGetL_V3(in IPS_RefTS_t RefTS, in ServiceIdList_t OutputSidList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /**
     * Get the list of services on a transcoder board.
     *
     * @param[in] BoardNr number of the transcoder board
     * @param[in] RefSvcList list of RefSvc of the transcoder board services for which to return the service data. For an empty list, data of all services are returned. The first time this function is called, the list should be empty in order to return all services. Afterwards, a list of RefSvc (first parameter of the returned TC_ServiceData_t structures) can be used to pass as second parameter of this function, in order to get the service data of a subset of services.
     *
     * @return TC_ServiceData_List_t List of TC_ServiceData_t entries
     *
     * @exception TimeOut A timeout occurred during IIOP processing
     * @exception OpNotSucceeded invalid references are used
     * @exception OpNotAllowed not logged in
     * @exception OpNotSupported if BoardNr is not the board number of a transcoder board
     *
     * @version Release 7.5
     *
     */
    TC_ServiceData_List_t TC_ServiceGetL(in unsigned short BoardNr, in IPS_RefSvc_List_t RefSvcList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /**
     * Set service details of transcoder board services.
     *
     * @param[in] BoardNr number of the transcoder board
     * @param[in] ServiceDataList list of TC_ServiceData_t specifying the service data details for modification.
     *
     * @exception TimeOut A timeout occurred during IIOP processing
     * @exception OpNotSucceeded invalid references are used or when trying to change User Tag of a PIP service
     * @exception OpNotAllowed not logged in
     * @exception OpNotSupported if BoardNr is not the board number of a transcoder board
     *
     * @version Release 7.5
     *
     */
    void TC_ServiceSetL(in unsigned short BoardNr, in TC_ServiceData_List_t ServiceDataList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /**
     * Add a list of services to a transcoder or MFP board and returns the output 
     * service data for those services.
     *
     * @param[in] BoardNr number of the board on which services are added
     * @param[in] InputRefSvcList list of RefSvc of the (IO board) input services
     *
     * @return TC_ServiceData_List_t List of TC_ServiceData_t entries containing info
     *                               of the passed services. Note: Service names might still be empty.
     *     
     * @exception TimeOut A timeout occurred during IIOP processing
     * @exception OpNotSucceeded
     * - invalid references are used
     * - If the limit of 16 services per transcoder board is exceeded
     * - If the limit of 128 services per MFP board is exceeded
     * @exception OpNotAllowed not logged in
     * @exception OpNotSupported if BoardNr is not the board number of a transcoder of MFP board
     *
     * @version Release 9.0
     *
     */
    TC_ServiceData_List_t ProcessorServiceAddL(in unsigned short BoardNr, in IPS_RefSvc_List_t InputRefSvcList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * Structure with service data for a transcoder board.
     * @version Release 11.10
     */
    struct TC_ServiceDataV2_t
    {
      IPS_RefSvc_t RefSvc;          ///< Read only : The RefSvc of this service, either main or PIP (PIP not supported in Version 7.01)
      IPS_RefSvc_t ParentRefSvc;    ///< Read only : The RefSvc of the main service. If RefSvc == ParentRefSvc, this is a main service. For PIP RefSvc <> ParentRefSvc.
      ServiceId_t SID;              ///< Read only : The SID of the service
      unsigned long TC_Property;    ///< Read only Bitmap used by GUI to display
                                    ///< Bit 0: Service present at input (true) or not (false).
                                    ///< Bit 4: at least one of the source input PIDs of this service is scrambled
                                    ///< Bit 5: TRUE if service is in backup
                                    ///< Bit 6: TRUE if Service Loss Alarm is active.
                                    ///< Bit 29: TRUE if service can't be deleted (e.g. because it's passed to an output)
                                    ///< Bit 30: TRUE if transcoding is enabled on one of the components of the Service
                                    ///<         TRUE if service on a MFP board is processing (transrating/transcoding) audio or video
                                    ///< Bit 31: TRUE if Service contains VBI (future) (same bit as in IPS_Service_In_t)
                                    ///   - Other bits for future use.
      IPS_Service_In_V2_t MainInputService;   ///< Read only : Reference to the main input service that was used to create the service
      IPS_Service_In_V2_t ActiveInputService; ///< Read only : can be different from main input service e.g. when service is in backup, ...
      DvbString_t         UserTag;            ///< Maximum string length 255 characters
                                              ///< For multires services this tag can be overwritten if settings change.
      boolean             bUseTagAsSvcName;   ///< True (default) use usertag as service name (will be inserted in the SDT). TODO exact behaviour 
                                              ///< Default false for main/pip services, default true for multires services.         
    };

    /// A sequence of TC_ServiceData_t entries.
    typedef sequence<TC_ServiceDataV2_t> TC_ServiceDataV2_List_t;

    /**
     * Get the list of services on a transcoder board.
     *
     * @param[in] BoardNr number of the transcoder board
     * @param[in] RefSvcList list of RefSvc of the transcoder board services for which to return the service data. For an empty list, data of all services are returned. The first time this function is called, the list should be empty in order to return all services. Afterwards, a list of RefSvc (first parameter of the returned TC_ServiceData_t structures) can be used to pass as second parameter of this function, in order to get the service data of a subset of services.
     *
     * @return TC_ServiceDataV2_List_t List of TC_ServiceData_t entries
     *
     * @exception TimeOut A timeout occurred during IIOP processing
     * @exception OpNotSucceeded invalid references are used
     * @exception OpNotAllowed not logged in
     * @exception OpNotSupported if BoardNr is not the board number of a transcoder board
     * @exception OperationFailed TODO
     *
     * @version Release 11.10
     *
     */
    TC_ServiceDataV2_List_t TC_ServiceGetLV2(in unsigned short BoardNr, in IPS_RefSvc_List_t RefSvcList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);


    /**
     * Set service details of transcoder board services.
     *
     * @param[in] BoardNr number of the transcoder board
     * @param[in] ServiceDataList list of TC_ServiceData_t specifying the service data details for modification.
     *
     * @exception TimeOut A timeout occurred during IIOP processing
     * @exception OpNotSucceeded invalid references are used or when trying to change User Tag of a PIP service
     * @exception OpNotAllowed not logged in
     * @exception OpNotSupported if BoardNr is not the board number of a transcoder board
     * @exception OperationFailed TODO
     *
     * @version Release 7.5
     *
     */
    void TC_ServiceSetLV2(in unsigned short BoardNr, in TC_ServiceDataV2_List_t ServiceDataList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);
        
    /**
     * Add a list of services to a transcoder board or MFP board
     *
     * @param[in] BoardNr number of the board on which services are added
     * @param[in] InputRefSvcList list of RefSvc of the (IO board) input services
     *
     * @exception TimeOut A timeout occurred during IIOP processing
     * @exception OpNotSucceeded
     * - invalid references are used
     * - If the limit of 16 services per transcoder board is exceeded
     * - If the limit of 128 services per MFP board is exceeded
     * @exception OpNotAllowed not logged in
     * @exception OpNotSupported if BoardNr is not the board number of a transcoder board
     *
     * @version Release 7.5
     *
     */
    void TC_ServiceAddL(in unsigned short BoardNr, in IPS_RefSvc_List_t InputRefSvcList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * Delete a list of services on a transcoder board. The service is only deleted if the service is not passed anymore to an IO board.
     *
     * @param[in] BoardNr the number of the transcoder board
     * @param[in] RefSvcList A list of services to delete.
     *
     * @exception OpNotSucceeded In case
     * - Invalid references are used (RefSvcList).
     * - Inconsistency between BoardNr & ServiceList[x].Ref.PhysRef.BoardNr.
     * - At least one of the services is passed to an IO board.
     * @exception OpNotAllowed not logged in
     * @exception OpNotSupported if BoardNr is not the board number of a transcoder board
     *
     * @version Release 7.5
     *
     */
    void TC_ServiceDeleteL(in unsigned short BoardNr, in IPS_RefSvc_List_t RefSvcList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /// @} end of group services
    
    /** @defgroup pids Pid
     * This contains types, enums and methods to configure the pid settings of the multiplexer part in the device.
     * @{
     */
    
    /** Undefined pid */
    const unsigned short INVALID_PID_VALUE=0xffff;
    /** Only for input parameters.
     *  If you want to specify all pids.
     */
    const unsigned short ANY_PID_VALUE=0xffff;

    /// Identification of which PID to be (un)blocked.
    struct InPID_Data_t
    {
      IPS_RefTS_t m_RefTS;        ///< The Slot, Port and Index of the input TS.
      unsigned short m_usPID;     /**< The reference to the input pid to be blocked 
                                       Is a service ES pid or EMM pid at TS level when
                                       m_ulOutputSID is INVALID_SID_VALUE.*/
      unsigned short m_usECM_PID; /**< Value of the ES ECMPID at the input TS
                                       when PID is valid or the ECM pid at service level.
                                       Will only be interpreted when different from INVALID_PID_VALUE.*/
    };

    /** Identification of the service(s) to (un)block PIDs in.
     * Will be replaced by ServiceCompSettings_t
     */
    struct ServicePIDStatus_t
    {
      ePIDPassingStatus m_ePID_Status; ///< The new passing status.
      unsigned long  m_ulOutputSID; /**< Output service ID value.
                                         Will be ignored if == INVALID_SID_VALUE.*/
      unsigned long  m_ulPCR;  /**< 1 means (un)block the PCR PID in this service 
                                * (other information will be ignored). 0 means that it's
                                * not the PCR PID to block. 
                                * @note It maybe necessary to use ePIDPassBlock_PID_Type
                                * but other types then PCR can be autodetected.*/
      InPID_Data_t   m_PidRef; ///< Reference to the input pid to be blocked.
    };
    
    /// A sequence of ServicePIDStatus_t.
    typedef sequence<ServicePIDStatus_t> ServicePIDStatus_List_t;

    struct ServiceCompSettings_t
    {
      unsigned long  m_ulOutputSID; ///< Output service ID value. Will be ignored if INVALID_SID_VALUE.
      unsigned long  m_ulPCR;  /**< 1 means (un)block the PCR PID in this service 
                                * (other information will be ignored). 0 means that it's
                                * not the PCR PID to block. 
                                * @note It maybe necessary to use ePIDPassBlock_PID_Type
                                * but other types than PCR can be autodetected.*/      
      InPID_Data_t   m_PidRef; ///< Reference to the input pid to be blocked.
      ePIDPassingStatus m_ePID_Status; ///< The new passing status.
      unsigned short m_usOutputPid;
      boolean m_bForced;
      boolean m_bTracked;
      unsigned long m_ulTrackRuleID;
    };
 
    /// A sequence of ServiceCompSettings_t.
    typedef sequence<ServiceCompSettings_t> ServiceCompSettingsList_t;
    
    struct ComponentTag_t
    {
      IPS_RefTS_t m_RefTsOut;        ///< The Slot, Port and Index.
      unsigned long m_ulOutputSid;
      unsigned short m_usOutputPid;
      octet m_ocComponentTag;
    };
    
    /// A sequence of ComponentTag_t.
    typedef sequence<ComponentTag_t> ComponentTagList_t;
    
    /// What information of a PID we're tracking.
    enum enuTrackType
    {
      eTrackComponentTag,
      eTrackPcr,
      eTrackStreamType,
      eTrackEsPid,    ///< m_usInputPid <> INVALID_PID_VALUE, m_usInputECM_PID == INVALID_PID_VALUE.
      eTrackEcmPid,   ///< m_usInputECM_PID <> INVALID_PID_VALUE, m_usInputPid == INVALID_PID_VALUE.
      eTrackEsEcmPid  ///< m_usInputECM_PID <> INVALID_PID_VALUE, m_usInputPid <> INVALID_PID_VALUE.
    };
    
    /// What the intention of a rule can be.
    enum enuRuleSetting
    {
      eRuleBlock,
      eRuleForce,
      eRulePass ///< Supported since v5.1. 
    };    
   
    struct ComponentTrackRule_t
    {
      unsigned long       m_ulID;
      IPS_Service_t       m_Service;          ///< Sid can be INVALID_SID_VALUE in case of a TS PID.
      enuTrackType        m_eTrackType;
      octet               m_ocComponentTag;   ///< valid if component tag tracking
      octet               m_ocStreamType;     ///< valid if stream type tracking
      string              m_strLanguage;      ///< valid if stream type tracking and audio streamtype
      unsigned long       m_ulDescriptorTag;  ///< 0x56 for teletext descriptor
      unsigned short      m_usInputPid;       ///< valid is pid tracking (ES, ECM and ES-ECM: always THE input pid)
      unsigned short      m_usEsPreferredOutputPid;   ///< valid if pid tracking for ECM pid: parent must exist.
      unsigned short      m_usPreferredOutputPid;
      enuRuleSetting      m_eRuleSetting;
    };
    
    /// A sequence of ComponentTrackRule_t.
    typedef sequence<ComponentTrackRule_t> ComponentTrackRuleList_t;
    
    struct ComponentTrackRule_V2_t
    {
      unsigned long       m_ulID;
      IPS_Service_t       m_Service;          ///< Sid can be INVALID_SID_VALUE in case of a TS PID.
      TrackingCriterium_t m_TrackCriterium;
      unsigned short      m_usPreferredOutputPid;
      enuRuleSetting      m_eRuleSetting;
    };
    
    /// A sequence of ComponentTrackRule_V2_t.
    typedef sequence<ComponentTrackRule_V2_t> ComponentTrackRuleList_V2_t;

    /// What the intention of a rule can be.
    enum enuDefaultRuleSetting
    {
      eDefaultRuleBlock,
      eDefaultRuleForce,
      eDefaultRulePass
    };    
   
    /** Structure for board default component tracking rules.
     * This is a first version, development both embedded and at the GUI side may change this.
     */
    struct DefaultTrackRule_t
    {
      unsigned long         m_ulID;
      enuTrackType          m_eTrackType;
      octet                 m_ocComponentTag;   ///< valid if component tag tracking
      octet                 m_ocStreamType;     ///< valid if stream type tracking
      string                m_strLanguage;      ///< valid if stream type tracking and audio streamtype
      unsigned long         m_ulDescriptorTag;  ///< 0x56 for teletext descriptor
      unsigned short        m_usInputPid;       ///< valid is pid tracking (ES, ECM and ES-ECM: always THE input pid)
      unsigned short        m_usEsPreferredOutputPid;   ///< valid if pid tracking for ECM pid: parent must exist.
      unsigned short        m_usPreferredOutputPid;
      enuDefaultRuleSetting m_eRuleSetting;
    };

    /// A sequence of DefaultTrackRule_t.
    typedef sequence<DefaultTrackRule_t> DefaultTrackRuleList_t;

    struct ES_TypeSetting_t
    {
        unsigned short      OutputPid;
        octet               ES_Type;
    };

    typedef sequence<ES_TypeSetting_t> ES_TypeSettingList_t;

    struct SvcOutES_TypeSetting_t
    {
        IPS_Service_t         RefServ;
        ES_TypeSettingList_t  ES_TypeSettingList;
    };

    typedef sequence< SvcOutES_TypeSetting_t> SvcOutES_TypeSettingList_t;

    struct ServiceES_t
    {
      unsigned long OutputSID;
      IPS_RefTS_t RefTSIn;
      unsigned long InputSID;
      long OldPID;
    };
  
    /// A sequence of ServiceES_t.
    typedef sequence<ServiceES_t> ServiceES_List_t;

    struct IPS_LanguageSettings_t
    {
      string LanguageCode; ///< ISO_639_language_code 
        octet AudioType;
    };
    
    /// A sequence of IPS_LanguageSettings_t.
    typedef sequence<IPS_LanguageSettings_t> LanguageList_t;

    struct IPS_Out_PIDSettings_t
    {
       IPS_RefTS_t RefIn;       ///< The location (slot, port) and stream.
       unsigned long InputSID;  ///< Input Service ID. (Not used : always 0 now)
       unsigned short OldPID;   ///< Value of the PID at the input TS.
       unsigned short NewPID;   ///< New output PID value: 0xFFFF means unassigned.
       boolean FixedPIDRemap;   ///< If Output PID is fixed, this variable is true.
       ePIDPassingStatus PIDStatus;         ///< Measurement, can be different from setting.
       ePIDPassingStatus PIDSetting;        /**< Set by user, can only be ePID_StatusBlockedByUser or ePID_StatusPassed.
                                            Is changed through the IPS_PassBlockPids IDL call.*/
       unsigned long PID_Property;          ///< Read only Bitmap used by GUI to display specific icons
                                            ///< Bit 0: PID present in input TS or not
                                            ///<        TRUE means present
                                            ///<        FALSE: PID not present
                                            ///<        Remark: present or not present is based on SI
                                            ///< Bit 1: Service scrambled by %DCM
                                            ///<        TRUE means scrambled by %DCM 
                                            ///<        FALSE means not scrambled by %DCM
                                            ///< Bit 2: PID descrambled by %DCM (TRUE = descrambled)
                                            ///< Bit 3: PID is not correctly descrambled (when descrambled by DCM)
                                            ///<        TRUE means that not descrambled alarm is active
                                            ///< Bit 4: PID is scrambled at input
                                            ///<        TRUE means scrambled at input
//     char InputPresent;       
       // replaced by bit 0 in PID_Property (IPS_Out_ESSettings_t)
    };

    struct IPS_Out_ECMSettings_t
    {
      long CASystemID;                   ///< To which CA system does the ECM belong.
      string ECM_Info;                   ///< Additional info for ECM (AC, ...)
      IPS_Out_PIDSettings_t ECM_PID;     ///< Setting of an individual ECM PID.
    };

    /// A sequence of IPS_Out_ECMSettings_t.
    typedef sequence<IPS_Out_ECMSettings_t> IPS_Out_ECMSettingsTree_t;
    
    struct IPS_Out_ESSettings_t
    {
      IPS_Out_PIDSettings_t ES_PID;
      octet ES_Type;                            ///< dvb streamtype.   
      string strEsType; ///< Interpretation of Es_Type in regard to m_EsTypeStandard of the output TS. Read only.
      IPS_Out_ECMSettingsTree_t ES_ECMSettings; ///< Settings for each ES ECM PID.
      LanguageList_t ES_Languages;              ///< Language descriptors: will be 0 in first version.
    };

    /// A sequence of IPS_Out_ESSettings_t.
    typedef sequence<IPS_Out_ESSettings_t> IPS_Out_ESSettingsTree_t;

    struct IPS_Out_ServiceComponents_t
    {
      IPS_RefTS_t Ref_Out;
      unsigned long OutputSID;
      IPS_Out_PIDSettings_t PMT_PID;
      IPS_Out_PIDSettings_t PCR_PID;
      IPS_Out_ECMSettingsTree_t ECM_Info;
      IPS_Out_ESSettingsTree_t ES_Info;     ///< Contains a list of ECM_Info.
    };

    /// A sequence of.IPS_Out_ServiceComponents_t.
    typedef sequence<IPS_Out_ServiceComponents_t> IPS_Out_ServiceComponents_List_t;

    ///< Intermediate structure definition for V6.9/V7.0. Will still be changed in V7.1 where output language list will be added.
    struct IPS_Out_ESSettings_V2_t
    {
      IPS_Out_PIDSettings_t ES_PID;
      octet SrcES_Type;                            ///< dvb streamtype of the source of the output TS.   
      string strSrcES_Type; ///< Interpretation of Es_Type in regard to m_EsTypeStandard of the source of the output TS. Read only.
      octet OutES_Type;                            ///< dvb streamtype of the output TS.
      string strOutES_Type; ///< Interpretation of Es_Type in regard to m_EsTypeStandard of the output TS. Read only.

      IPS_Out_ECMSettingsTree_t ES_ECMSettings; ///< Settings for each ES ECM PID.
      LanguageList_t ES_Languages;              
    };

    /// A sequence of IPS_Out_ESSettings_V2_t.
    typedef sequence<IPS_Out_ESSettings_V2_t> IPS_Out_ESSettingsTree_V2_t;

    struct IPS_Out_ServiceComponents_V2_t
    {
      IPS_RefTS_t Ref_Out;
      unsigned long OutputSID;
      IPS_Out_PIDSettings_t PMT_PID;
      IPS_Out_PIDSettings_t PCR_PID;
      IPS_Out_ECMSettingsTree_t ECM_Info;
      IPS_Out_ESSettingsTree_V2_t ES_Info;     ///< Contains a list of ECM_Info.
    };

    /// A sequence of.IPS_Out_ServiceComponents_V2_t.
    typedef sequence<IPS_Out_ServiceComponents_V2_t> IPS_Out_ServiceComponents_List_V2_t;
    
    struct PcrSetting_t
    {
      AlternateSrcId_t AlternateSrcId; ///< Identifies the alternate service for a specific output service
      IPS_RefPid_t     InputPidRef;    ///< If Board, Port and TS Reference are invalid (0xFFFFFFFF),
                                       ///< this meanse it's a "dummy" PCR.  Input PID value is used as
                                       ///< preferred output PID value.  When set to INVALID_PID_VALUE
                                       ///< this means that the PCR will be removed
    };
    typedef sequence<PcrSetting_t> PcrSettingList_t;

    struct IPS_In_ECMSettings_t
    {
      long CASystemID;          ///< To which CA system does the ECM belong.
      unsigned short ECM_PID;   ///< Setting of an individual ECM PID.
    };

    /// A sequence of IPS_In_ECMSettings_t.
    typedef sequence<IPS_In_ECMSettings_t> IPS_In_ECMSettingsTree_t;

    struct IPS_In_ESSettings_t
    {
        unsigned short ES_PID;
        octet ESType;                             ///< Dvb stream type.   
        string strEsType; ///< Interpretation of EsType in regard to m_EsTypeStandard of  the input TS. Read only.
        IPS_In_ECMSettingsTree_t ES_ECMSettings;  ///< Settings for each ES ECM PID.
        LanguageList_t ES_Languages;              ///< Language descriptors: will be zero in first version.
        unsigned long PID_Property;               ///< Read only Bitmap used by GUI to display specific icons
                                                  ///< Bit 0: PID present in input TS or not
                                                  ///<        TRUE means present
                                                  ///<        FALSE: PID not present
                                                  ///<        Remark: present or not present is based on SI
                                                  ///< Bit 4: PID scrambled at input
                                                  ///< @todo To be implemented
    };

    /// A sequence of IPS_In_ESSettings_t.
    typedef sequence<IPS_In_ESSettings_t> IPS_In_ESSettingsTree_t;

    struct IPS_In_ServiceComponents_t
    {
      IPS_RefTS_t Ref_In;
      unsigned long InputSID;
      unsigned short PMT_PID;
      unsigned short PCR_PID;
      IPS_In_ECMSettingsTree_t ECM_Info;
      IPS_In_ESSettingsTree_t ES_Info;    ///< Contains a list of ECM_Info.
    };
    
    /// A sequence of IPS_In_ServiceComponents_t.
    typedef sequence<IPS_In_ServiceComponents_t> IPS_In_ServiceComponents_List_t;
    
    struct TableGenerationData_t
    {
      TableKeys_t         OutKeys;         ///< Keys to locate the output table
      unsigned short      OutPid;          /**< Pid on which the output table should be played out
                                            * PMT Pid range: 0x0020 .. 0x1FFE
                                            * PAT-SDT Pid range: 0x0000 .. 0x1FFE
                                            */
      boolean             ForcedOutputPid; ///< Indicates if the output pid should be forced or not (=0)
      ePIDPassingStatus GenerationMode;  ///< Specifies what should happen wiht the output table
      IPS_RefTS_t         InRefTs;         /**< Slot, port and index of the input TS where the table to be
                                            * be used can be found. Should be set to invalid when the input
                                            * table has to be retrieved from local disk.
                                            */
      TableKeys_t         InKeys;           ///< Keys to locate the desired input table.
      unsigned short      InPid;            /**< Pid on which the specified input table should be found.
                                             * Set to INVALID_PID_VALUE for an imported table.
                                             */
    };
    
    /// A sequence of TableGenerationData_t.
    typedef sequence<TableGenerationData_t> TableGenerationDataList_t;
    
    struct TableGenerationData_V2_t
    {
      TableKeys_t          OutKeys;         ///< Keys to locate the output table
      unsigned short       OutPid;          /**< Pid on which the output table should be played out
                                             * PMT Pid range: 0x0020 .. 0x1FFE
                                             * PAT-SDT Pid range: 0x0000 .. 0x1FFE
                                             */
      boolean              ForcedOutputPid; ///< Indicates if the output pid should be forced or not (=0)
      ePIDPassingStatus_V2 GenerationMode;  ///< Specifies what should happen wiht the output table
      IPS_RefTS_t          InRefTs;         /**< Slot, port and index of the input TS where the table to be
                                             * be used can be found. Should be set to invalid when the input
                                             * table has to be retrieved from local disk.
                                             */
      TableKeys_t          InKeys;           ///< Keys to locate the desired input table.
      unsigned short       InPid;            /**< Pid on which the specified input table should be found.
                                              * Set to INVALID_PID_VALUE for an imported table.
                                              */
    };
    
    /// A sequence of TableGenerationData_t.
    typedef sequence<TableGenerationData_V2_t> TableGenerationDataList_V2_t;
    
    struct SvcOutStreamingSetting_t
    {
      IPS_Service_t RefServ;
      boolean       StreamingState; // true means enabled
    };
    
    /// A sequence of SvcStreamingState_t
    typedef sequence<SvcOutStreamingSetting_t> SvcOutStreamingSettingList_t;
    
    /** Set Output Service streaming state
     * 
     * @param[in] RefTs                      The Output TS the services are attached to.
     * @param[in] SvcOutStreamingSettingList List with settings to apply
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of
     * - RefTs does not exist.
     * - an empty list is passed.
     * - a ServiceId is not found in the TS.
     * - a RefSvc doesn't match RefTS     
     *
     * @version Release 7.0
     */       
    void SetSvcOutStreaming(in IPS_RefTS_t RefTs, in SvcOutStreamingSettingList_t SvcOutStreamingSettingList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);      
    
    /** Get Output Service streaming state
     * 
     * @param[in] RefTs    The Output TS the services are attached to.
     * @param[in] SidList  List of Services to return the service streaming
     *                     settings of.
     * @return    SvcOutStreamingSettingList_t  
     * 
     * @exception  OpNotSupported when BoardNr = 0 = Main board.
     * @exception  OpNotSucceeded In case the
     * - RefTs not valid or does not exist.
     * - no ServiceId's found for in the TS.
     *
     * @version Release 7.0
     */      
    SvcOutStreamingSettingList_t GetSvcOutStreaming(in IPS_RefTS_t RefTs, in ServiceIdList_t SidList)
       raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the board default output service streaming state.
     * 
     * @param[in] BoardNr        The Output TS the services are attached to.
     * @param[in] StreamingState The default service streaming state setting.
     * 
     * @exception  OpNotSupported when BoardNr = 0 = Main board.
     *
     * @version Release 7.0
     */             
    void SetDefaultSvcOutStreaming(in unsigned short BoardNr, in boolean StreamingState)
       raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get board default output service streaming state.
     * 
     * @param[in] BoardNr  The board the default is requested of.
     * @return    boolean  The default service streaming state setting.
     * 
     * @exception  OpNotSupported when BoardNr = 0 = Main board.
     *
     * @version Release 7.0
     */       
    boolean GetDefaultSvcOutStreaming(in unsigned short BoardNr)
       raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    // Pid IDLs
    // ------------------------------------------------------------------------------------
    
    
    /** Get a list of service components for services on given port and TS.
     *
     * @param[in] RefTS: The port and TS MUST exist and must be for output.
     * @param[in] OutputSidList List of services for which to return PID info. An empty list means all sevices.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid references are used (RefTS, OutputSidList).
     */
    IPS_Out_ServiceComponents_List_t IPS_OutSvcGetPIDsL(in IPS_RefTS_t RefTS, in ServiceIdList_t OutputSidList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Get a list of service components for services on given port and TS.
     *
     * @param[in] RefTS: The port and TS MUST exist and must be for output.
     * @param[in] OutputSidList List of services for which to return PID info. An empty list means all sevices.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid references are used (RefTS, OutputSidList).
     */
    IPS_Out_ServiceComponents_List_V2_t IPS_OutSvcGetPIDsL_V2(in IPS_RefTS_t RefTS, in ServiceIdList_t OutputSidList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get a list of service components for services on given port and TS.
     *
     * @param[in] RefTS: The port and TS MUST exist and must be for input.
     * @param[in] InputSidList List of services for which to return PID info. An Empty list means all services.
     *
     * @return A IPS_In_ServiceComponents_List_t list of IPS_In_ServiceComponents_t entries.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid references are used (RefTS, InputSidList).
     */ 
    IPS_In_ServiceComponents_List_t IPS_InSvcGetPIDsL(in IPS_RefTS_t RefTS, in ServiceIdList_t InputSidList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
  
    /** Block or unblock pids in a list of services on an output TS.
     *
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the TS. 
     * @param[in] ServicePIDStatusList  A list of references to specific service PIDs together with pass or block status
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case an invalid TS reference is used, when the new status is not in
     * the range (ePID_StatusBlockedByUser, ePID_StatusPassed) or when a PID can not be found.
     */
    void IPS_PassBlockPids(in IPS_RefTS_t RefTS, in ServicePIDStatus_List_t ServicePIDStatusList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Change the automatic regeneration of a certain SI table so that it can be passed transparently 
     * or "alternatively" regenerated from a non-default input or from local disk (table imported over 
     * ethernet). Also the output pid, on which an SI subtable should be played out, can be set.
     *
     * @param[in] OutRefTS Slot, Port and Index identifying the output TS
     * @param[in] TableSettings: list of output table settings
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded when any of the following conditions occur.
     * - Invalid refences (OutRefTS, OutKeys)
     * - One of the parameters is out of range (Outpid, ForcedOutputPid, GenerationMode).
     * - One of the tables to change can not be found.
     * - Force a generated SI PID to a transparent SI PID
     * - Force a generated SI PID to a ghost PID
     * - Force a generated SI PID to a forced service PID
     * - Force a transparent SI PID to a forced SI PID
     * - Force a transparent SI PID to a transparent SI PID and input pid reference is different from output pid
     * - Force a transparent SI PID to a ghost PID
     * - Force a transparent SI PID to a forced service PID
     * - Release 1.1 only allowed the regenerated mode, playout stopped and transparent
     *   mode as table generation modes.
     * @exception LicenseError When trying to activate EIT Filtering or Advanced EIT Filtering
     *                         when insufficient licenses are available.
     *
     * @note Input table settings are ignored in release 1.1. Release 2.0 fully supports all features.
     * @note Transparent is always forced even if the user specifies otherwise. The opposite goes for
     * stopped where the force flag is always assumed to be false. 
     */
    void SetSI_Generation(in IPS_RefTS_t OutRefTS, in TableGenerationDataList_t TableSettings)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);

    /** (Deprecated) Returns a list of all output table settings.
     *  This list is filtered: It contains only tables which have a mode that
     *  is compatible with the old version of the PID status enum.
     *  For backwards compatibility only.
     *
     * @param[in] OutRefTS Slot, Port and Index identifying the output TS
     * @param[out] TableSettings: list of output table settings
     *
     * @return Requested table settings.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of invalid reference (OutRefTS)
     * @deprecated
     */
    void GetSI_Generation(in IPS_RefTS_t OutRefTS, out TableGenerationDataList_t TableSettings)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Returns a list of all output table settings.
     *
     * @param[in] OutRefTS Slot, Port and Index identifying the output TS
     * @param[out] TableSettings: list of output table settings
     *
     * @return Requested table settings.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of invalid reference (OutRefTS)
     */
    void GetSI_Generation_V2(in IPS_RefTS_t OutRefTS, out TableGenerationDataList_V2_t TableSettings)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Get a (filtered) set of default component tracking rules for given TS.
     *
     * @param[in] BoardNr The slot.
     * @param[in] RuleIds The IDs of the rules to get or an empty list for all rules. 
     * @param[out] theList of current rules.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of invalid reference (OutRefTS).
     * @remark There's no validity check on the filter list, ID's that don't exist will simply not be found. 
     */
    void GetDefaultCompTrackRuleL(in unsigned short BoardNr, in LongStream RuleIds, out DefaultTrackRuleList_t theList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Update set of default component tracking rules for given board.
     * 
     * @param[in] BoardNr The slot.
     * @param[in] theList The rules to apply (new rules have ID==0 existing rules don't).
     * @param[in] IDsOfRulesToDelete The ID's of the rules to drop.
     * 
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of 
     * - Inconsistent rules (either in the list supplied or in combination with the current settings of the device).
     * - If ruleID <> 0 but rule does not exist. (modification of existing rule).
     * - New rule for a perfect match (PCR, ES, ECM or ES ECM) that already has a rule.
     * - Tracking type, rule setting, pid value out of range.
     * - Streamtype tracking combined with both a language and a descripor tag.
     * - Trying to apply the same rule twice.
     * - Trying to force two components with the same tracking type to the same ouput PID.
     * - Trying to force or block the same component twice (PCR, Tag, Streamtype, ES, ECM).
     * - Trying to force AND block the same component.
     * - Trying to force two ES ECM's under the same ES Pid to the same preferred output pid.
     * - Trying to block an ES ECM under an ES PID that is blocked.
     */
    void SetDefaultCompTrackRuleL(in unsigned short BoardNr, in DefaultTrackRuleList_t theList, in LongStream IDsOfRulesToDelete)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the current set of component tracking rules for given TS.
     *
     * @param[in] OutRefTS The TS.
     * @param[out] theList of current rules.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of invalid reference (OutRefTS).
     */
    void IPS_OutGetComponentTrackRuleL(in IPS_RefTS_t OutRefTS, out ComponentTrackRuleList_t theList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Get a filtered set of component tracking rules for given TS.
     *
     * @param[in] OutRefTS The TS.
     * @param[in] RuleIds The IDs of the rules to get or an empty list for all rules. 
     * @param[out] theList of current rules.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of invalid reference (OutRefTS).
     * @remark There's no validity check on the filter list, ID's that don't exist will simply not be found. 
     */
    void IPS_OutGetCompTrackRuleL_Filt(in IPS_RefTS_t OutRefTS, in LongStream RuleIds, out ComponentTrackRuleList_t theList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Update set of component tracking rules for given TS.
     * 
     * @param[in] OutRefTS The TS.
     * @param[in] theList The rules to apply (new rules have ID==0 existing rules don't).
     * @param[in] IDsOfRulesToDelete The ID's of the rules to drop.
     * 
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of 
     * - Invalid reference (OutRefTS).
     * - Inconsistent rules (either in the list supplied or in combination with the current settings of the device).
     * - If ruleID <> 0 but rule does not exist. (modification of existing rule).
     * - New rule for a perfect match (PCR, ES, ECM or ES ECM) that already has a rule.
     * - Service ID to apply rule to not found.
     * - Tracking type, rule setting, pid value out of range.
     * - Streamtype tracking combined with both a language and a descripor tag.
     * - Trying to apply the same rule twice.
     * - Trying to force two components with the same tracking type to the same ouput PID.
     * - Trying to force or block the same component twice (PCR, Tag, Streamtype, ES, ECM).
     * - Trying to force AND block the same component.
     * - Trying to force two ES ECM's under the same ES Pid to the same preferred output pid.
     * - Trying to block an ES ECM under an ES PID that is blocked.
     */
    void IPS_OutSetComponentTrackRuleL(in IPS_RefTS_t OutRefTS, in ComponentTrackRuleList_t theList, in LongStream IDsOfRulesToDelete)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the current set of component tracking rules for given TS.
     *
     * @param[in] OutRefTS The TS.
     * @param[out] theList of current rules.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of invalid reference (OutRefTS).
     *
     * @version Release 7.3
     */
    void IPS_OutGetComponentTrackRuleL_V2(in IPS_RefTS_t OutRefTS, out ComponentTrackRuleList_V2_t theList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Get a filtered set of component tracking rules for given TS.
     *
     * @param[in] OutRefTS The TS.
     * @param[in] RuleIds The IDs of the rules to get or an empty list for all rules. 
     * @param[out] theList of current rules.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of invalid reference (OutRefTS).
     * @remark There's no validity check on the filter list, ID's that don't exist will simply not be found. 
     *
     * @version Release 7.3
     */
    void IPS_OutGetCompTrackRuleL_Filt_V2(in IPS_RefTS_t OutRefTS, in LongStream RuleIds, out ComponentTrackRuleList_V2_t theList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Update set of component tracking rules for given TS.
     * 
     * @param[in] OutRefTS The TS.
     * @param[in] theList The rules to apply (new rules have ID==0 existing rules don't).
     * @param[in] IDsOfRulesToDelete The ID's of the rules to drop.
     * 
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of 
     * - Invalid reference (OutRefTS).
     * - Inconsistent rules (either in the list supplied or in combination with the current settings of the device).
     * - If ruleID <> 0 but rule does not exist. (modification of existing rule).
     * - New rule for a perfect match (PCR, ES, ECM or ES ECM) that already has a rule.
     * - Service ID to apply rule to not found.
     * - Tracking type, rule setting, pid value out of range.
     * - Streamtype tracking combined with both a language and a descripor tag.
     * - Trying to apply the same rule twice.
     * - Trying to force two components with the same tracking type to the same ouput PID.
     * - Trying to force or block the same component twice (PCR, Tag, Streamtype, ES, ECM).
     * - Trying to force AND block the same component.
     * - Trying to force two ES ECM's under the same ES Pid to the same preferred output pid.
     * - Trying to block an ES ECM under an ES PID that is blocked.
     *
     * @version Release 7.3
     */
    void IPS_OutSetComponentTrackRuleL_V2(in IPS_RefTS_t OutRefTS, in ComponentTrackRuleList_V2_t theList, in LongStream IDsOfRulesToDelete)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the list of service component settings for given TS.
     *
     * @param[in] RefTS The TS.
     * @param[out] ServiceCompSettingsList The list of current settings.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of invalid reference (RefTS).
     */
    void IPS_ServiceCompSettingsGetL(in IPS_RefTS_t RefTS, out ServiceCompSettingsList_t ServiceCompSettingsList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the list of components (pids) and their tag.
     *
     * @param[in] RefTS The TS.
     * @param[out] ComponentTagList The list of tags.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of invalid reference (RefTS).
     *
     * @note For now, only components having a tag are returned (descriptior Type == LB_STREAM_IDENTIFIER_DESCRIPTOR).
     */
    void IPS_OutSvcGetComponentTagL(in IPS_RefTS_t RefTS,  out ComponentTagList_t ComponentTagList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);        
        
    /** Add a list of pid components to output service(s).
     *
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the output TS to add components to.
     * @param[in] CompPidESList A list of components to add specifying input BoardNr, PortNr, Ref, PID
     *        and output SID and output streamtype.
     *
     * @exception OpNotSupported when RefTS BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of
     * - Invalid reference RefTS (BoardNr, PortNr and TS)
     * - Non existing TS or not an output TS
     * - Service(s) in CompPidESList don't exist
     */
    void OutService_AddESFromPidL(in IPS_RefTS_t RefTS, in CompPidESList_t CompPidESList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
 
    /** Delete a list of pid components from output service(s).
     *
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the output TS to delete components from.
     * @param[in] CompPidESList A list of components to delete specifying input BoardNr, PortNr, Ref, PID.
     *
     * @exception OpNotSupported when RefTS BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of
     * - Invalid reference RefTS (BoardNr, PortNr and TS)
     * - Non existing TS or not an output TS
     * - Service(s) in CompPidESList don't exist
     *
     * @note CompPidES.streamtype is ignored
     */
    void OutService_DeleteESFromPidL(in IPS_RefTS_t RefTS, in CompPidESList_t CompPidESList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
 
    /** Get a list of pid components from output service(s).
     *
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the output TS to get components from.
     * @param[out] CompPidESList
     *
     * @return CompPidESList A list of components on the output TS service(s).
     *
     * @exception OpNotSupported when RefTS BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of
     * - Invalid reference RefTS (BoardNr, PortNr and TS)
     * - Non existing TS or not an output TS
     */
    void OutService_GetESFromPidL(in IPS_RefTS_t RefTS, out CompPidESList_t CompPidESList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Add a list of pid components to output service(s) V2.
     *
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the output TS to add components to.
     * @param[in] CompPidESList A list of components to add specifying input BoardNr, PortNr, Ref, PID
     *        and output SID and output streamtype.
     *
     * @exception OpNotSupported when RefTS BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of
     * - Invalid reference RefTS (BoardNr, PortNr and TS)
     * - Non existing TS or not an output TS
     * - Service(s) in CompPidESList don't exist
     *
     * @version release 6.9     
     */
    void OutService_AddESFromPidL_V2(in IPS_RefTS_t RefTS, in CompPidESList_V2_t CompPidESList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
 
    /** Delete a list of pid components from output service(s) V2.
     *
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the output TS to delete components from.
     * @param[in] CompPidESList A list of components to delete specifying input BoardNr, PortNr, Ref, PID.
     *
     * @exception OpNotSupported when RefTS BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of
     * - Invalid reference RefTS (BoardNr, PortNr and TS)
     * - Non existing TS or not an output TS
     * - Service(s) in CompPidESList don't exist
     *
     * @note CompPidES.streamtype is ignored
     *
     * @version release 6.9     
     */
    void OutService_DeleteESFromPidL_V2(in IPS_RefTS_t RefTS, in CompPidESList_V2_t CompPidESList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
 
    /** Get a list of pid components from output service(s) V2.
     *
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the output TS to get components from.
     * @param[out] CompPidESList
     *
     * @return CompPidESList A list of components on the output TS service(s).
     *
     * @exception OpNotSupported when RefTS BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of
     * - Invalid reference RefTS (BoardNr, PortNr and TS)
     * - Non existing TS or not an output TS
     *
     * @version release 6.9     
     */
    void OutService_GetESFromPidL_V2(in IPS_RefTS_t RefTS, out CompPidESList_V2_t CompPidESList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);



   /** Set the ES type for a number of output PIDs for a number of services.
     * A list provided for a certain output service, replaces the previous list completely.
     * This means when an empty list is provided for an output service any existing 
     * ES type settings for that service will be deleted.
     * Each PID can be included only once per service.
     *
     * @param[in] RefTS specifies the output TS on which streamtypes will have to be remapped.
     * @param[in] SvcOutES_TypeSettingList  : List of SvcOutES_TypeSetting_t entries
     *
     * @exception OpNotSupported When called for other boards than IO ones (Main,...).
     * @exception OpNotSucceeded In case of
     * 			- Invalid references (RefTS)
     *                             - PID is not unique for a service
     *
     * @version Release 6.9
     */
    void SetES_TypeRules(in IPS_RefTS_t RefTS, in  SvcOutES_TypeSettingList_t SvcOutES_TypeSettingList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


  /**  Retrieves the ES type settings for a list of services.
     *
     * @param[in] RefTS specifies the TS where we want to get the ES type settings from.
     * @param[in] OutputSidList : list of output service ids for which the ES type
     *                                             settings should be returned.
     *
     * @return SvcOutES_TypeSettingList_t  : List of SvcOutES_TypeSetting_t entries
     *
     * @exception OpNotSupported When called for other boards than IO ones (Main,...).
     * @exception OpNotSucceeded In case of
     * 			- Invalid references (RefTS)
     *
     * @version Release 6.9
     */
    SvcOutES_TypeSettingList_t GetES_TypeRules(in IPS_RefTS_t RefTS, in ServiceIdList_t OutputSidList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
       
  /**  Sets the PCR PID for a (virtual) output service.
     *
     * @param[in] ServiceOut  Identifies the ouput service where the PCR should be added.
     * @param[in] PcrSettings A sequence of PCR settings for number of alternate sources. 
     *
     * @return
     *
     * @exception OpNotSupported When called for other boards than IO ones (Main,...).
     * @exception OpNotSucceeded In case of
     *      - Invalid references (IPS_RefSvc_t)
     *      - Invalid settings (PcrSettingList_t)
     *
     * @version Release 7.5
     */        
    void SetPcrPids(in IPS_RefSvc_t ServiceOut, in PcrSettingList_t PcrSettings)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
  /**  Gets the PCR PID settings from a (virtual) output service.
     *
     * @param[in] ServiceOut  Identifies the output service to get the PCR settings from.
     * @param[in] AlternateSrcIdList The IDs of the alternate sources for which settings are requested.
     *            If empty, then the settings of all alternate services for the output service are returned
     *
     * @return List PcrSetting_t of entries
     *
     * @exception OpNotSupported When called for other boards than IO ones (Main,...).
     * @exception OpNotSucceeded In case of
     *      - Invalid references (IPS_RefSvc_t)
     *      - Invalid alternate source id (AlternateSrcIdList_t)
     *
     * @version Release 7.5
     */    
    PcrSettingList_t GetPcrPids(in IPS_RefSvc_t ServiceOut, in AlternateSrcIdList_t AlternateSrcIdList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /// @} end of group pids
    
    /** @defgroup portConfig PortConfig
     * This contains types, enums and methods to configure the ports of the multiplexer part in the device.
     * @{
     */
    enum eIPS_PortSelectMode
    {
      IPS_PSM_ManualA,
      IPS_PSM_ManualB,
      IPS_PSM_AutoA,
      IPS_PSM_AutoB
    };

    enum eIPS_PortSelectRevert
    {
      IPS_PSR_Active,
      IPS_PSR_Inactive
    };

    enum ePortBackupTrigger
    {
      PBT_LinkLoss,
      PBT_LinkAndUdpLoss
    };

    enum eIPS_AutoNegociation
    {
      IPS_AN_OFF, 
      IPS_AN_ON
    };

    enum eAsiPacketFormat
    {
      eAsiPacketFormat204Bytes,
      eAsiPacketFormat188Bytes,
      eAsiPacketFormatNone   ///< Unknown or not set.
    };
  
    /**
     * @note Output mode can only be set to byte mode when the output bitrate on that 
     * ASI port <= 155 Mbps.
     */
    enum eAsiOutputMode
    {
      eAsiOutputModeByte,
      eAsiOutputModePacket,
      eAsiOutputModeNone    ///< Input ports don't support this.
    };
  
    /// Structure to set ASI format and output mode.
    struct AsiFormatData_t
    {
      IPS_Ref_t Location;
      eAsiPacketFormat PacketFormat;
      eAsiOutputMode OutputMode;
    };
      
    /// A sequence of AsiFormatData_t.
    typedef sequence<AsiFormatData_t> AsiFormatDataList_t;
    
    /// Structure to define port mirroring for ASI.
    /// - The content of an ASI input port can be transparently looped to a specified output port (mirror port)
    /// - The content of an ASI output port can be duplicated to a specified output port
    struct ASI_MirrorCfg_t
    {
       unsigned short MirrorPortNr;  ///< Output port to where the data is mirrored
       unsigned short MainPortNr;    ///< Mirror source port from where content is routed
    };
    
    /// A sequence of ASI_MirrorCfg_t.
    typedef sequence<ASI_MirrorCfg_t> ASI_MirrorCfgList_t;

    /// Enumeration of port streaming type
    enum ePortStreamingType
    {
      PortStreamingType_Off,
      PortStreamingType_On,
      PortStreamingType_Auto
    };
    struct IpCfg_t
    {
      string IpAddress;
      string SubnetMask;
    };
    typedef sequence<IpCfg_t> IpCfgList_t;

    /** structure to Create/Get information on Vlan PortSets */
    struct VlanPortSet_t
    {
      /** Underlying Physical (GbE) Port Set */
      IPS_Ref_t RefPhysPortSet;
      /** Handle to identify a VlanPortSet.
       * If you need to access the Vlan Interface themselves, the IPS_Ref_t of the main vlan Interface equals RefVlanPortSet, and the Backup Vlan Interface has a port number one higher.
       * RO field
       */
      IPS_Ref_t RefVlanPortSet;
      /** valid range: 1-4094 */
      unsigned short VLANID; 
      /** Configured addresses of the vlan interfaces.
       * sequence length must match number of ports in the physical portset, i.e. 2 for now.
       */
      IpCfgList_t ItfAddresses;
      /** true if the configured VLAN can be deleted.
       *  It cannot be deleted if it is in use e.g. in IGMP joins
       *  RO field
       */
      boolean bCanBeDeleted;
    };

    /** Creates a Vlan Port Set on a GbE board.
     * When creating a VlanPortSet, RefVlanPortSet is ignored.
     * The created vlan will have the same number of ports as the underlying portset, so the length of ItfAddresses must match.
     * This means two vlan ports are created: the main one with the same IPS_Ref_t as the port set, and a backup one with a port number one higher.
     * @param[in] Settings Parameters for the Vlan PortSet to create
     * @param[out] RefVlanPortSet Handle to the created portset.
     * @exception OpNotSupported When called for other boards than GbE ones (Main, ASI,...).
     * @exception OpNotSucceeded In case
     * - RefPhysPortSet is not a physical port set
     * - Invalid VLAN id
     * - VLAN id already in use
     * - Too many VLANs (current limit: 240 vlan ports = 120 vlan portsets)
     * - bad ip address/subnet (see  IPS_IP_ParamsSet)
     */
    void CreateVlanPortSet(in VlanPortSet_t Settings, out IPS_Ref_t RefVlanPortSet)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Delete a Vlan PortSet.
     * @param[in] RefVlanPortSet Handle to the Vlan PortSet to destroy. No wildcard allowed
     * @exception OpNotSupported When called for other boards than GbE ones (Main, ASI,...).
     * @exception OpNotSucceeded In case
     * - RefVlanPortSet is not a Vlan Port Set
     * - bCanBeDeleted is false (vlan port set is still in use in a way that inhibits deletion, for now: IGMP join is defined on it)
     */
    void DeleteVlanPortSet(in IPS_Ref_t RefVlanPortSet)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    typedef sequence<VlanPortSet_t> VlanPortSetList_t;

    /** get all vlan portsets connect to a physical portset.
     * wildcard allowed for portnr.
     * @param[in] RefPhysPortSet The physical portset. Wildcard allowed for portnr.
     * @param[out] VlanPortSetList The list of Vlan PortSets attached to the specified physial portset/board
     * @exception OpNotSupported When called for other boards than GbE ones (Main, ASI,...).
     * @exception OpNotSucceeded In case
     * - RefPhysPortSet is not a Physical Port Set
     */
    void GetVlanPortSets(in IPS_Ref_t RefPhysPortSet, out VlanPortSetList_t VlanPortSetList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    // PortConfig IDLs
    // ------------------------------------------------------------------------------------
    /** Sets the IP addresses, network mask and default gateway for a GbE port.
     * 
     * @param[in] RefPhys Specifies the Port to set the IP params. A virtual port is possible.
     
     * @param[in] IPAddress Ip address of the port.
     * @param[in] SubNetMask SubNetMask of the port.
     * @param[in] AutoNeg Auto negotiation value of the port. Changing this value is undefined for a virtual port.
     *
     * @exception OpNotSupported When called for other boards than GbE ones (Main, ASI,...).
     * @exception OpNotSucceeded In case
     * - Invalid references are used (RefPhys)
     * - Invalid enum values (AutoNeg)
     * - Invalid netmask (should be, binary, all ones followed by all zeros)
     * - IPAddress is in class D or class E subnet
     * - IPAddress is in 127.x.y.z or 0.x.y.z subnet
     * - IpAddress is already in use on the board (the same subnet is allowed though)
     *
     */
    void IPS_IP_ParamsSet(in IPS_Ref_t RefPhys, in string IPAddress, in string SubNetMask, in eIPS_AutoNegociation AutoNeg) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Gets the IP address, network mask and default gateway for a Gigabit ethernet output. A virtual port is possible.
     *
     * @param[in] RefPhys Specifies the Port to get the IP params from. A virtual port is possible.
     * @param[out] IPAddress
     * @param[out] SubNetMask 
     * @param[out] AutoNeg  This value is undefined for a virtual port.
     * @param[out] MacAddress This value is undefined for a virtual port.
     *
     * @return IPAddress Ip address of the port.
     * @return SubNetMask SubNetMask of the port.
     * @return AutoNeg Auto negotiation of the port.
     * @return MacAddress MAC address of the port.     
     *
     * @exception OpNotSupported When called for other boards than GbE ones (Main, ASI,...).
     * @exception OpNotSucceeded In case invalid references are used (RefPhys).
     */
    void IPS_IP_ParamsGet(in IPS_Ref_t RefPhys, out string IPAddress, out string SubNetMask, out eIPS_AutoNegociation AutoNeg, out string MacAddress) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Activates a certain GigE output port.
     *
     * @param[in] RefPhys Specifies BoardNr & PortNr.
     * @param[in] Mode Manually, automatically,...
     * @param[in] Revert If the port selection switches back to previous when a fail occurred.
     * @param[in] RevertDelay After which time it should revert, in seconds, 0..60.
     *
     * @exception OpNotSupported When called for other boards than GbE ones (Main, ASI,...).
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys)
     * - Invalid enum values (Mode, Revert)
     * - Out of range values (RevertDelay)
     * - GbE board configured in individual port mode (2I2O)
     *
     * @note 
     * - It's possible to manually activate a port or let the device decide in automatic mode.
     * - If mode is manual, the given output port will be used as default.
     */
    void IPS_SelectModeSet(in IPS_Ref_t RefPhys, in eIPS_PortSelectMode Mode, in eIPS_PortSelectRevert Revert, in unsigned long RevertDelay) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Gets the active output mode status.
     *
     * @param[in] RefPhys Specifies BoardNr & PortNr to get information from
     * @param[out] Mode
     * @param[out] Revert 
     * @param[out] RevertDelay
     *
     * @return Mode see IPS_SelectModeSet
     * @return Revert see IPS_SelectModeSet
     * @return RevertDelay see IPS_SelectModeSet
     *
     * @exception OpNotSupported When called for other boards than GbE ones (Main, ASI,...).
     * @exception OpNotSucceeded In case 
     * - invalid references are used (RefPhys).
     * - GbE board configured in individual port mode (2I2O).
     */
    void IPS_SelectModeGet(in IPS_Ref_t RefPhys, out eIPS_PortSelectMode Mode, out eIPS_PortSelectRevert Revert, out unsigned long RevertDelay) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Gets the selected port based on the SelectMode and the linkstatuses.
     *
     * @param[in] RefPhys Specifies BoardNr & PortNr
     *
     * @return Selected Port Resulting port number will be 1 or 2 for respective GbE1 Main, GbE2 Backup or GbE3 Main, GbE4 backup.
     *
     * @exception OpNotSupported When called for other boards than GbE ones (Main, ASI,...).
     * @exception OpNotSucceeded In case 
     * - invalid references are used (RefPhys).
     * - GbE board configured in individual port mode (2I2O).
     */
    unsigned long IPS_SelectedPortGet(in IPS_Ref_t RefPhys) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported); 

    /** Set the port backup trigger mode (trigger on link loss only or on link or udp loss) 
     * 
     * @param[in] RefPhys Specifies BoardNr & PortNr
     * @param[in] eTrigger Trigger mode
     *
     * @exception OpNotSucceeded In case of invalid references (RefPhys)
     * @exception OpNotSucceeded In case of invalid Trigger mode.
     * @exception OpNotSupported When called for other boards than GbE ones (Main, ASI, ...) or 
     *                           if the GbE board is in individual port (2I2O) mode.
     */
    void IPS_SetPortBackupTrigger(in IPS_Ref_t RefPhys, in ePortBackupTrigger eTrigger) 
        raises(TimeOut, OpNotSucceeded, OpNotSupported); 

    /** Gets the port backup trigger mode (trigger on link loss only or on link or udp loss)
     * 
     * @param[in] RefPhys Specifies BoardNr & PortNr
     * @param[out] eTrigger 
     *
     * @return ePortBackupTrigger 
     *
     * @exception OpNotSucceeded In case of invalid references (RefPhys)
     * @exception OpNotSupported When called for other boards than GbE ones (Main, ASI, ...)
     *                           if the GbE board is in individual port (2I2O) mode.
     * 
     * @return Trigger mode (eTrigger)
     */
    void IPS_GetPortBackupTrigger(in IPS_Ref_t RefPhys, out ePortBackupTrigger eTrigger) 
        raises(TimeOut, OpNotSucceeded, OpNotSupported); 

     /** Set port mirroring on GbE ports
     * A GbE portpair can be used in Port Mirroring mode: both main and backup ports are actively streaming 
     * and the backup port streams out an exact copy of the active port.
     *
     * @param[in] RefPhys Identifies the (main) port. No wildcards allowed.
     * @param[in] EnablePortMirroring Is true in case PortMirroring is enabled. Default is false.
     *
     * @exception OpNotSupported When the board is not a GbE board, IP Video Adapter board or IP Audio Gateway board.
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist (or is a backup port).
     * - GbE board is configured in individual port mode (2I2O).
     */
    void IPS_SetPortMirrorMode(in IPS_Ref_t RefPhys, in boolean EnablePortMirroring)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get port mirroring status of GbE ports
     * A GbE portpair can be used in Port Mirroring mode: both main and backup ports are actively streaming 
     * and the backup port streams out an exact copy of the active port.
     *
     * @param[in] RefPhys Identifies the (main) port. No wildcards allowed.
     * @param[out] EnablePortMirroring Is true in case PortMirroring is enabled. Default is false.
     *
     * @exception OpNotSupported When the board is not a GbE board, IP Video Adapter board or IP Audio Gateway board.
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist (or is a backup port).
     * - GbE board is configured in individual port mode (2I2O).
     */
    void IPS_GetPortMirrorMode(in IPS_Ref_t RefPhys, out boolean EnablePortMirroring)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the ASI format and output mode of ASI output ports.
     * 
     * @param[in] RefPhys specifies the BoardNr & PortNr.
     * @param[in] AsiFormatList List of ports with their according ASI format.
     * 
     * @exception OpNotSupported When called for other boards than ASI ones (Main, GbE,...).
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys, Location).
     * - Invalid enum values (PacketFormat, OutputMode).
     * - Inconsistency between RefPhys.BoardNr & AsiFormatList[x].Location.BoardNr.
     * - Inconsistency between RefPhys.PortNr & AsiFormatList[x].Location.PortNr in case RefPhys.PortNr != 0xFFFF.
     * - When set on a input ASI port.
     */
    void SetAsiFormat(in IPS_Ref_t RefPhys, in AsiFormatDataList_t AsiFormatList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported); 
    
    /** Get the ASI format (input & output ports) and output mode of ASI output ports
     * 
     * @param[in] RefPhys Specifies the BoardNr & PortNr
     * 
     * @return AsiFormatDataList_t list of asi data.
     * 
     * @exception OpNotSupported When called for other boards than ASI ones (Main, GbE,...).
     * @exception OpNotSucceeded In case invalid references (RefPhys) are used.
     * 
     * @note Format can be asked for one specific or all ASI ports (input as well as output), this by setting 
     * the PortNr to 0xFFFF.
     */
    AsiFormatDataList_t GetAsiFormat(in IPS_Ref_t RefPhys) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get the port mirror configuration of the ASI ports
     *
     * @param[in] BoardNr Specifies the BoardNr
     * @param[out] MirrorCfgList List of port mirror configuration
     *
     * @exception OpNotSupported When called for non-ASI boards
     *
     * @note
     * - MirrorPortNr is the output port to where the data is mirrored
     * - MainPortNr is the corresponding source port (input or output)
     */
    void ASI_MirrorCfgGetL(in unsigned short BoardNr, out ASI_MirrorCfgList_t MirrorCfgList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Set the port mirror configuration of the ASI ports
     *
     * @param[in] BoardNr Specifies the BoardNr
     * @param[in] MirrorCfgList List of port mirror configuration
     *
     * @exception OpNotSupported When called for non-ASI boards
     * @exception OpNotSucceeded In case of
     * - Invalid port specified
     * - MirrorPortNr not unique in list
     *
     * @note
     * - MirrorPortNr is the output port to where the data is mirrored
     * - MainPortNr is the corresponding source port (input or output)
     * - Deleting a mirror occurs when MirrorPortNr == MainPortNr
     */
    void ASI_MirrorCfgSetL(in unsigned short BoardNr, in ASI_MirrorCfgList_t MirrorCfgList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    struct ASI_BW_LimitData_t
    {
      IPS_Ref_t Location;
      boolean Enabled; // true: Bandwidth is limited to given bitrate
      unsigned long Bitrate;  // range: 0bps to 213000000bps, default 40000000bps
    };
    typedef sequence<ASI_BW_LimitData_t> ASI_BW_LimitDataList_t;

    /** Enable/disable the ASI bandwith limiting feature and set its bitrate.
     * 
     * @param[in] RefPhys specifies the BoardNr & PortNr.
     * @param[in] Settings List of ports with their according ASI Bandwidth limiting settings.
     * 
     * @exception OpNotSupported When called for other boards than ASI ones (Main, GbE,...).
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys, Location).
     * - BitRate out of range.
     * - Inconsistency between RefPhys.BoardNr & Settings[x].Location.BoardNr.
     * - Inconsistency between RefPhys.PortNr & Settings[x].Location.PortNr in case RefPhys.PortNr != 0xFFFF.
     * - When set on a output ASI port.
     */
    void InPort_ASI_BW_Limit_SetL(in IPS_Ref_t RefPhys, in ASI_BW_LimitDataList_t Settings)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the ASI bindwidth limiting data.
     * 
     * @param[in] RefPhys Specifies the BoardNr & PortNr
     * 
     * @return AsiFormatDataList_t list of asi data.
     * 
     * @exception OpNotSupported When called for other boards than ASI ones (Main, GbE,...).
     * @exception OpNotSucceeded In case invalid references (RefPhys) are used.
     * 
     * @note Data can be asked for one specific port by specifying the proper PortNr or  
     *       for all input ASI ports by setting the PortNr to 0xFFFF.
     */
     ASI_BW_LimitDataList_t InPort_ASI_BW_Limit_GetL(in IPS_Ref_t RefPhys)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /**
     * @brief Set the port output streaming setting.
     *
     * @param[in]     RefPhys               specifies the port-pair
     * @param[in]     PortOutputStreaming   port streaming setting
     *
     * @exception OpNotSupported  when called for boards other than ASI, IP Audio Gateway or IP Video Gateway.
     * @exception OpNotSucceeded  in case of
     * - invalid port specified
     * - invalid port streaming setting
     **/
    void PortOutputStreamingSet(in IPS_Ref_t RefPhys, in ePortStreamingType PortOutputStreaming)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get the port output streaming setting.
     *
     * @param[in]     RefPhys               specifies the port-pair
     * @param[out]    PortOutputStreaming   port streaming setting
     * @param[out]    bStreaming            actual port streaming state
     *
     * @exception OpNotSupported  when called for boards other than ASI, IP Audio Gateway or IP Video Gateway.
     * @exception OpNotSucceeded  in case of
     * - invalid port specified
     * - invalid port streaming setting
     **/
    void PortOutputStreamingGet(in IPS_Ref_t RefPhys, out ePortStreamingType PortOutputStreaming, out boolean bStreaming)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** 
     * @brief Set the given port pair in mirror mode.
     * 
     * @param[in]  RefPhys        Contains board and port number, port number should 
     *                            be either 0 or 2 (port numbers 0 and 1 refer to 
     *                            the 1st port pair, 2 and 3 to the 2nd port pair)
     * @param[in]  MirroredPort   When different from RefPhys, RefPhys will be 
     *                            mirroring MirroredPort, otherwise mirroring is 
     *                            disabled. Port number should be either 0 or 2.
     *
     * @exception OpNotSupported  when called for non-GBE boards
     * @exception OpNotSucceed    - when trying to activate port pair mirroring 
     *                              and the other pair is already mirroring.
     *                            - when supplied port number is invalid.
     *                            - when RefPhys and MirroredPort are not on the 
     *                              same IO board.
     *
     * @version  Release 6.5 
     */
    void SetPortPairMirror(in IPS_Ref_t RefPhys, in IPS_Ref_t MirroredPort)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);    

    /** Returns the port pair mirror for the supplied port.
     * 
     * @param[in] RefPhys         Contains board and port number, port number should 
     *                            be either 0 or 2 (port numbers 0 and 1 refer to 
     *                            the 1st port  pair, 2 and 3 to the 2nd port pair).
     * @param[out] MirroredPort   Contains the current setting, when different from 
     *                            RefPhys, port pair RefPhys is mirroring MirroredPort 
     *                            otherwise no port pair mirroring is active.
     *
     * @exception OpNotSupported  when board nbr does not match a Gbe IO board.
     * @exception OpNotSucceed    when supplied port number is invalid.
     *
     * @version  Release 6.5 
     */
    void GetPortPairMirror(in IPS_Ref_t RefPhys, out IPS_Ref_t MirroredPort)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /// @} end of group PortConfig   
 
    /** @defgroup vsb 8-VSB
     * This contains types, enums and methods to configure 8VSB ports.
     * @{
     */

    /** Tuning parameters for an 8VSB input port.
     *  The selection of the channel can be done by means of the ChannelNbr or the Frequency.
     *  If the ChannelNbr is a non-negative value, the ChannelNbr will be used for tuning 
     *  (the frequency corresponding to the channel number is used). The Frequency is ignored 
     *  in that case. In order to tune to a custom frequency, the ChannelNbr must be set to a
     *  negative value, e.g. -1 and a valid frequency needs to be filled in.
     *
     * @version Release 8.1
     */
    struct InPort_8VSB_TuningParams_t 
    {
      IPS_Ref_t InputPortRef;   ///< Reference of the input port.
      short ChannelNbr;         ///< A value from 1 to 82. Negative if frequency is used.
      unsigned long Frequency;  ///< In KHz. Valid range is 47000 to 885000, multiples of 125.
      boolean IsLocked;         ///< Output parameter indicating whether tuner is locked to channel.
      long InputLevel;          ///< Output parameter indicating signal level in dBm. 
                                ///  If the input level is out of range the InputLevel 
                                ///  is set to the minimum or maximum long value, e.g. 2147483647 in case of 
                                ///  above measurement range or -2147483648 in case of below measurement range.
    };

    /// A sequence of InPort_8VSB_TuningParams_t.
    typedef sequence<InPort_8VSB_TuningParams_t> InPort_8VSB_TuningParams_List_t;
    
    /** Represents the 8VSB input port specific settings. The SignalHighThreshold must be 
     * equal to or greater than the SignalLowThreshold. 
     * 
     * @version Release 8.1
     * @version Release 8.5 MER threshold range has been restricted to 15..35 (instead of 0..40).
     */
    struct InPort_8VSB_Config_t 
    {
      IPS_Ref_t InputPortRef; ///< Reference of the 8VSB input port.
      long SignalLowThreshold; ///< In dBm. Valid range is -80 to -20.
      long SignalHighThreshold; ///< In dBm. Valid range is -80 to -20. 
      unsigned long MER_Threshold; ///< in dB. Valid range is 15 to 35.
    };

    /// A sequence of InPort_8VSB_Config_t
    typedef sequence<InPort_8VSB_Config_t> InPort_8VSB_Config_List_t;

    /** Defines the statistics that can be retrieved per 8VSB input port. Fields indicated
     * for future use will get a default value, e.g. 0.
     * 
     * @version Release 8.1
     */
    struct InPort_8VSB_Statistics_t
    {
      IPS_Ref_t InputPortRef; ///< Reference of the 8VSB input port.
      long InputLevel; ///< Signal level in dBm. If the input level is out of range the InputLevel 
                       ///  is set to the minimum or maximum long value, e.g. 2147483647 in case of 
                       ///  above measurement range or -2147483648 in case of below measurement range.
      unsigned long MER; ///< Modulation Error Ratio in dB
      long  BER; ///< (future) Bit Error Rate (errored bits per second).
      unsigned long long RS_FEC_Correctable; ///< Number of correctable RS FEC errors.
      unsigned long long RS_FEC_Uncorrectable; ///< Number of uncorrectable RS FEC errors.
      unsigned long long RS_FEC_Clean; ///< Number of clean RS blocks.  
    };

    /// A sequence of InPort_8VSB_Statistics_t
    typedef sequence<InPort_8VSB_Statistics_t> InPort_8VSB_Statistics_List_t;



    /** Sets the tuning parameters for the input ports of a board.
     *
     * @param[in] RefPhys RefPhys specifies the BoardNr and PortNr. PortNr can be 0xFFFF if 
     *                    more than one port is configured.
     * @param[in] Settings A list of input ports with their corresponding tuning parameters.
     * 
     * @exception OpNotSupported When called for a board not containing 8VSB ports, such as main, GBE, ASI.
     * @exception OpNotSucceeded In case of
     *                           - invalid references (RefPhys, Location)
     *                           - Tuning parameters out of range
     *                           - Inconsistency between RefPhys.BoardNr and 
     *                             Settings[x].InputPortRef.BoardNr.
     *                           - Inconsistency between RefPhys.PortNr and 
     *                             Settings[x].InputPortRef.PortNr if RefPhys.PortNr!=0xFFFF.
     *                           - When applied to an output port.
     *
     * @version Release 8.1
     */
    void InPort_8VSB_TuningParams_SetL(in IPS_Ref_t RefPhys, 
                                       in InPort_8VSB_TuningParams_List_t Settings)
      raises (TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    
    /** Get the tuning parameters of the given input port(s). Both channel number and
     *  frequency will be filled in in the returned structures, as well as an indication
     *  of the lock status and the (RF) input level.
     *  If the channel was selected using the frequency a negative value will be filled in 
     *  as channel number in the returned settings.
     * 
     * @param[in]  RefPhys  Specifies the BoardNr & PortNr. If PortNr is 0xFFFF the tuning	
     *                      parameters of all input ports supporting tuning are retrieved.
     * @param[out] Settings list of input port tuning parameters.
     * 
     * @exception OpNotSupported When called for boards not containing 8VSB ports (Main, GbE...).
     * @exception OpNotSucceeded In case invalid references (RefPhys) are used.
     * 
     * @note Data can be asked for one specific port by specifying the proper PortNr or  
     *       for all input ports by setting the PortNr to 0xFFFF.
     *
     * @version Release 8.1
     */
    void InPort_8VSB_TuningParams_GetL(in IPS_Ref_t RefPhys, 
                                       out InPort_8VSB_TuningParams_List_t Settings)
      raises (TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
      
    
    /** Sets 8VSB specific configuration of one or more 8VSB input ports.
     * 
     * @param[in] RefPhys  Boardnr and PortNr. PortNr can be 0xFFFF if more than one port is
     *                     configured.
     * @param[in] Settings A list containing the configuration of the 8VSB port(s).
     * 
     * @exception OpNotSupported When called for a board not containing 8VSB input ports,
     *                           such as main board, GbE board or ASI board.
     * @exception OpNotSucceeded In case of
     *                           - invalid references (RefPhys, Settings[x].InputPortRef)
     *                           - Inconsistency between RefPhys.BoardNr and 
     *                             Settings[x].Location.BoardNr.
     *                           - Inconsistency between RefPhys.PortNr and 
     *                             Settings[x].Location.PortNr if RefPhys.PortNr != 0xFFFF.
     *                           - When set on an output port.
     *                           - When set on an input port which is not an 8VSB input port.
     *
     * @version Release 8.1
     */
    void InPort_8VSB_Config_SetL(in IPS_Ref_t RefPhys, in InPort_8VSB_Config_List_t Settings)
      raises (TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Gets the 8VSB specific configuration of one or more 8VSB input ports.
     * 
     * @param[in]  RefPhys  Specifies the BoardNr & PortNr
     * @param[out] Settings List of BW limit configuration data.
     * 
     * @exception OpNotSupported When called for boards not containing 8VSB input ports
     *                           (Main, GbE,...).
     * @exception OpNotSucceeded In case invalid references (RefPhys) are used.
     * 
     * @note Data can be asked for one specific port by specifying the proper PortNr or  
     *       for all input 8VSB input ports by setting the PortNr to 0xFFFF. In the latter
     *       case the returned list will only contain 8VSB input ports, e.g. if input ports
     *       of different types are present on the board.
     * 
     * @version Release 8.1
     */
    void InPort_8VSB_Config_GetL(in IPS_Ref_t RefPhys, out InPort_8VSB_Config_List_t Settings)
      raises (TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
  
    
    /** Retrieves the statistics for one or more 8VSB input ports.
     * 
     * @param[in]  RefPhys    BoardNr and PortNr. PortNr can be 0xFFFF if more than
     *                        one port is configured.
     * @param[out] Statistics List of statistics per 8VSB input port.
     *
     * @exception OpNotSupported When called for boards not containing any 8VSB 
     *                            input ports.
     * @exception OpNotSucceeded In case of invalid reference (RefPhys).
     *                
     * @note Data can be asked for one specific port by specifying the proper PortNr or  
     *        for all input 8VSB input ports by setting the PortNr to 0xFFFF. In the latter
     *        case the returned list will only contain 8VSB input ports, e.g. if input ports
     *        of different types are present on the board.
     *
     * @version Release 8.1
     */
    void InPort_8VSB_Statistics_GetL(in IPS_Ref_t RefPhys, 
                                    out InPort_8VSB_Statistics_List_t Statistics)
      raises (TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    

    /** Resets the 8VSB statistics for the given 8VSB input port.
     * 
     * @param[in] RefPhys Reference of the 8VSB board (PortNr is ignored)
     * @param[in] Ports   A sequence of ports for which to reset the statistics. If an empty
     *                    list is provided, the statistics of all 8VSB input ports on the
     *                    board will be reset.
     *
     * @exception OpNotSupported When called for boards not containing 8VSB ports.
     * @exception OpNotSucceeded In case 
     *              - an invalid RefPhys is provided.
     *              - an invalid port number is provided in the Ports list.
     *              - one of the ports in the Ports list is not an 8VSB input port.
     *
     * @version Release 8.1
     */
    void InPort_8VSB_Statistics_ResetL(in IPS_Ref_t RefPhys, in PortList_t Ports)
      raises (TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /// @} end of group vsb
#endif // DISABLE_MUX_SVC

    /** @defgroup dvbs2 DVB-S2
     * This contains types, enums and methods to configure DVB-S2 ports.
     * @{
     */
#ifndef DISABLE_DVBS2

    // ---------------------------
    // ---- DVB S2 RECEPTION -----
    // ---------------------------
    
    enum eDvbS2_Mode_t
    {
      eDvbS2_Mode_S,
      eDvbS2_Mode_S2,
      eDvbS2_Mode_Auto,  ///< default
      eDvbS2_Mode_Reserved1,
      eDvbS2_Mode_Reserved2,
      eDvbS2_Mode_Reserved3
    };
    
    enum eDvbS2_Polarization_t
    {
      eDvbS2_Polarization_Horizontal, ///< default
      eDvbS2_Polarization_Vertical,
      eDvbS2_Polarization_Reserved1,
      eDvbS2_Polarization_Reserved2,
      eDvbS2_Polarization_Reserved3
    };
    
    enum eDvbS2_Constellation_t
    {
      eDvbS2_Constellation_QPSK,
      eDvbS2_Constellation_8PSK,
      eDvbS2_Constellation_16APSK,
      eDvbS2_Constellation_32APSK,
      eDvbS2_Constellation_Reserved1,
      eDvbS2_Constellation_Reserved2,
      eDvbS2_Constellation_Reserved3,
      eDvbS2_Constellation_Reserved4, 
      eDvbS2_Constellation_Reserved5 
    };
    
    enum eDvbS2_LNC_Band_t
    {
      eDvbS2_LNC_Band_Low,
      eDvbS2_LNC_Band_High,
      eDvbS2_LNC_Band_Reserved1,
      eDvbS2_LNC_Band_Reserved2,
      eDvbS2_LNC_Band_Reserved3
    };
    
    enum eDvbS2_SpectrumInversion_t
    {
      eDvbS2_SpectrumInversion_On,
      eDvbS2_SpectrumInversion_Off,
      eDvbS2_SpectrumInversion_Reserved1,
      eDvbS2_SpectrumInversion_Reserved2,
      eDvbS2_SpectrumInversion_Reserved3
    };
    
    enum eDvbS2_FEC_CodeRate_t
    {
      eDvbS2_FEC_CodeRate_1_4,  ///< 1/4
      eDvbS2_FEC_CodeRate_1_3,  ///< 1/3
      eDvbS2_FEC_CodeRate_2_5,  ///< 2/5
      eDvbS2_FEC_CodeRate_1_2,  ///< 1/2
      eDvbS2_FEC_CodeRate_3_5,  ///< 3/5
      eDvbS2_FEC_CodeRate_2_3,  ///< 2/3
      eDvbS2_FEC_CodeRate_3_4,  ///< 3/4
      eDvbS2_FEC_CodeRate_4_5,  ///< 4/5
      eDvbS2_FEC_CodeRate_5_6,  ///< 5/6
      eDvbS2_FEC_CodeRate_7_8,  ///< 7/8
      eDvbS2_FEC_CodeRate_8_9,  ///< 8/9
      eDvbS2_FEC_CodeRate_9_10, ///< 9/10
      eDvbS2_FEC_CodeRate_Reserved1,
      eDvbS2_FEC_CodeRate_Reserved2,
      eDvbS2_FEC_CodeRate_Reserved3
    };
    
    enum eDvbS2_BandSelection_t
    {
      eDvbS2_BandSelection_Auto, ///< default
      eDvbS2_BandSelection_ForcedLow,
      eDvbS2_BandSelection_ForcedHigh,
      eDvbS2_BandSelection_Reserved1,
      eDvbS2_BandSelection_Reserved2,
      eDvbS2_BandSelection_Reserved3
    };
    
    enum eDvbS2_LncType_t 
    {
      eDvbS2_LncType_SingleBand, ///< default
      eDvbS2_LncType_DualBand,
      eDvbS2_LncType_Reserved1,
      eDvbS2_LncType_Reserved2,
      eDvbS2_LncType_Reserved3
    };
    
    enum eDvbS2_RxMode_t
    {
      eDvbS2_RxMode_SingleStream, ///< single stream reception only (default)
      eDvbS2_RxMode_MultiStream,  ///< single or multi-stream reception
      eDvbS2_RxMode_Reserved1, 
      eDvbS2_RxMode_Reserved2,
      eDvbS2_RxMode_Reserved3
    };
    
    /** The coding and modulation type. */
    enum eDvbS2_MA_Type_t
    {
      eDvbS2_MA_Type_CCM, ///< Constant Coding and Modulation
      eDvbS2_MA_Type_VCM, ///< Variable Coding and Modulation
      eDvbS2_MA_Type_ACM, ///< Adaptive Coding and Modulation
      eDvbS2_MA_Type_Reserved1,
      eDvbS2_MA_Type_Reserved2,
      eDvbS2_MA_Type_Reserved3
    };
    
    /** Structure used to configure single stream or multi-stream mode per port. */
    struct InPort_DvbS2_PortConfig_t
    {
      IPS_Ref_t       RefPhys; ///< port identifier
      eDvbS2_RxMode_t RxMode;  ///< single stream of multi-stream mode.  
    };
    
    /** A sequence of InPort_DvbS2_PortConfig_t. */ 
    typedef sequence<InPort_DvbS2_PortConfig_t> InPort_DvbS2_PortConfig_List_t;
    
    /** Configures the reception mode on one or more DVB S2 ports.
     *
     * @param[in] BoardNr        identifies the board.
     * @param[in] ConfigList     contains the configuration per port.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   not logged in.
     * @exception OpNotSupported if board does not support this function.
     * @exception OpNotSucceeded invalid references are used.
     * @exception LicenseError   required multistream license is not available.
     *
     * @version Release 9.0
     */
    void InPort_DvbS2_RxModeSetL(in unsigned short BoardNr, 
                                 in InPort_DvbS2_PortConfig_List_t ConfigList)
      raises (TimeOut, OpNotAllowed, OpNotSupported, OpNotSucceeded, LicenseError); 
    
    /** Retrieves the reception mode of one or all DVB S2 ports.
     *
     * @param[in]  RefPhys    identifies the port (wildcard is allowed for PortNr).
     * @param[out] ConfigList list of configuration data.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded invalid references are used.
     * @exception OpNotAllowed   not logged in.
     * @exception OpNotSupported if board does not support this function.
     *
     * @version Release 9.0
     */
    void InPort_DvbS2_RxModeGetL(in IPS_Ref_t RefPhys, 
                                 out InPort_DvbS2_PortConfig_List_t ConfigList)
      raises (TimeOut, OpNotAllowed, OpNotSupported, OpNotSucceeded); 
    
    
    /** Structure used to configure the DVB S2 tuner. */
    struct InPort_DvbS2_TunerCfg_t
    {
      IPS_Ref_t              RefPhys;                ///< port identifier
      eDvbS2_Mode_t          Mode;                   ///< auto, DVB-S, DVB-S2
      unsigned long          SatFrequency;           ///< in KHz
      unsigned long          SymbolRate;             ///< in KSym/s (1000..45000)
      eDvbS2_Polarization_t  Polarization;           ///< horizontal or vertical
      eDvbS2_BandSelection_t BandSelection;          ///< auto, forced low, forced high
      long                   SignalLowThreshold;     ///< -75..-25 dBm
      long                   SignalHighThreshold;    ///< -75..-25 dBm
      unsigned short         CN_MarginLowThreshold;  ///< 1..10 dB. Units of 0.1 dB. Eg. 105 represents 10,5 dB
      unsigned long          BER_HighThreshold;      ///< units of 1E-10. Valid values : 1, 10, 100, 1000, 10000, 100000, 1000000, 2000000
                                                     ///  (corresponds to 1E-10 1E-9 1E-8 1E-7 1E-6 1E-5 1E-4 2E-4).
      unsigned long          PL_ScramblingSeqIndex;  ///< 0..262141                                                 
    };
    
    /** A sequence of InPort_DvbS2_TunerCfg_t. */
    typedef sequence<InPort_DvbS2_TunerCfg_t> InPort_DvbS2_TunerCfg_List_t;
    
    /** Configure tuner parameters for one or more DVB S2 ports.
     * 
     * @param[in] BoardNr   Identifies the board.
     * @param[in] Settings  List of configuration data.
     * 
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   not logged in.
     * @exception OpNotSupported when called on non-DVB S2 board.
     * @exception OpNotSucceeded in case of invalid input parameters, references...
     * 
     * @version Release 9.0
     */
    void InPort_DvbS2_TunerCfgSetL(in unsigned short BoardNr, 
                                   in InPort_DvbS2_TunerCfg_List_t Settings)
      raises (TimeOut, OpNotAllowed, OpNotSupported, OpNotSucceeded);
    
    /** Retrieve the tuner parameters for one or all DVB S2 ports. 
     * 
     * @param[in]  RefPhys   identifies the port. Wildcard allowed for PortNr.
     * @param[out] Settings  list of input port tuning parameters.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   not logged in.
     * @exception OpNotSupported when called on non-DVB S2 board.
     * @exception OpNotSucceeded when invalid reference is used.
     *
     * @version Release 9.0
     */
    void InPort_DvbS2_TunerCfgGetL(in IPS_Ref_t RefPhys,
                                   out InPort_DvbS2_TunerCfg_List_t Settings)
      raises (TimeOut, OpNotAllowed, OpNotSupported, OpNotSucceeded);
    
    
    
    
    /** Structure used to configure the DVB S2 LNC. */
    struct InPort_DvbS2_LncCfg_t
    {
      IPS_Ref_t        RefPhys; ///< port identifier
      eDvbS2_LncType_t LncType; ///< single band / dual band
      unsigned long    LoFrequency; ///< (single + dual) 1000000..20000000 KHz, step 125 KHz
      unsigned long    LoFrequencyHigh; ///< (dual only) 1000000..20000000 KHz, step 125 KHz
      boolean          bLncBias; ///< true to enable, false to disable (default)
    };
    
    typedef sequence<InPort_DvbS2_LncCfg_t> InPort_DvbS2_LncCfg_List_t;
    
    /** Configure LNC parameters for one or more DVB S2 ports. 
     * Remark: LNC Bias can only be enabled on the first two DVB S2 ports (first front end).
     * 
     * @param[in] BoardNr  Identifies the board.
     * @param[in] Settings List of configuration data.
     * 
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   not logged in.
     * @exception OpNotSupported when called on non-DVB S2 board.
     * @exception OpNotSucceeded in case of invalid input parameters, references...
     *                           if LNC bias is enabled on invalid ports.
     * 
     * @version Release 9.0
     */
    void InPort_DvbS2_LncCfgSetL(in unsigned short BoardNr, 
                                 in InPort_DvbS2_LncCfg_List_t Settings)
      raises (TimeOut, OpNotAllowed, OpNotSupported, OpNotSucceeded);
    
    /** Retrieve the LNC parameters for one or all DVB S2 ports. 
     * 
     * @param[in]  RefPhys  identifies the port. Wildcard allowed for PortNr.
     * @param[out] Settings list of input port tuning parameters.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   not logged in.
     * @exception OpNotSupported when called on non-DVB S2 board.
     * @exception OpNotSucceeded when invalid reference is used.
     * 
     * @version Release 9.0
     */
    void InPort_DvbS2_LncCfgGetL(in IPS_Ref_t RefPhys,
                                 out InPort_DvbS2_LncCfg_List_t Settings)
      raises (TimeOut, OpNotAllowed, OpNotSupported, OpNotSucceeded);
    
    
    /** Structure used to retrieve status information of a DVB S2 port. 
     * Remarks:
     *   When the port is not locked, following fields are not relevant:
     *   - CN_Level
     *   - CN_Margin
     *   - BER
     *   - DVBS_Mode
     *   - Constellation
     *   - FEC_CodeRate
     *   - SpectrumInversion
     *   - DetectedMode
     *   - MA_Type
     * 
     *   The BER, CN_Margin, FEC_CodeRate and Constellation are only valid if the 
     *   MA_Type is equal to CCM (constant coding and modulation). 
     */
    struct InPort_DvbS2_Status_t
    {
      IPS_Ref_t                  RefPhys;    ///< port identifier
      boolean                    bIsLocked;  ///< true if locked, false if not locked
      long                       InputLevel; ///< -80..-20 dBm. If the input level is out of 
                                             ///  range the InputLevel is set to the minimum
                                             ///  or maximum long value, e.g. 2147483647 in
                                             ///  case of above measurement range or 
                                             ///  -2147483648 in case of below measurement 
                                             ///  range.
      short                      CN_Level;   ///< -30..50 dB. Units of 0.1 dB. Eg. 312 represents 31,2 dB
      short                      CN_Margin;  ///< -30..50 dB. Units of 0.1 dB. Eg. 120 represents 12,0 dB
      unsigned long              BER;        ///< units of 1E-10. Eg. 1000 represents 1E-7.
      eDvbS2_Mode_t              DVBS_Mode;  ///< Detected mode: DVB-S or DVB-S2
      eDvbS2_Constellation_t     Constellation; ///< Constellation.
      eDvbS2_FEC_CodeRate_t      FEC_CodeRate; ///< FEC code rate
      unsigned long              TunerFrequency; ///< 950000 ' 2150000 KHz
      eDvbS2_LNC_Band_t          LNC_Band;   ///< actual RF band (low or high)
      eDvbS2_SpectrumInversion_t SpectrumInversion; 
      eDvbS2_RxMode_t            DetectedMode; ///< single stream or multi-stream detected. 
      eDvbS2_MA_Type_t           MA_Type; ///< Coding and modulation type. 
    };
    
    typedef sequence<InPort_DvbS2_Status_t> InPort_DvbS2_Status_List_t;
    
    /** Retrieve the status of one or all DVB S2 ports. 
     * 
     * @param[in] RefPhys     identifies the port. Wildcard allowed for PortNr.
     * @param[out] StatusList list of input port tuning parameters.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   not logged in.
     * @exception OpNotSupported when called on non-DVB S2 board.
     * @exception OpNotSucceeded when invalid reference is used.
     * 
     * @version Release 9.0
     */
    void InPort_DvbS2_StatusGetL(in IPS_Ref_t RefPhys,
                                 out InPort_DvbS2_Status_List_t StatusList)
      raises (TimeOut, OpNotAllowed, OpNotSupported, OpNotSucceeded);
    
    
    /** Structure containing the different counters per DVB S2 port. */
    struct InPort_DvbS2_Counters_t
    {
      IPS_Ref_t          RefPhys;    ///< port identifier
      unsigned long long BCH_UncorrectedErrors;
      unsigned long long RS_UncorrectedErrors;
      unsigned long long ErroredSeconds;
      unsigned long long SeverelyErroredSeconds;
      unsigned long long PacketsErrorCount;
      unsigned long long TotalPacketsCount;
    };
    
    typedef sequence<InPort_DvbS2_Counters_t> InPort_DvbS2_Counters_List_t;
    
    /** Retrieve the counters of one or all DVB S2 ports.
     * 
     * @param[in] RefPhys     identifies the port. If PortNr is 0xFFFF status parameters of 
     *                        all ports are returned.
     * @param[out] CounterList list of counters per port.
     * 
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   not logged in.
     * @exception OpNotSupported when called on non-DVB S2 board.
     * @exception OpNotSucceeded invalid RefPhys.
     * 
     * @version Release 9.10
     */
    void InPort_DvbS2_CountersGetL(in IPS_Ref_t RefPhys, 
                                   out InPort_DvbS2_Counters_List_t CounterList)
      raises (TimeOut, OpNotAllowed, OpNotSupported, OpNotSucceeded);
    
    /** Reset the counters of one or more DVB S2 ports. 
     * 
     * @param[in] BoardNr identifies the board.
     * @param[in] Ports   list of input ports. Empty list to reset all ports.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   not logged in.
     * @exception OpNotSupported when called on non-DVB S2 board.
     * @exception OpNotSucceeded when invalid reference is used.
     * 
     * @version Release 9.10
     */
    void InPort_DvbS2_CountersResetL(in unsigned short BoardNr, in PortList_t Ports)
      raises (TimeOut, OpNotAllowed, OpNotSupported, OpNotSucceeded);
    
    
    // ----------------------
    // ---- MULTISTREAM -----
    // ----------------------
    
    /// ISI value assigned to single stream (e.g. port in single stream mode).
    const unsigned short INVALID_ISI = 0xffff;
    
    /** DVB-S2 input stream identifier type. */
    typedef unsigned short DvbS2_Isi_t;
    
    /** A sequence of DVB-S2 input stream identifiers. */
    typedef sequence<DvbS2_Isi_t> DvbS2_Isi_list_t;
    
    /** Structure to find a specific TS by port and input stream identifier. */
    struct DvbS2_LookupTS_t
    {
      IPS_Ref_t   RefPhys; ///< Identifies the DVB-S2 port.
      DvbS2_Isi_t Isi;     ///< Input stream identifier.
    };
    
    /** A sequence of DvbS2_LookupTS_t. */
    typedef sequence<DvbS2_LookupTS_t> DvbS2_LookupTS_List_t;
    
    /** Structure containing the looked-up transport stream for a given lookupTS. */
    struct DvbS2_RefTS_t
    {
      DvbS2_LookupTS_t LookupTS; ///< the TS that needed looking up.
      IPS_RefTS_t      RefTS;    ///< TS references of the looked up TS. If not found,
                                 ///  RefTS.Ref is set to INVALID_ITF_REF.
    };
    
    /** A sequence of DvbS2_RefTS_t. */
    typedef sequence<DvbS2_RefTS_t> DvbS2_RefTS_List_t;
    
    /** Gets the transport stream references for a number of transport streams with given
     *  input stream identifier.
     *  If an input TS is looked up, this one will automatically be created when not found.
     *  The number of transport streams that can be created automatically is limited by the 
     *  number of ISI's that can be supported on a DVB-S2 port (currently 6).
     *
     * @param[in] BoardNumber An unsigned short to indicate the slot.
     * @param[in] LookupList  A sequence of board/port/ISI for which TS Index is
     *                        to be returned.
     *
     * @return A DvbS2_RefTS_List_t, a sequence of DvbS2_RefTS_t entries with 
     *         corresponding TS reference.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   not logged in.
     * @exception OpNotSupported When board doesn't support this operation.
     * @exception OpNotSucceeded when BoardNumber or Ref is invalid. 
     * - When too many TS are looked up for a single DVB-S2 port.
     * - When duplicate ISI's are looked up for a single DVB-S2 port.
     *
     * @version Release 9.0
     */
    DvbS2_RefTS_List_t DvbS2_LookupTSs(
                                in unsigned short BoardNumber, 
                                in DvbS2_LookupTS_List_t LookupList) 
      raises (TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Gets the TS reference for a number of transport streams with given input stream
     *  identifier. NO automatic creation will be done in any case.
     *
     * @param[in] BoardNumber   An unsigned short to indicate the slot.
     * @param[in] LookupList    A sequence of board/port/ISI
     *
     * @return A DvbS2_RefTS_List_t, a sequence of DvbS2_RefTS_t entries with 
     *         corresponding TS reference.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   not logged in.
     * @exception OpNotSupported When board doesn't support this operation.
     * @exception OpNotSucceeded - When BoardNumber or LookupList is invalid. 
     *
     * @version Release 9.0
     */
    DvbS2_RefTS_List_t DvbS2_FindTSs(in unsigned short BoardNumber, 
                                     in DvbS2_LookupTS_List_t LookupList) 
      raises (TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Retrieves the list of all detected input stream identifiers on the given DVB-S2 port. 
     * 
     * @param[in]  RefPhys        identification of the DVB-S2 port.
     * @param[out] bIsMultiStream True if multistream is detected. If false IsiList is empty.
     * @param[out] IsiList list of detected input stream identifiers. This list contains all
     *                     ISI's that are detected at the input (can be more than 6).
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   not logged in.
     * @exception OpNotSupported board does not support this operation.
     * @exception OpNotSucceeded - invalid port reference
     *
     * @version Release 9.10
     */ 
    void DvbS2_IsiGetL(in IPS_Ref_t RefPhys, out boolean bIsMultiStream, 
                       out DvbS2_Isi_list_t IsiList)
      raises (TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** DvbS2 information of an incoming DVB-S2 input stream. */
    struct DvbS2_InputTS_t
    {
      IPS_RefTS_t RefIn; ///< Identifies the input stream (Board, Port and Ref).
      DvbS2_Isi_t Isi;   ///< Input stream identifier (INVALID_ISI in case of single stream).
    };
    
    /** A sequence of DvbS2_InputTS_t. */
    typedef sequence<DvbS2_InputTS_t> DvbS2_InputTS_list_t; 
    
    /** Retrieves the list of DVB-S2 input streams.
     *
     * @param[in] PhysRef  Identifies the port. Wildcard allowed for PortNr. 
     * @param[in] RefList  Filter result with list of given TS idents. Empty list to get all.
     *
     * @return Sequence of DvbS2_InputTS_t, mapping the input stream reference to ISI.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   not logged in.
     * @exception OpNotSupported board does not support this operation.
     * @exception OpNotSucceeded if invalid references are used.
     *
     * @version Release 9.0
     */
    DvbS2_InputTS_list_t DvbS2_InTS_GetL(in IPS_Ref_t PhysRef, in Ref_List_t RefList)
      raises (TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported); 
    
    /**
     * Information about a DVBS2 input TS, including the hardware index.
     */
    struct Debug_DvbS2_InputTS_t
    {
      IPS_RefTS_t   RefIn;    ///< The location of the TS (Board, Port and Ref).
      DvbS2_Isi_t   Isi;      ///< Input stream identifier (INVALID_ISI in case of single stream).
      unsigned long HwIndex;  ///< The hardware index for a stream
    };
    
    /// A sequence of Debug_DvbS2_InputTS_t.
    typedef sequence<Debug_DvbS2_InputTS_t> Debug_DvbS2_InputTS_List_t;
    
    /** Get a list of DVBS2 information of incoming transport streams, including the hardware
     *  index.
     *
     * @param[in] PhysRef The BoardNr and PortNr of which you want the information.
     * @param[in] RefList A Ref_List_t, sequence of Ref's (longs) you want info about.
     *
     * @return  A sequence of Debug_DvbS2_InputTS_t entries.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OperationFailed In case invalid references( PhysRef, RefList) are used.
     *
     * @note 
     * - A value of 0xFFFF for port means all ports.
     * - An empty RefList means all refs.
     * - A non-empty RefList is only allowed for a specific PhysRef (not if PhysRef has wildcard).
     * 
     * @version Release 9.10     
     */    
    Debug_DvbS2_InputTS_List_t DebugDvbS2StreamInGetL(in IPS_Ref_t PhysRef, in Ref_List_t RefList) 
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

#endif // DISABLE_DVBS2
    /// @} end of group DVB-S2
   
#ifndef DISABLE_DESCRIPTORS
    /** @defgroup descriptors Descriptors
     * This contains types, enums and methods to configure descriptors settings of the multiplexer part in the device.
     * @{
     */

    // Descriptors Structures and enums
    // ------------------------------------------------------------------------------------
    
    struct TableKeysExt_t
    {
      TableKeys_t TableKey;
      unsigned long Location ;  ///< e.g. Event ID, TS_ID, SID, PID,
                                // 0xFFFFFFFF means Inner+outer loop
                                // 0xFFFFFFFE means for all elements in outer loop
                                // 0xFFFFFFFD means for all elements in inner loop
    };

    typedef sequence<TableKeysExt_t> TableKeysExtList_t;

    enum eDescriptorType
    {
      eDT_ManuallyInserted,  ///< typically from GUI
      eDT_Passed,            ///< typically from input
      eDT_Generated,         ///< e.g. SCS
      eDT_Imported           ///< e.g. PSIG
    };

    struct DescriptorData_t
    {
      TableKeysExt_t TableKey;
      eDescriptorType DescriptorType;  
      long ID;   ///< -1 means invalid ID
      string UserName;
      octet Tag;
      ByteStream DescriptorData;
    };
    typedef sequence<DescriptorData_t> DescriptorDataList_t;
    
    struct DescriptorRule_t
    {
      octet Tag;
      ByteStream AdditionalBytes;
    };
    typedef sequence<DescriptorRule_t> DescriptorRuleList_t;

    struct DescriptorRuleSet_t
    {
      TableKeysExt_t Key;
      DescriptorRuleList_t  RulesList;
    };
    typedef sequence<DescriptorRuleSet_t> DescriptorRuleSetList_t;

    // Descriptors IDLs
    // ------------------------------------------------------------------------------------

    /** Insert descriptors to parts of a table
     * Imported descriptors can be uniquely identified in two ways:
     * either by the tag and the complete descriptor bytestream stream or either by their ID.
     * Other descriptors (generated and passed) can only be uniquely identified using their tag and bytestream.
     * The user can give the descriptor a name.
     *
     * @param[in] RefTS specifies the TS on which descriptors are inserted
     * @param[in] DescriptorDataList specifies the inserted descriptors and where they must be inserted
     * @param[in] Volatile specifies whether the descriptors must be saved to file
     * 
     * @exception OpNotSupported When called for other boards than IO ones (Main,...).
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefTS)
     * - No Tables found
     * - Descriptor Data larger than 255 bytes
     * - No more free ID's (2147483646 available)
     * - DescriptorType set to something other than eDT_ManuallyInserted
     */
    void InsertDescriptorL(in IPS_RefTS_t RefTS, in DescriptorDataList_t DescriptorDataList, in boolean Volatile) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Delete Inserted descriptors
     * This function allows deleting descriptors using a ID or using the TableKeysExt_t with masking for location.
     * If the ID is not invalid then a delete based on ID will be performed.
     *
     * @param[in] RefTS specifies the TS on which descriptors are deleted
     * @param[in] DescriptorDataList specifies which inserted descriptors must be deleted
     *
     * @exception OpNotSupported When called for other boards than IO ones (Main,...).
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefTS).
     * - No Tables found
     */
    void DeleteDescriptorL(in IPS_RefTS_t RefTS, in DescriptorDataList_t DescriptorDataList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get ALL descriptors of a table
     * This function can be used to see all descriptors that are available for the specified table at a certain TS.
     * (dynamic and all inserted descriptors)
     *
     * @param[in] RefTS specifies the TS on which descriptors are deleted
     * @param[in] TableKey specifies which descriptors are to be retrieved. When TableID = 0xFF, all descriptors of the TS are retrieved
     * @param[out] DescriptorDataList
     * @return DescriptorDataList list of descriptors
     * 
     * @exception OpNotSupported When called for other boards than IO ones (Main,...).
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefTS).
     */
    void OutTS_GetDescriptorL(in IPS_RefTS_t RefTS, in TableKeysExt_t TableKey, out DescriptorDataList_t DescriptorDataList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set descriptor order rules to parts of a table
     * Full list set and no add or remove, to allow ordering on the GUI.
     * Call is to be used to add/remove/update the specific rules.
     *
     * @param[in] RefTS specifies the TS for which the rules are set
     * @param[in] OrderRulesList specifies the descriptor order rules and where they must be applied
     * 
     * @return DescriptorDataList list of descriptors
     * 
     * @exception OpNotSupported When called for other boards than IO ones (Main,...).
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefTS). 
     * - No Tables found
     * - Descriptor Data larger than 255 bytes
     */
    void OutTS_SetSpecDescrOrderRules(in IPS_RefTS_t RefTS, in DescriptorRuleSetList_t OrderRulesList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get descriptor order rules
     * Symmetrical with OutTS_SetSpecDescrOrderRules
     *
     * @param[in] RefTS specifies the TS for which the rules are retrieved
     * @param[in] TableKeyList specifies the table-parts for which the rules are retrieved
     * @param[out] OrderRulesList
     * 
     * @return OrderRulesList specifies the descriptor order rules and where they must be applied
     * 
     * @exception OpNotSupported When called for other boards than IO ones (Main,...).
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefTS). 
     */
    void OutTS_GetSpecDescrOrderRules(in IPS_RefTS_t RefTS, in TableKeysExtList_t TableKeyList, out DescriptorRuleSetList_t OrderRulesList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set descriptor blocking rules to parts of a table
     * Full list set and no add or remove, to allow ordering on the GUI.
     * Call is to be used to add/remove/update the specific rules.
     *
     * @param[in] RefTS specifies the TS for which the rules are set
     * @param[in] RemoveRulesList specifies the descriptor blocking rules and where they must be applied
     *
     * @exception OpNotSupported When called for other boards than IO ones (Main,...).
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefTS). 
     * - No Tables found
     * - Descriptor Data larger than 255 bytes
     */
    void OutTS_SetSpecDescrRemoveRules(in IPS_RefTS_t RefTS, in DescriptorRuleSetList_t RemoveRulesList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get descriptor blocking rules
     * Symmetrical with OutTS_SetSpecDescrRemoveRules
     *
     * @param[in] RefTS specifies the TS for which the rules are retrieved
     * @param[in] TableKeyList specifies the table-parts for which the rules are retrieved
     * @param[out] RemoveRulesList
     *
     * @return RemoveRulesList specifies the descriptor blocking rules and where they must be applied
     *
     * @exception OpNotSupported When called for other boards than IO ones (Main,...).
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefTS). 
     */
    void OutTS_GetSpecDescrRemoveRules(in IPS_RefTS_t RefTS, in TableKeysExtList_t TableKeyList, out DescriptorRuleSetList_t RemoveRulesList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set default descriptor order rules.
     * When a new tables are created, these settings will be added to them.
     *
     * @param[in] PhysRef specifies the board for which the rules are set. The port is ignored.
     * @param[in] OrderRules specifies the descriptor order rules. The tablekeys part is ignored.
     *
     * @exception OpNotSupported When called for other boards than IO ones (Main,...).
     * @exception OpNotSucceeded In case of
     * - Descriptor Data larger than 255 bytes
     */
    void Board_SetDefDescrOrderRules(in IPS_Ref_t PhysRef, in DescriptorRuleSetList_t OrderRules) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get default descriptor order rules.
     * Symmetrical with Board_SetDefDescrOrderRules.
     *
     * @param[in] PhysRef specifies the board for which the rules are set. The port is ignored.
     * @param[out] OrderRules 
     *
     * @return OrderRules is returned
     *
     * @exception OpNotSupported When called for other boards than IO ones (Main,...).
     */
    void Board_GetDefDescrOrderRules(in IPS_Ref_t PhysRef, out DescriptorRuleSetList_t OrderRules) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set default descriptor blocking rules.
     * When a new tables are created, these settings will be added to them.
     *
     * @param[in] PhysRef specifies the board for which the rules are set. The port is ignored.
     * @param[in] RemoveRules specifies the descriptor order rules. The tablekeys part is ignored.
     *
     * @exception OpNotSupported When called for other boards than IO ones (Main,...).
     * @exception OpNotSucceeded In case of
     * - Descriptor Data larger than 255 bytes
     */
    void Board_SetDefDescrRemoveRules(in IPS_Ref_t PhysRef, in DescriptorRuleSetList_t RemoveRules) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get default descriptor blocking rules.
     * Symmetrical with Board_SetDefDescrRemoveRules.
     *
     * @param[in] PhysRef specifies the board for which the rules are set. The port is ignored.
     * @param[out] RemoveRules
     *
     * @return RemoveRules is returned
     *
     * @exception OpNotSupported When called for other boards than IO ones (Main,...).
     */
    void Board_GetDefDescrRemoveRules(in IPS_Ref_t PhysRef, out DescriptorRuleSetList_t RemoveRules) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);



    struct MergedESDescriptorData_t
    {
      unsigned short OutputSid;
      IPS_RefPid_t  MergedES_InputPid;
      long ID;
      string UserName;
      octet Tag;
      ByteStream DescriptorData;
    };
    typedef sequence<MergedESDescriptorData_t> MergedESDescriptorDataList_t;

 /** Insert descriptors to merged elementary streams
     * Imported descriptors can be uniquely identified in two ways:
     * either by the tag and the complete descriptor bytestream stream or either by their ID.
     * The user can give the descriptor a name.
     *
     * @param[in] RefTS              specifies the TS on which descriptors are inserted
     * @param[in] DescriptorDataList specifies the inserted descriptors and where they must be inserted
     *                               the ID parameter should be set to -1 (invalid)
     * @param[in] volatile           specifies whether the descriptors must be saved to file
     * 
     * @exception OpNotSupported When called for other boards than IO ones (Main,...).
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefTS)
     * - Merged ES not found
     * - Descriptor Data larger than 255 bytes
     * - No more free ID's (2147483646 available
     *
     * @version release 6.9
     */
    void MergedES_InsertDescriptorL(in IPS_RefTS_t RefTS, in MergedESDescriptorDataList_t DescriptorDataList, in boolean volatile)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

 /** Delete inserted descriptors from Merged ESs
     * This function allows deleting descriptors using a ID. 
     *
     * @param[in] RefTS              specifies the TS on which descriptors are deleted
     * @param[in] DescriptorDataList specifies which inserted descriptors must be deleted 
     *                               (username, tag and bytestream parameters are ignored)
     * @exception OpNotSupported When called for other boards than IO ones (Main,...).
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefTS).
     * - Merged ES not found
     *
     * @version release 6.9
     */        
    void MergedES_DeleteDescriptorL(in IPS_RefTS_t RefTS, in MergedESDescriptorDataList_t DescriptorDataList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

 /** Get ALL Merged ES descriptors for a specific output service
     * This function can be used to see all descriptors that are available for the specified table at a certain TS.
     * (dynamic and all inserted descriptors)
     *
     * @param[in]  RefTS               specifies the TS on which descriptors are deleted
     * @param[in]  OutputSID           specifies the output service ID for which the descriptor should be retrieved. 
     *                                 0xFFFFFFFF means for all output service of the given output TS
     * @param[out] DescriptorDataList  specifies descriptors
     * @return MergedES_DescriptorDataList list of descriptors
     * 
     * @exception OpNotSupported When called for other boards than IO ones (Main,...).
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefTS).
     *
     * @version release 6.9
     */        
    void OutTs_GetMergedES_DescriptorL(in IPS_RefTS_t RefTS,in unsigned long OutputSID, out MergedESDescriptorDataList_t DescriptorDataList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** @defgroup CompactCA Compact CA Descriptor settings
     * This contains types, enums and methods to configure the handling of compact CA decriptors.
     * @{
     */

    /// Compact CA mode
    enum eCompactCaMode
    {
      CompactCaModeOff,        ///< Compact CA descriptors are handled like other CA descriptors.
      CompactCaModeOn          ///< Compact CA descriptors are interpreted and private pids are recognized.
    };

    /// Compact CA descriptor setting (per input TS)
    struct  CompactCaMode_t
    {
      eCompactCaMode    Mode;
      boolean           FollowDefaultRule; ///< readonly flag indicating if default compact CA settings are used
    };
    
    /// Compact CA descriptor settings for specific TS
    struct  InTS_CompactCaMode_t
    {
      IPS_RefTS_t       RefTSIn;
      CompactCaMode_t   CompactCaMode;
    };
    
    /// A sequence of InTS_CompactCaMode_t entries
    typedef sequence<InTS_CompactCaMode_t> InTS_CompactCaMode_List_t;

    /** Set Compact CA descriptor settings for some input TS
     * 
     * @param[in] RefPhys The BoardNr and PortNr of which parameters need to be changed. 
     * @param[in] InTS_CompactCaMode_List List of RefTsIn/CompactCaMode_t pairs
     *
     * @exception OpNotSupported This call is not supported in the running software version.
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist (or is a backup port)
     * - InTS_CompactCaMode_t out of range
     **/
    void InTS_CompactCaMode_SetL(in IPS_Ref_t RefPhys, in InTS_CompactCaMode_List_t InTS_CompactCaMode_List)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    
    /** Get Compact CA descriptor settings for some input TS
     * 
     * @param[in] RefPhys The BoardNr and PortNr you want information about.
     * @param[in] RefTsList List of Referenced input TS for which to return the Compact CA Settings. 
     * Empty list=all InTs attached to RefPhys
     * @param[out] InTS_CompactCaMode_List List of RefTsIn/CompactCaMode_t pairs
     *
     * @exception OpNotSupported This call is not supported in the running software version.
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist (or is a backup port)
     * - RefTs does not match RefPhys
     **/
    void InTS_CompactCaMode_GetL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList, 
                           out InTS_CompactCaMode_List_t InTS_CompactCaMode_List)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    
    /** Delete the Compact CA descriptor settings for some input TS (revert to default)
     * 
     * @param[in] RefPhys The BoardNr and PortNr of which parameters need to be changed.
     * @param[in] RefTsList List of Referenced input TS for which to delete the Compact CA settings
     *
     * @exception OpNotSupported This call is not supported in the running software version.
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist (or is a backup port)
     * - RefTs does not match RefPhys
     **/
    void InTS_CompactCaMode_DelL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    
    /** Set default Compact CA mode settings to be used for all InTS without Compact CA settings.
     * Defaults are attached to a board.
     * The change takes effect immidiately for each input TS that is set to default.
     * 
     * @param[in] BoardNumber The BoardNumber of which parameters need to be changed.
     * @param[in] CompactCaMode The new default setting.
     *
     * @exception OpNotSupported This call is not supported in the running software version.
     * @exception OpNotSucceeded In case of
     * - BoardNumber does not exist
     * - CompactCaMode out of range
     **/
    void SetDefault_CompactCaMode(in unsigned short BoardNumber, in eCompactCaMode CompactCaMode)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Get default Compact CA mode settings to be used for all InTS without Compact CA settings.
     * Defaults are attached to a board.
     *
     * @param[in] BoardNumber The BoardNumber you want information about.
     * @param[out] CompactCaMode The current default.
     *
     * @exception OpNotSupported This call is not supported in the running software version.
     * @exception OpNotSucceeded In case of
     * - BoardNumber does not exist
     **/
    void GetDefault_CompactCaMode(in unsigned short BoardNumber, out eCompactCaMode CompactCaMode)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /// @} end of CompactCA

    // @} end of group descriptors
   
#endif // DISABLE_DESCRIPTORS

#ifndef DISABLE_OTHERS
    /** @defgroup others Others
     * This contains types, enums and methods to configure other settings of the multiplexer part in the device.
     * @{
     */

          
    // Other Structures and enums
    // ------------------------------------------------------------------------------------
    
    // PSI Table retrieval 
    // ---------------------------------------------------------------------------------
    enum eSource {
      Cached,
      Realtime 
    };
    
    enum eTableStatus {
      Status_OK,
      Status_ParseFailed,
      Status_NotFound,
      Status_Pending
    };
    
    enum eSubTableRequestMode {
      RequestModeSynchronous,
      RequestModeAsynchronous
    };
    
    // Next definitions are for descriptor manipulation
    
    // Other IDLs
    // ------------------------------------------------------------------------------------
    /* [OBSOLETE] Return a complete or a part of a table. This call is obsolete.
        It's functionality is replaced by GetSubTable
     *
     * @param[in] RefTS TS reference
     * @param[in] TableID See table below
     * @param[in] ONID See table below
     * @param[in] TSID See table below
     * @param[in] SID See table below
     * @param[in] PID See table below
     * @param[in] Section Section Number in case only 1 section requested. 
     * @param[in] SIPart Requested table part (complete table, 1 section, ...)
     * @param[in] Origin from DMS or real-time
     * @n@n <TABLE>
     * <TR><TD> Table   </TD><TD> TableId    </TD><TD> ONID       </TD><TD> TSID       </TD><TD> TableIdExt </TD><TD> PID        </TD></TR>
     * <TR><TD> PAT     </TD><TD> 0x00000000 </TD><TD>            </TD><TD>            </TD><TD>            </TD><TD>            </TD></TR>
     * <TR><TD> CAT     </TD><TD> 0x00000001 </TD><TD>            </TD><TD>            </TD><TD>            </TD><TD>            </TD></TR>
     * <TR><TD> PMT     </TD><TD> 0x00000002 </TD><TD>            </TD><TD>            </TD><TD> SID        </TD><TD>            </TD></TR>
     * <TR><TD> NITa    </TD><TD> 0x00000040 </TD><TD>            </TD><TD>            </TD><TD>            </TD><TD>            </TD></TR>
     * <TR><TD> NITo    </TD><TD> 0x00000041 </TD><TD>            </TD><TD>            </TD><TD> Network_ID </TD><TD>            </TD></TR>
     * <TR><TD> SDTa    </TD><TD> 0x00000042 </TD><TD>            </TD><TD>            </TD><TD>            </TD><TD>            </TD></TR>
     * <TR><TD> SDTo    </TD><TD> 0x00000046 </TD><TD> ON_ID      </TD><TD>            </TD><TD> TS_ID      </TD><TD>            </TD></TR>
     * <TR><TD> BAT     </TD><TD> 0x0000004A </TD><TD>            </TD><TD>            </TD><TD> Bouquet_ID </TD><TD>            </TD></TR>
     * <TR><TD> EITp/fa </TD><TD> 0x0000004E </TD><TD>            </TD><TD>            </TD><TD> SID        </TD><TD>            </TD></TR>
     * <TR><TD> EITp/fo </TD><TD> 0x0000004F </TD><TD> ON_ID      </TD><TD> TS_ID      </TD><TD> SID        </TD><TD>            </TD></TR>
     * <TR><TD> EITscha </TD><TD> 0x50..0x5F </TD><TD>            </TD><TD>            </TD><TD> SID        </TD><TD>            </TD></TR>
     * <TR><TD> EITscho </TD><TD> 0x60..0x6F </TD><TD> ON_ID      </TD><TD> TS_ID      </TD><TD> SID        </TD><TD>            </TD></TR>
     * <TR><TD> TDT     </TD><TD> 0x00000070 </TD><TD>            </TD><TD>            </TD><TD>            </TD><TD>            </TD></TR>
     * <TR><TD> TOT     </TD><TD> 0x00000073 </TD><TD>            </TD><TD>            </TD><TD>            </TD><TD>            </TD></TR>
     * <TR><TD> AIT     </TD><TD> 0x00000074 </TD><TD>            </TD><TD>            </TD><TD> App type   </TD><TD> AIT PID    </TD></TR>
     * </TABLE> 
     * @note In the table above, empty fields are ignored in set calls.
     * @note In get calls, the PID field will always contain the actual PID value for the
     * table. The Table ID Ext field for PAT and SDTa will contain the TS_ID. For EITp/fa and EITscha,
     * the TSID and ONID fields will be filled in. For SDTa, the ONID field will be filled in as well.
     *
     * @return Requested table, section or ...
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of invalid references (see all parameters).
     *
     * @todo Implement the correct exceptions.
     */
    /*ByteStream IPS_GetTable(in IPS_RefTS_t RefTS, in unsigned long TableID, in unsigned long ONID, in unsigned long TSID, in unsigned long SID, in unsigned long PID, in unsigned long Section, in unsigned long SIPart, in unsigned long Origin) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    */

    /** Retrieves the PSI table (PAT, CAT and PMT) of a given TS in binary format.
     * 
     * @param[in] TS Holds the identification of the Port and eventually TS.
     * @param[in] Input Determines if we are requesting a table from input or output.
     * @param[in] Key Holds the identification of the requested PSI table.
     * @param[in] Pid The pid to acquire. Wildcard: ANY_PID_VALUE, this means that the standard PID-value of the table will be used.
     * @param[in] Location Determines if the table is retrieved cached or real-time.
     * @param[out] SIData The table information returned.
     *
     * @exception OpNotSucceeded when TS does not exist or does not match given input flag.
     * @exception OpNotSucceeded is returned when a transparent PSI table is requested from the output or if a blocked PSI table
     * is requested. 
     */
    void GetSubTable(in IPS_RefTS_t TS, in boolean Input, in TableKeys_t Key, in unsigned short Pid, in eSource Location, out ByteStream SIData)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
      
    /** Retrieves the PSI table (PAT, CAT and PMT) of a given TS in XML format.
     * 
     * @param[in] TS Holds the identification of the Port and eventually TS.
     * @param[in] Input Determines if we are requesting a table from input or output.
     * @param[in] Key Holds the identification of the requested PSI table.
     * @param[in] Pid The pid to acquire. Wildcard: ANY_PID_VALUE, this means that the standard PID-value of the table will be used.
     * @param[in] Location Determines if the table is retrieved cached or real-time.
     * @param[out] SIDataXML ByteStream
     * @param[out] Status eTableStatus.
     *
     * @exception OpNotSucceeded when TS does not exist or does not match given input flag.
     * @exception OpNotSucceeded is returned when a transparent PSI table is requested from the output or if a blocked PSI table
     * is requested. 
     */
    void GetSubTableAsXML(in IPS_RefTS_t TS, in boolean Input, in TableKeys_t Key, in unsigned short Pid, in eSource Location, out ByteStream SIDataXML, out eTableStatus Status)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Retrieves the PSI table (PAT, CAT and PMT) of a given TS in XML format.
     * 
     * @param[in] TS Holds the identification of the Port and eventually TS.
     * @param[in] Input Determines if we are requesting a table from input or output.
     * @param[in] Key Holds the identification of the requested PSI table.
     * @param[in] Pid The pid to acquire. Wildcard: ANY_PID_VALUE, this means that the standard PID-value of the table will be used.
     * @param[in] Location Determines if the table is retrieved cached or real-time.
     * @param[in] RequestMode Determines if the table is requested synchronously or asynchronously.
     * @param[in] SessionID Session ID of the GUI currently requesting the table.
     * @param[out] SIDataXML Requested table is returned in XML format.
     * @param[out] SIData Requested table is returned in binary format.
     * @param[out] Status Status of the requested table 
     * 
     * @exception OpNotSucceeded when TS does not exist or does not match given input flag.
     * @exception OpNotSucceeded is returned when a transparent PSI table is requested from the output or if a blocked PSI table
     * is requested. 
     */    
    void GetSubTableBinaryAndXML(in IPS_RefTS_t TS, in boolean Input, in TableKeys_t Key, in unsigned short Pid, in eSource Location, in eSubTableRequestMode RequestMode, in string SessionID, out ByteStream SIDataXML, out ByteStream SIData, out eTableStatus Status)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Structure that describes a PSIG provision.
     */
    struct PSIGSubTable_t
    {
      unsigned long OnId;             ///< As in PSIG channel setup
      unsigned long TsId;             ///< As in PSIG channel setup
      ePsigType PsigType;            ///< Property of this PSIG connection (SA specific or not)
      long PsigId;                    ///< Identification of the PSIG connection (as used in the scrambler.idl functions)
      unsigned short ChannelId;       ///< PSIG protocol channel ID
      unsigned short StreamId;        ///< PSIG protocol stream ID
      TableKeys_t Keys;               ///< Table Keys (extracted from the sections which were provisioned)
      unsigned short Pid;             ///< As in PSIG stream setup
    };

    typedef sequence<PSIGSubTable_t> PSIGSubTableList_t;

    /** Retrieves the list of currently active PSIG imported tables.
     * Tables with an activation time in the future will not be returned by this function.
     * This function returns the lists of tables exactly as they have been
     * imported on PSIG. This means, for example, that when  provisions are
     * conflicting, both provisoins will be returned, even if only one of them
     * can be active at any given time.
     * All provisions for all PSIG connections are always returned.
     * 
     * @param[in] ONID Return only tables imported for this ONID. Set this parameter to 0xFFFFFFFF (ONID_DONT_CARE) to return tables fo all ONIDs.
     * @param[in] TSID Return only tables imported for this TSID. Set this parameter to 0xFFFFFFFF (TSID_DONT_CARE) to return tables fo all TSIDs.
     * @param[out] PSIGSubTableList This output parameter receives the list of currently active PSIG provisions.
     * 
     * @exception OpNotSucceeded An internal error occurred, or the input parameters could not be retrieved. Should not normally occur.
     */    
    void GetPSIGSubTables(in unsigned long ONID, in unsigned long TSID, out PSIGSubTableList_t PSIGSubTableList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Retrieves a PSIG imported subtable.
     * This function will return the one (sub)table that matches the table identification
     * if it exists. If no such table exists, the function succeeds but the SIData stream
     * is empty.
     * 
     * @param[in] PSIGSubTable The identification of the table, as it was obtained using the
     *                     function GetPSIGSubTables.
     * @param[out] SIData The data as received from the PSIG. This is not necessarily the same data as is present on
     *               the output. This data corresponds to one subtable from a PSIG provision. Note that
     *               a PSIG provision can contain multiple subtables. In this case each call to this function
     *               will return only the part of the provision that corresponds with the subtable which is identified
     *               in the PSIGSubTable parameter, and multiple calls will be needed to retrieve all data.
     * 
     * @exception OpNotSucceeded An internal error occurred, or the input parameters could not be retrieved. Should not normally occur.
     */    
    void GetPSIGSubTableBinary(in PSIGSubTable_t PSIGSubTable, out ByteStream SIData)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    // PSI Table import via IIOP
    // ---------------------------------------------------------------------------------
    
    /** Structure containing the properties a SubTable provisioned via IIOP. */
    struct IIOP_SubTable_t
    {
      unsigned long  OnId;        ///< original network ID of targeted output TS.
      unsigned long  TsId;        ///< transport stream ID of targeted output TS.
      TableKeys_t    TableKeys;   ///< identifies the sub-table.
      unsigned short Pid;         ///< the output PID where the sub-table is played out.
      boolean        bPureImport; ///< indicates if playout is identical to binary data. This parameter
                                  ///  is not taken into account in the DeleteImportedSubTableL call.
    };
    
    /** A sequence of IIOP_SubTable_t. */
    typedef sequence<IIOP_SubTable_t> IIOP_SubTableList_t;


    /**
     * Imports an SI sub-table via IIOP.
     * This function imports an SI sub-table via IIOP in the same way as this is done via the
     * PSIG to MUX interface. 
     * The provisioned SI table is played out on each transport stream with matching
     * ONID / TSID. The table keys are extracted from the provided binary data.
     * It is possible to provide new binary data for an existing sub-table. This results in
     * provisioning of the new binary data.
     * Supported table ID's: NITactual, NITother.
     *
     * @param[in] OnId        The original network ID of matching output TS.
     * @param[in] TsId        Transport stream ID of matching output TS.
     * @param[in] bPureImport If true binary data will be played out with no modifications.
     * @param[in] Pid         Output PID used for playout of the SI table.
     * @param[in] Data        The SI table in binary data format.
     * 
     * @exception OpNotSucceeded if invalid parameters are provided, binary data contans a 
     *                           not supported table ID or any other error.
     * 
     * @version Release 8.5
     */
    void ImportSubTable(in unsigned long OnId, in unsigned long TsId, in boolean bPureImport,
                        in unsigned short Pid, in ByteStream Data)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported); 
    
    
    /**
     * Get the list of SI sub-tables provisioned via IIOP.
     * Use this function to retrieve references of imported sub-tables for deprovisioning.
     * 
     * @param[in]  OnId         ONID of TS. Set to 0xFFFFFFFF to retrieve all sub-tables.
     * @param[in]  TsId         TSID of TS. Set to 0xFFFFFFFF to retrieve all sub-tables.
     * @param[out] SubTableList List of provisioned SubTables.
     *
     * @exception OpNotSucceeded in case of a general error.
     * 
     * @version Release 8.5
     */
    void GetImportedSubTableL(in unsigned long OnId, in unsigned long TsId, 
                              out IIOP_SubTableList_t SubTableList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    
    /**
     * Deprovision one or more previously provisioned SI sub-tables.
     * 
     * @param[in] SubTableList List of sub-tables to deprovision.
     * 
     * @exception OpNotSucceeded if one or more sub-tables were not found.
     *
     * @version Release 8.5
     */
    void DeleteImportedSubTableL(in IIOP_SubTableList_t SubTableList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    // Scte35-extended commands 
    // ---------------------------------------------------------------------------------

    struct PsipUpdateLocation_t 
    {
        octet Id;
        unsigned long Detail;
    };

    /** Definition of a PsipUpdate Rule
     * Rule: number uniquely defining a rule
     *     0: Add/update descriptor
     *     2: Remove descriptor
     *     (this list should be updated when more rules are supported)
     * RuleName: actual meaning of the rule (see above)
     * Location:
     *     0x02, 0xFFFFFFFF: PMT
     *     0xCB, start-time: PsipEIT event
     * RuleData: extra data of rule in readable form (UTF-8):
     *     Add/update descriptor: new descriptor in hex-string. e.g. "050443554549"
     *     Remove descriptor: descriptor tag in 2-character hex. e.g. "05"
     */
    struct PsipUpdateRule_t 
    {
      octet Rule;
      string RuleName;
      PsipUpdateLocation_t Location;
      string RuleData;
    };
    typedef sequence<PsipUpdateRule_t> PsipUpdateRuleList_t;

    struct SvcOutPsipUpdateRule_t
    {
        IPS_RefSvc_t          RefSvc;
        PsipUpdateRuleList_t  PsipUpdateRuleList;
    };

    typedef sequence<SvcOutPsipUpdateRule_t> SvcOutPsipUpdateRuleList_t;
    
    /**  Retrieves the PsipUpdate rules as given via Scte35-extended for a list of services.
     *
     * @param[in] RefTS specifies the TS where we want to retrieve.
     * @param[in] OutputSidList : list of output service ids for which the PsipUpdate
     *                            rules should be returned.
     *
     * @return PsipUpdateRuleList_t  : List of PsipUpdateRule_t entries
     *
     * @exception OpNotSupported When called for other boards than IO ones (Main,...).
     * @exception OpNotSucceeded In case of
     * 			- Invalid references (RefTS)
     *
     * @version Release 7.1
     */
    SvcOutPsipUpdateRuleList_t OutSvc_GetPsipUpdateRuleL(in IPS_RefTS_t RefTS, in ServiceIdList_t OutputSidList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /// The different sources for Redus switch
    enum enRedusSwitchSource
    {
      eRedusSwitchSource1,                ///< Sometimes referred to as ?A? instead of ?1?
      eRedusSwitchSource2                 ///< Sometimes referred to as ?B? instead of ?2?
    };
    
    /// The different modes for Redus switch
    enum enRedusSwitchMode
    {
      eRedusSwitchManual,
      eRedusSwitchAutomatic
    };
    
    /// The different sources for TS backup
    enum enTsInputSwitchSource            ///< In context of TS backup
    {
      eTsInputSwitchSourceMain,           ///< Sometimes referred to as ?A? instead of ?Main?
      eTsInputSwitchSourceBackup          ///< Sometimes referred to as ?B? instead of ?Backup?
    };
    
    /// The different modes for TS backup
    enum enTsInputSwitchMode              ///< In context of TS backup
    {
      eTsInputSwitchManual,
      eTsInputSwitchAutomatic
    };
    
    /// The different values of the Network Feed Active indicator
    enum enNetworkFeedActiveIndicator
    {
      eNetworkFeedInactive,
      eNetworkFeedActive,
      eNetworkFeedUnknown
    };
    
    /// The different values of the Local Feed Available indicator
    enum enLocalFeedAvailableIndicator
    {
      eLocalFeedNotAvailable,
      eLocalFeedAvailable,
      eLocalFeedUnknown
    };
    
    /// The different values of motion mode (logo insertion related)
    enum enMotionMode
    {
      eMotionModeReserverd0,
      eMotionModeReserverd1,
      ePalindromeOnce,
      ePalindromeLoop,
      eDefault,
      eOnce,
      eLoop,
      eStatic
    };    
    
    /// The different types of SCTE-35 commands
    enum enScte35Commands
    {
      eREDUS_switch,
      eDCM_input_switch,
      eSelect_now,
      eNetwork_feed_active_or_inactive,
      eLocal_avail_enable_or_disable,
      eSplicer_reset,
      eKeyer_on_or_off,
      eKeyer_config,
      eLogo_enable_or_disable,
      eLogo_reset,
      eREDUS_switch_single,
      eScte35CommandReserved06,
      eScte35CommandReserved07,
      eScte35CommandReserved08,
      eScte35CommandReserved09,
      eScte35CommandReserved10,
      eScte35CommandReserved11,
      eScte35CommandReserved12,
      eScte35CommandReserved13,
      eScte35CommandReserved14,
      eScte35CommandReserved15
    };
    
    /// The data struct for SCTE-35 command eREDUS_switch
    struct Scte35Data_REDUS_Switch_t 
    {	
      enRedusSwitchSource REDUS_1_state;
      enRedusSwitchMode		REDUS_1_autoswitch;
      enRedusSwitchSource REDUS_2_state;
      enRedusSwitchMode   REDUS_2_autoswitch;
      enRedusSwitchSource REDUS_3_state;
      enRedusSwitchMode   REDUS_3_autoswitch;
      enRedusSwitchSource REDUS_4_state;
      enRedusSwitchMode   REDUS_4_autoswitch;
    };
    
    /// The data struct for SCTE-35 command eREDUS_switch_single
    struct Scte35Data_REDUS_Switch_Single_t
    {
      unsigned short      REDUS_id;
      enRedusSwitchSource REDUS_state;
      enRedusSwitchMode   REDUS_autoswitch;
    };
      
    /// The data struct for SCTE-35 command eDCM_input_switch
    struct Scte35Data_DCM_input_switch_t 
    {	
      enTsInputSwitchSource DCM_radio_input;
      enTsInputSwitchMode   DCM_radio_autoswitch;
      enTsInputSwitchSource DCM_local_input;
      enTsInputSwitchMode   DCM_local_autoswitch;
    };	
    
    /// The data struct for SCTE-35 command eSelect_now
    struct Scte35Data_Select_now_t 
    {
      unsigned long SID;                    ///< A.k.a. Program number
    };
    
    /// The data struct for SCTE-35 command eNetwork_feed_active_or_inactive
    struct Scte35Data_Network_active_t 
    {	
      enNetworkFeedActiveIndicator	Network_active_indicator;
      boolean SelectService;
    };	
    
    /// The data struct for SCTE-35 command eLocal_avail_enable_or_disable
    struct Scte35Data_Local_avail_t 
    {	
      enLocalFeedAvailableIndicator Local_avail_indicator;
    };	
    
    /// The data struct for SCTE-35 command eKeyer_on_or_off
    struct Scte35Data_Keyer_t
    {
      unsigned long  Keyer_id;
      boolean        Keyer_on_indicator;
    };
    
    /// The data struct for SCTE-35 command eKeyer_config
    struct Scte35Data_Keyer_config_t
    {
      unsigned long  Keyer_id;
      unsigned long  Logo_file_number;
      enMotionMode   Motion_mode;
      boolean        Update_flag;
      unsigned short Position_x_offset;
      unsigned short Position_y_offset;
      unsigned short Transition_rate_on;
      unsigned short Transition_rate_off;
      unsigned short Opacity;
    };    
    
    /// The data struct for SCTE-35 command eLogo_enable_or_disable
    struct Scte35Data_Logo_enable_t
    {
      boolean Logo_enable;
    };
    
    /// Union containing data structures of SCTE-35 commands
    union Scte35CommandAndData_t switch (enScte35Commands)
    {
      case eREDUS_switch:								     Scte35Data_REDUS_Switch_t			   Data_REDUS_Switch;
      case eDCM_input_switch:						     Scte35Data_DCM_input_switch_t	   Data_DCM_input_switch;
      case eSelect_now:								       Scte35Data_Select_now_t				   Data_Select_now;
      case eNetwork_feed_active_or_inactive: Scte35Data_Network_active_t	   	 Data_Network_active;
      case eLocal_avail_enable_or_disable:	 Scte35Data_Local_avail_t			     Data_Local_avail;
      // case eSplicer_reset: 							 /* no data */ 		
      case eKeyer_on_or_off:                 Scte35Data_Keyer_t                Data_Keyer;
      case eKeyer_config:                    Scte35Data_Keyer_config_t         Data_Keyer_config;
      case eLogo_enable_or_disable:          Scte35Data_Logo_enable_t          Data_Logo_Enable;
      // case eLogo_reset:                   /* no data */
      case eREDUS_switch_single:             Scte35Data_REDUS_Switch_Single_t  Data_REDUS_Switch_single;
    };
    
    typedef sequence<Scte35CommandAndData_t> Scte35CommandAndData_list_t;     
    
    /** Get the list of commands received through SCTE-35. Each type of command can occur maximum once in the list. 
     *
     * @param[in] SvcOut The output service of which the SCTE-35 commands have been parsed.
     * @param[out] Scte35CommandAndData_list List of commands
     *
     * @exception OpNotSucceeded In case of invalid reference (SvcOut)
     *
     * @version Release 7.1
     */    
    void Scte35CommandGetL(in IPS_Service_t SvcOut, out Scte35CommandAndData_list_t Scte35CommandAndData_list) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the Station ID.
     *
     * @param[in] BoardNr 
     * @param[out] StationID Identifies where the DCM is located.
     *
     * @exception OpNotSucceeded In case of invalid BoardNr
     *
     * @version Release 7.1
     */            
    void StationID_Get (in unsigned short BoardNr, out unsigned short StationID) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the Station ID.
     *
     * @param[in] BoardNr 
     * @param[in] StationID Identifies where the DCM is located. Range is [0, 255].
     *
     * @exception OpNotSucceeded In case of invalid BoardNr
     *
     * @version Release 7.1
     */            
    void StationID_Set (in unsigned short BoardNr, in unsigned short StationID) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the status of the Network Feed Active Indicator.
     *
     * @param[in] SvcOut The output service of which the SCTE-35 commands have been parsed.
     * @param[out] Network_active_indicator 
     *
     * @exception OpNotSucceeded In case of invalid reference (SvcOut)
     *
     * @version Release 7.1
     */            
    void NetworkFeedActiveIndicatorGet (in IPS_Service_t SvcOut, out enNetworkFeedActiveIndicator Network_active_indicator) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the status of the Local Feed Available Indicator.
     *
     * @param[in] SvcOut The output service of which the SCTE-35 commands have been parsed.
     * @param[out] Local_avail_indicator 
     *
     * @exception OpNotSucceeded In case of invalid reference (SvcOut)
     *
     * @version Release 7.1
     */            
    void LocalFeedAvailableIndicatorGet (in IPS_Service_t SvcOut, out enLocalFeedAvailableIndicator Local_avail_indicator) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    enum enFCS_Scte35_Commands
      {
        eBasicScte35,                        /// < Process all basic SCTE35 commands, default
        eInputScte35,
        eOutputScte35,
        eReservedForFuture1,
        eReservedForFuture2,
        eReservedForFuture3,
        eReservedForFuture4,
        eReservedForFuture5,
        eReservedForFuture6,
        eReservedForFuture7,
        eReservedForFuture8,
        eReservedForFuture9,
        eReservedForFuture10
      };


    struct FCS_Scte35_CommandSelect_t
    {
      IPS_RefSvc_t SvcOut;
      enFCS_Scte35_Commands CommandSelect;  // Selects which commands are to be handled by the output service
      IPS_RefSvc_t SwitchToLocalSvc;        // Output Service that will switch to local when Program is selected, valid when command handling is set to eInputScte35
    };


    typedef sequence<FCS_Scte35_CommandSelect_t> FCS_Scte35_CommandList_t;

    /**
     * Sets the list of customer specific SCTE_35 commands to be handled by the specified output services
     * Additionally sets the service that handles the 'splice to local' when a program select is received and
     * the command handling is set to eInputScte35
     *
     * @param [in] RefTS : The TS the services belong to.
     * @param [in] Scte35_CommandList : a List of commands that will be handled by this output service
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case
     * - invalid references are used
     * - invalid values in Scte35_CommandList
     * - no SwitchToLocalSvc is provided when the command handling is set to eInputScte35
     * - The SwitchToLocalSvc is not on the same board as the SvcOut
     *
     * @version Release 7.1
     */
    void FCS_SetScte35_CommandExecuteL(in IPS_RefTS_t RefTS, in FCS_Scte35_CommandList_t Scte35_CommandList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * Gets the list of customer specific SCTE_35 commands to be handled by the specified output service
     *
     * @param [in] RefTS : The TS the services belong to.
     * @param [in] OutputSidList : A list of Service ID's to get info about.
     * @param [out] Scte35_CommandList : a List of commands that will be handled by this output service
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid output references are used (RefTS, OutputSidList).
     *
     * @version Release 7.1
     */
    void FCS_GetScte35_CommandExecuteL(in IPS_RefTS_t RefTS, in ServiceIdList_t OutputSidList, out FCS_Scte35_CommandList_t Scte35_CommandList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    /// @} end of group Others
    
    /** @defgroup PSIP PSIP
     * This module contains types, enums and methods related to ATSC PSIP (Program and System Information Protocol)
     * @{
     */

    /** Multiple String: ATSC string representation.
     * Actually, the string is passed in UTF-8 format for easy handling.
     * The language code, compression type and mode are passed, so they can be changed.
     */
    struct MultipleStringSegment_t
    {
      octet CompressionType;
      octet Mode;
      ByteStream Data;  ///< String segment in UTF-8 format
    };

    struct MultipleStringElement_t
    {
      string LanguageCode;
      sequence<MultipleStringSegment_t> Segments;
    };

    typedef sequence<MultipleStringElement_t> MultipleString_t;
    
    /** Transport Stream standard to guide generation (and display) of output tables.
     * This enum is added for PSIP support.
     */
    enum eTableStandard_t
    {
      eTableStandardAll,
      eTableStandardMPEG2, ///< (PAT, CAT and PMT only)
      eTableStandardDVB,
      eTableStandardATSC ///< Support for PSIP.
    };
        
    /** Set the default output TS standard.
     *
     * @param[in] Board specifies BoardNr.
     * @param[in] eNew specifies the new default.
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case eNew is not in range for a valid eTableStandard_t.
     *
     * @version release 6.0
     */
    void SetDefaultOutputTsStandard(in unsigned short Board, in eTableStandard_t eNew)  
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported); 

    /** Get the default output TS standard.
     * 
     * @param[in] Board specifies BoardNr.
     * @param[out] eStandard The current setting. 
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     *
     * @version release 6.0
     */                                                       
    void GetDefaultOutputTsStandard(in unsigned short Board, out eTableStandard_t eStandard)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /**
     * Transport stream specific Output TS Standard setting parameters. 
     */
    struct OutTsStandard_t
    {
      IPS_RefTS_t RefTs;
      eTableStandard_t eStandard;
    };

    /// A sequence of OutTsStandard_t.
    typedef sequence<OutTsStandard_t> OutTsStandardList_t;

    /** Set Output TS Standard for some OutTS.
     * 
     * @param[in] RefPhys The port the OutTS are attached to. 
     * @param[in] lst     List of RefTs/eStandard pairs
     *
     * @exception OpNotSupported When called for main board.
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist.
     * - eStandard is invalid.
     * - RefTs does not match RefPhys.
     *
     * @version Release 6.0 (PSIP)
     */
    void OutputTsStandardSetL(in IPS_Ref_t RefPhys, in OutTsStandardList_t lst)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get Output TS Standard for some OutTS.
     * 
     * @param[in] RefPhys    The port the OutTS are attached to. 
     * @param[in] RefTsList  List of References of OutTs for which to return the OutTsStandard_t Settings. 
     * Empty list equals all OutTs attached to RefPhys.
     * @param[out] lst List of RefTs/eTableStandard_t pairs
     * 
     * @exception OpNotSupported When called for main board.
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist.
     * - RefTs does not match RefPhys
     *
     * @version Release 6.0 (PSIP)
     */
    void OutputTsStandardGetL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList, out OutTsStandardList_t lst)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the GPS-UTC offset.
     * The GPS-UTC offset is the current offset in whole seconds between GPS and 
     * UTC time standards.
     * To convert GPS time to UTC, this offset is subtracted from the GPS time.
     * Whenever the National Bureau of Weights and Measures decides that the
     * current offset is too far in error, an additional leap second may be
     * added. When this happens, you should update your %DCM to reflect this.
     * The default value at the time of %DCM release 6.0 is 15.
     * This is a board level setting. To update the configuration, you have to
     * call this function on every I/O board of the %DCM.
     *
     * This setting is used for generating the PSIP STT.
     * 
     * @param[in] Board The Board for which to change the setting.
     * @param[in] Offset The new offset in seconds.
     * 
     * @exception OpNotSupported When called for main board.
     *
     * @version Release 6.0 (PSIP)
     */
    void SetGpsUtcOffset(in unsigned short Board, in unsigned short Offset)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the GPS-UTC offset.
     * 
     * @param[in] Board The Board for which to retrieve the setting.
     * @param[out] Offset The current offset in seconds.
     * 
     * @exception OpNotSupported When called for main board.
     *
     * @sa SetGpsUtcOffset
     *
     * @version Release 6.0 (PSIP)
     */
    void GetGpsUtcOffset(in unsigned short Board, out unsigned short Offset)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * Transport stream specific STT time zone setting. 
     */
    struct OutTS_SttTimeZone_t
    {
      IPS_RefTS_t RefTs;
      string TimeZone;
    };

    /// A sequence of OutTS_SttTimeZone_t.
    typedef sequence<OutTS_SttTimeZone_t> OutTS_SttTimeZone_List_t;

    /** Set STT time zone for some OutTS.
     * The time zone is used to calculate the DST fields in the STT.
     * The format of the time zone string is the same as for TOT.
     * An empty string means: Follow the %DCM's local time zone.
     * The default is an empty string.
     * 
     * @param[in] RefPhys The port the OutTS are attached to. 
     * @param[in] lst List of RefTs / time zone pairs
     *
     * @exception OpNotSupported When called for main board.
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist.
     * - RefTs does not match RefPhys.
     *
     * @version Release 6.0 (PSIP)
     */
    void OutTS_SttTimeZone_SetL(in IPS_Ref_t RefPhys, in OutTS_SttTimeZone_List_t lst)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get STT time zone for some OutTS.
     * The time zone is used to calculate the DST fields in the STT.
     * The format of the time zone string is the same as for TOT.
     * An empty string means: Follow the %DCM's local time zone.
     * The default is an empty string.
     * 
     * @param[in] RefPhys    The port the OutTS are attached to. 
     * @param[in] RefTsList  List of References of OutTs for which to return the STT time zone Settings. 
     *    Empty list means all OutTS attached to RefPhys.
     * @param[out] lst List of RefTs/time zone pairs
     *
     * @exception OpNotSupported When called for main board.
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist.
     * - RefTs does not match RefPhys.
     *
     * @version Release 6.0 (PSIP)
     */
    void OutTS_SttTimeZone_GetL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList, out OutTS_SttTimeZone_List_t lst)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    enum eTriBool
    {
      eTB_Transparent,  //  use input setting
      eTB_False,
      eTB_True
    };
    
    enum eVctModulation
    {
      eVctModulationMode_Transparent,  // use input setting
      eVctModulationMode_Analog,
      eVctModulationMode_Qam64,
      eVctModulationMode_Qam256,
      eVctModulationMode_Vsb8,
      eVctModulationMode_Vsb16
    };
    
    enum eVctEtmLocation  // remark: values are not according to the standard
    {
      eVctEtmLocation_Transparent,  //  use input setting
      eVctEtmLocation_NoEtm,
      eVctEtmLocation_InternalEtm,
      eVctEtmLocation_ExternalEtm
    };

    enum eVctServiceType
    {
      eVctServiceType_Transparent,  // use input setting
      eVctServiceType_Analog,
      eVctServiceType_Digital_television,
      eVctServiceType_Digital_audio,
      eVctServiceType_Digital_data
    };
    
    /** Structure that contains settings about the Virtual Channel Table of a service.
     */
    struct VCT_Data_t
    {
      eTriBool VCT_Present;                 ///< Follow Input, Generate (Present), Block (Not Present)
                                            ///< status: true = VCT fragment is present at input (either CVCT or TVCT)
      DvbString_t ShortName;                ///< setting: actually the service user name
                                            ///< status: the short name as taken from input
      MultipleString_t LongName;            ///< more describing channel name optionally passed as descriptor.  Empty string
      unsigned short MajorChannelNumber;    ///< first part of channel number (10 bits)
      unsigned short MinorChannelNumber;    ///< second part of channel number (10 bits)
      eVctModulation ModulationMode;        ///< see eVctModulation, defaults: if modulation is not according to table
      eVctEtmLocation ETM_Location;         ///< see VCT_ETMLOCATION_xxxx
      eTriBool AccessControlled;            ///< true: channel is scrambled
      eTriBool Hidden;                      ///< true: channel is inactive, should not be listed
      eTriBool PathSelect;                  ///< (CVCT only) false: path 1, true: path 2
      eTriBool OutOfBand;                   ///< (CVCT only) true: out of band physical transmission
      eTriBool HideGuide;                   ///< (only valid when hidden flag is true) true: program may not be listed in program guide
      eVctServiceType ServiceType;          ///< see VCT_SERVICETYPE_xxxx
      unsigned short SourceId;              ///< internal reference, used for ETT-V and EIT's
    };
        
    /// Structure that contains status about the Virtual Channel Table of a service on input.
    struct VCT_SvcInput_t
    {
      IPS_Service_t RefServ;
      VCT_Data_t Data;
    };
 
    /// A sequence of VCT_SvcInput_t.
    typedef sequence<VCT_SvcInput_t> VCT_SvcInput_List_t;
       
    /** Get VCT data for some input services.
     * 
     * @param[in] RefTS    The InputTS the services belong to.
     * @param[in] SidList  List of ServiceId's for which to return the VCT_Data. 
     *    Empty list: all Services of the TS.
     *    Invalid TS: all Services of the port.
     *    Invalid Port and TS: all services of the board.
     * @return VCT_SvcInput_List_t List of Service/VCT-data pairs
     *
     * @exception OpNotSupported When called for main board.
     * @exception OpNotSucceeded In case of
     * - RefTs not valid or does not exist.
     * - no ServiceId's found in the TS.
     *
     * @version Release 6.0 (PSIP)
     */
    VCT_SvcInput_List_t VCT_InputData_GetL(in IPS_RefTS_t RefTS, in ServiceIdList_t SidList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    struct VCT_Forcing_t
    {
      boolean ForceUserName;      ///< true = use service user name as short name, false = use input short name
      boolean ForceLongName;      ///< true = use filled in long name, false = use input long name
      boolean ForceChannelNumber; ///< true = use filled in channel number, false = use input channel number
      boolean ForceSourceId;      ///< true = use filled in source id, false = use input source id
    };

    /** Structure combining service-id with settings.
     */
    struct VCT_SvcSetting_t
    {
      IPS_Service_t RefServ;
      VCT_Data_t Setting;
      VCT_Forcing_t Forcing;
    };

    /** A sequence of VCT_Setting_t. */
    typedef sequence<VCT_SvcSetting_t> VCT_SvcSetting_List_t;

    /** Structure that contains status about the Virtual Channel Table of a service.
     *  Introduced to bundle the settings and status when getting VCT information.
     */
    struct VCT_SvcData_t
    {
      VCT_SvcSetting_t Setting;
      VCT_Data_t Input;
    };

    /// A sequence of VCT_Data_t.
    typedef sequence<VCT_SvcData_t> VCT_SvcData_List_t;

    /** Get CVCT data (settings and input) for some output services.
     * 
     * @param[in] RefTS    The OutTS the services belong to. 
     * @param[in] SidList  List of ServiceId's for which to return the VCT_Data. 
     *    Empty list means all Services of the TS.
     *    Invalid TS: all Services of the port.
     *    Invalid Port and TS: all services of the board.
     * @return VCT_SvcData_List_t List of Service/VCT-data pairs
     *
     * @exception OpNotSupported When called for main board.
     * @exception OpNotSucceeded In case of
     * - RefTs not valid or does not exist.
     * - no ServiceId's found for in the TS.
     *
     * @version Release 6.0 (PSIP)
     */
    VCT_SvcData_List_t CVCT_OutputData_GetL(in IPS_RefTS_t RefTS, in ServiceIdList_t SidList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Get TVCT data (settings and input) for some output services.
     * 
     * @param[in] RefTS    The OutTS the services belong to. 
     * @param[in] SidList  List of ServiceId's for which to return the VCT_Data. 
     *    Empty list means all Services of the TS.
     *    Invalid TS: all Services of the port.
     *    Invalid Port and TS: all services of the board.
     * @return VCT_SvcData_List_t List of Service/VCT-data pairs
     *
     * @exception OpNotSupported When called for main board.
     * @exception OpNotSucceeded In case of
     * - RefTs not valid or does not exist.
     * - no ServiceId's found for in the TS.
     *
     * @version Release 6.0 (PSIP)
     */
    VCT_SvcData_List_t TVCT_OutputData_GetL(in IPS_RefTS_t RefTS, in ServiceIdList_t SidList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);        
        
    /** Set CVCT settings for some output services.
     * 
     * @param[in] RefTS    The OutTS the services belong to. 
     * @param[out] lst List of Services with its settings.
     *      An empty list is not allowed
     *
     * @exception OpNotSupported When called for main board.
     * @exception OpNotSucceeded In case of
     * - RefTs does not exist.
     * - an empty list is passed.
     * - a ServiceId is not found for in the TS.
     * - a RefSvc doesn't match RefTS
     * - invalid settings are given
     *
     * @version Release 6.0 (PSIP)
     */
    void CVCT_OutputData_SetL(in IPS_RefTS_t RefTS, in VCT_SvcSetting_List_t lst)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set TVCT settings for some output services.
     * 
     * @param[in] RefTS    The OutTS the services belong to. 
     * @param[out] lst List of Services with its settings.
     *      An empty list is not allowed
     *
     * @exception OpNotSupported When called for main board.
     * @exception OpNotSucceeded In case of
     * - RefTs does not exist.
     * - an empty list is passed.
     * - a ServiceId is not found for in the TS.
     * - a RefSvc doesn't match RefTS
     * - invalid settings are given
     *
     * @version Release 6.0 (PSIP)
     */        
    void TVCT_OutputData_SetL(in IPS_RefTS_t RefTS, in VCT_SvcSetting_List_t lst)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
  
    /**
     * Transport stream specific "Service Location Added" setting parameters. 
     */
    struct OutTsServiceLocationAdded_t
    {
      IPS_RefTS_t RefTs;
      boolean Added;
    };

    typedef sequence<OutTsServiceLocationAdded_t> OutTsServiceLocationAddedList_t;

    /** Set per TS whether the service location descriptor must be added per CVCT fragment.
     * 
     * @param[in] RefPhys   The port the OutTS are attached to. 
     * @param[in] AddedList List of RefTs/boolean pairs
     *
     * @exception OpNotSupported When called for main board.
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist or is not an output Port.
     * - RefTs does not match RefPhys or does not exist.
     *
     * @version Release 6.0 (PSIP)
     */
    void CVCT_ServiceLocationAddedSetL(in IPS_Ref_t RefPhys, in OutTsServiceLocationAddedList_t AddedList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get per TS whether the service location descriptor must be added per CVCT fragment.
     * 
     * @param[in] RefPhys    The port the OutTS are attached to. 
     * @param[in] RefTsList  List of References of OutTs for which to return the OutTsStandard_t Settings. 
     *                       Empty list equals all OutTs attached to RefPhys.
     * @param[out] AddedList List of RefTs/boolean pairs
     * 
     * @exception OpNotSupported When called for main board.
     * @exception OpNotSucceeded In case of
     * - RefTs does not exist or is not an output TS.
     * - RefPhys does not exist or is not an output Port.
     *
     * @version Release 6.0 (PSIP)
     */
    void CVCT_ServiceLocationAddedGetL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList, out OutTsServiceLocationAddedList_t AddedList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);    
    
    /** Set per TS whether the service location descriptor must be added per TVCT fragment.
     * 
     * @param[in] RefPhys   The port the OutTS are attached to. 
     * @param[in] AddedList List of RefTs/boolean pairs
     *
     * @exception OpNotSupported When called for main board.
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist or is not an output Port.
     * - RefTs does not match RefPhys or does not exist.
     *
     * @version Release 6.0 (PSIP)
     */
    void TVCT_ServiceLocationAddedSetL(in IPS_Ref_t RefPhys, in OutTsServiceLocationAddedList_t AddedList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get per TS whether the service location descriptor must be added per TVCT fragment.
     * 
     * @param[in] RefPhys    The port the OutTS are attached to. 
     * @param[in] RefTsList  List of References of OutTs for which to return the ServiceLocationAdded Settings. 
     *                       Empty list equals all OutTs attached to RefPhys.
     * @param[out] AddedList List of RefTs/boolean pairs
     * 
     * @exception OpNotSupported When called for main board.
     * @exception OpNotSucceeded In case of
     * - RefTs does not exist or is not an output TS.
     * - RefPhys does not exist or is not an output Port.
     *
     * @version Release 6.0 (PSIP)
     */
    void TVCT_ServiceLocationAddedGetL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList, out OutTsServiceLocationAddedList_t AddedList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    struct OutTS_PsipEitStartPid_t
    {
      IPS_RefTS_t    RefTs;
      unsigned short StartPid;
    };
        
    typedef sequence<OutTS_PsipEitStartPid_t> OutTS_PsipEitStartPidList_t;    
    
    struct OutTS_PsipEttStartPid_t
    {
      IPS_RefTS_t    RefTs;
      unsigned short StartPid;
    };
        
    typedef sequence<OutTS_PsipEttStartPid_t> OutTS_PsipEttStartPidList_t;

    /** Number of tables follows input.
     *  @version release 8.9
     */
    const unsigned short PSIP_REGENERATION_FOLLOW_INPUT = 0xffff;
    
    /** Set the default output PSIP-EIT start PID.
     *
     * @param[in] Board     specifies BoardNr.
     * @param[in] StartPid  specifies the new default.
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case the given start PID is not in range for 
     *                           a valid PSIP-EIT start PID [0x0020 - 0x1FFF]
     *
     * @version Release 6.0
     */    
    void SetDefault_PsipEitStartPid(in unsigned short Board, in unsigned short StartPid)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Get the default output PSIP-EIT start PID.
     * 
     * @param[in]  Board     specifies BoardNr.
     * @param[out] StartPid  The current setting of the start PID. 
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     *
     * @version Release 6.0
     */          
    void GetDefault_PsipEitStartPid(in unsigned short Board, out unsigned short StartPid)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Set the default output PSIP-ETT start PID.
     *
     * @param[in] Board     specifies BoardNr.
     * @param[in] StartPid  specifies the new default.
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case the given start PID is not in range for 
     *                           a valid PSIP-ETT start PID [0x0020 - 0x1FFF]
     *
     * @version Release 6.5
     */    
    void SetDefault_PsipEttStartPid(in unsigned short Board, in unsigned short StartPid)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Get the default output PSIP-ETT start PID.
     * 
     * @param[in]  Board     specifies BoardNr.
     * @param[out] StartPid  The current setting of the start PID. 
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     *
     * @version Release 6.5
     */          
    void GetDefault_PsipEttStartPid(in unsigned short Board, out unsigned short StartPid)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Set Output TS PSIP-EIT start PID for some OutTS.
     * 
     * @param[in] RefPhys       The port the OutTS are attached to. 
     * @param[in] StartPidList  List of RefTs/OutTS_PsipEitStartPid_t pairs
     *
     * @exception OpNotSupported When called for main board.
     * @exception OpNotSucceeded In case the 
     * - RefPhys does not exist.
     * - StartPid is not in the valid range. [0x0020 - 0x1FFF]
     * - RefTs does not match RefPhys.
     *
     * @version Release 6.0
     */        
    void OutTS_PsipEitStartPid_SetL(in IPS_Ref_t RefPhys, in OutTS_PsipEitStartPidList_t StartPidList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);    
    
    /** Get Output TS PSIP-EIT start PID for some OutTS.
     * 
     * @param[in]   RefPhys       The port the OutTS are attached to. 
     * @param[in]   RefTsList     List of References of OutTs for which to return 
     *                            the start PID Settings. 
     * @param[out]  StartPidList  List start PID / refTS pairs.
     * 
     * @exception  OpNotSupported  When called for main board.
     * @exception  OpNotSucceeded  In case of
     *                              - RefPhys does not exist.
     *                              - RefTs does not match RefPhys
     *
     * @version Release 6.0
     */        
    void OutTS_PsipEitStartPid_GetL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList, out OutTS_PsipEitStartPidList_t StartPidList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Set Output TS PSIP-ETT start PID for some OutTS.
     * 
     * @param[in] RefPhys       The port the OutTS are attached to. 
     * @param[in] StartPidList  List of RefTs/OutTS_PsipEttStartPid_t pairs
     *
     * @exception OpNotSupported When called for main board.
     * @exception OpNotSucceeded In case the 
     * - RefPhys does not exist.
     * - StartPid is not in the valid range. [0x0020 - 0x1FFF]
     * - RefTs does not match RefPhys.
     *
     * @version Release 6.5
     */        
    void OutTS_PsipEttStartPid_SetL(in IPS_Ref_t RefPhys, in OutTS_PsipEttStartPidList_t StartPidList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);    
    
    /** Get Output TS PSIP-ETT start PID for some OutTS.
     * 
     * @param[in]   RefPhys       The port the OutTS are attached to. 
     * @param[in]   RefTsList     List of References of OutTs for which to return 
     *                            the start PID Settings. 
     * @param[out]  StartPidList  List start PID / refTS pairs.
     * 
     * @exception  OpNotSupported  When called for main board.
     * @exception  OpNotSucceeded  In case of
     *                              - RefPhys does not exist.
     *                              - RefTs does not match RefPhys
     *
     * @version Release 6.5
     */        
    void OutTS_PsipEttStartPid_GetL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList, out OutTS_PsipEttStartPidList_t StartPidList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Set the default number of regenerated PSIP-EIT subtables.
     *
     * @param[in] Board       specifies BoardNr.
     * @param[in] NbrOfTables specifies the new default.Use of
     *                        PSIP_REGENERATION_FOLLOW_INPUT is allowed.
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case NbrOfTables is not in the valid range.
     *                           The valid range is equal to [0,128]
     *
     * @version release 6.0
     */
    void SetDefault_PsipEitRegeneration(in unsigned short Board, in unsigned short NbrOfTables)  
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);         
        
    /** Get the default number of regenerated PSIP-EIT subtables.
     * 
     * @param[in]  Board        specifies BoardNr.
     * @param[out] NbrOfTables  The current setting of the board default PSIP-EIT
     *                          regeneration. Can be PSIP_REGENERATION_FOLLOW_INPUT.
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     *
     * @version Release 6.0
     */          
    void GetDefault_PsipEitRegeneration(in unsigned short Board, out unsigned short NbrOfTables)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);        
        
    /** Set the default number of regenerated PSIP-ETT subtables.
     *
     * @param[in] Board       specifies BoardNr.
     * @param[in] NbrOfTables specifies the new default.Use of
     *                        PSIP_REGENERATION_FOLLOW_INPUT is allowed.
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case NbrOfTables is not in the valid range.
     *                           The valid range is equal to [0,128]
     *
     * @version release 6.5
     */
    void SetDefault_PsipEttRegeneration(in unsigned short Board, in unsigned short NbrOfTables)  
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);         
        
    /** Get the default number of regenerated PSIP-ETT subtables.
     * 
     * @param[in]  Board        specifies BoardNr.
     * @param[out] NbrOfTables  The current setting of the board default PSIP-ETT
     *                          regeneration. Can be PSIP_REGENERATION_FOLLOW_INPUT.
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     *
     * @version Release 6.5
     */          
    void GetDefault_PsipEttRegeneration(in unsigned short Board, out unsigned short NbrOfTables)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);        
        
    /** Structure combining service information with the number of regenerated 
     *  PSIP-EIT subtables. The member NbrOfTables can be set to
     *  PSIP_REGENERATION_FOLLOW_INPUT.
     */
    struct Svc_PsipEitRegenerationInfo_t
    {
      IPS_Service_t  RefServ;
      unsigned short NbrOfTables;
    };
    
    /// A sequence of Svc_PsipEitRegenerationInfo_t
    typedef sequence<Svc_PsipEitRegenerationInfo_t> Svc_PsipEitRegenerationInfoList_t;
    
    /** Structure combining service information with the number of regenerated 
     *  PSIP-ETT subtables
     */
    struct Svc_PsipEttRegenerationInfo_t
    {
      IPS_Service_t  RefServ;
      unsigned short NbrOfTables;
    };
    
    /// A sequence of Svc_PsipEttRegenerationInfo_t
    typedef sequence<Svc_PsipEttRegenerationInfo_t> Svc_PsipEttRegenerationInfoList_t;
    
    /** Set Output Service PSIP-EIT Regeneration info
     * 
     * @param[in] RefTs The Output TS the services are attached to.
     * @param[in] PsipEitRegenerationInfoList List with settings to apply
     * 
     * @exception  OpNotSupported when BoardNr = 0 = Main board.
     * @exception  OpNotSucceeded In case of
     * - RefTs does not exist.
     * - an empty list is passed.
     * - a ServiceId is not found in the TS.
     * - a RefSvc doesn't match RefTS
     * - the given setting is not in the range of a valid number of regenerated
     *   PSIP-EIT tables. The valid range is equal to [0,128]
     *
     * @version Release 6.0
     */       
    void SetPsipEitRegeneration(in IPS_RefTS_t RefTs, in Svc_PsipEitRegenerationInfoList_t PsipEitRegenerationInfoList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);      
    
    /** Get Output Service PSIP-EIT Regeneration info
     * 
     * @param[in] RefTs          The Output TS the services are attached to.
     * @param[in] SidList        List of Services to return the regeneration settings of.
     * @return    Svc_PsipEitRegenerationInfoList_t  
     * 
     * @exception  OpNotSupported when BoardNr = 0 = Main board.
     * @exception  OpNotSucceeded In case the
     * - RefTs not valid or does not exist.
     * - no ServiceId's found for in the TS.
     *
     * @version Release 6.0
     */           
    Svc_PsipEitRegenerationInfoList_t GetPsipEitRegeneration(in IPS_RefTS_t RefTs, in ServiceIdList_t SidList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);    
        
    /** Set Output Service PSIP-ETT Regeneration info
     * 
     * @param[in] RefTs The Output TS the services are attached to.
     * @param[in] PsipEttRegenerationInfoList List with settings to apply
     * 
     * @exception  OpNotSupported when BoardNr = 0 = Main board.
     * @exception  OpNotSucceeded In case of
     * - RefTs does not exist.
     * - an empty list is passed.
     * - a ServiceId is not found in the TS.
     * - a RefSvc doesn't match RefTS
     * - the given setting is not in the range of a valid number of regenerated
     *   PSIP-ETT tables. The valid range is equal to [0,128]
     *
     * @version Release 6.5
     */       
    void SetPsipEttRegeneration(in IPS_RefTS_t RefTs, in Svc_PsipEttRegenerationInfoList_t PsipEttRegenerationInfoList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);      
    
    /** Get Output Service PSIP-ETT Regeneration info
     * 
     * @param[in] RefTs          The Output TS the services are attached to.
     * @param[in] SidList        List of Services to return the regeneration settings of.
     * @return    Svc_PsipEttRegenerationInfoList_t  
     * 
     * @exception  OpNotSupported when BoardNr = 0 = Main board.
     * @exception  OpNotSucceeded In case the
     * - RefTs not valid or does not exist.
     * - no ServiceId's found for in the TS.
     *
     * @version Release 6.5
     */           
    Svc_PsipEttRegenerationInfoList_t GetPsipEttRegeneration(in IPS_RefTS_t RefTs, in ServiceIdList_t SidList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);    
        
    struct OutTS_PsipEttvPid_t
    {
      IPS_RefTS_t    RefTs;
      unsigned short Pid;
    };

    typedef sequence< OutTS_PsipEttvPid_t > OutTS_PsipEttvPid_List_t;

    /** Set the default output PSIP-ETTV PID.
     *
     * @param[in] Board specifies BoardNr.
     * @param[in] Pid   specifies the new default.
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case the given PID is not in range for 
     *                           a valid PSIP-ETTV PID [0x0020 - 0x1FFF]
     *
     * @version Release 6.5
     */    
    void SetDefaultPsipEttvPid(in unsigned short Board, in unsigned short Pid)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the default output PSIP-ETTV PID.
     * 
     * @param[in]  Board specifies BoardNr.
     * @param[out] Pid   The current setting of the PID. 
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     *
     * @version Release 6.5
     */          
    void GetDefaultPsipEttvPid(in unsigned short  Board, out unsigned short Pid)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set Output TS PSIP-ETTV PID for some OutTS.
     * 
     * @param[in] RefPhys The port the OutTS are attached to. 
     * @param[in] PidList List of RefTs/PID pairs.
     *
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case the 
     * - RefPhys does not exist.
     * - Pid is not in the valid range [0x0020 - 0x1FFF].
     * - RefTs does not match RefPhys.
     *
     * @version Release 6.5
     */        
    void OutTS_PsipEttvPid_SetL(in IPS_Ref_t RefPhys, in OutTS_PsipEttvPid_List_t PidList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get Output TS PSIP-ETTV PID for some OutTS.
     * 
     * @param[in]   RefPhys       The port the OutTS are attached to. 
     * @param[in]   RefTsList     List of References of OutTs for which to return 
     *                            the PID Settings. 
     * @param[out]  PidList  List of RefTs/PID pairs.
     * 
     * @exception  OpNotSupported  When called for main board.
     * @exception  OpNotSucceeded  In case of
     *                              - RefPhys does not exist.
     *                              - RefTs does not match RefPhys.
     *
     * @version Release 6.5
     */        
    void OutTS_PsipEttvPid_GetL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList, out OutTS_PsipEttvPid_List_t PidList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Structure combining service-id with settings.
     */
    struct ETTV_ContentSetting_t
    {
      IPS_Service_t RefServ;
      MultipleString_t Content;
      boolean Forcing;
    };

    /** A sequence of ETTV_ContentSetting_t. */
    typedef sequence< ETTV_ContentSetting_t > ETTV_ContentSetting_List_t;

    /** Structure that contains status about the Content of an ETTV.
     *  Introduced to bundle the settings and status when getting ETTV content information.
     */
    struct ETTV_ContentData_t
    {
      ETTV_ContentSetting_t Setting;
      MultipleString_t Input;
    };

    /// A sequence of ETTV_ContentData_t.
    typedef sequence<ETTV_ContentData_t> ETTV_ContentData_List_t;

    /** Set Output Data for PSIP-ETTV.
     * 
     * @param[in] RefTS The TS the Services are attached to. 
     * @param[in] lst List of RefServ/Content/Forcing.
     *
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case the 
     * - RefTS does not exist.
     * - Invalid values in the content.
     * - RefServ does not match RefTS.
     *
     * @version Release 6.5
     */        
    void ETTV_OutputData_SetL(in IPS_RefTS_t RefTS, in ETTV_ContentSetting_List_t lst)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get Output Data for PSIP-ETTV.
     * 
     * @param[in] RefTS The TS the Services are attached to. 
     * @param[in] SidList list of services. 
     * @return ETTV_ContentData_List_t.
     *
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case the 
     * - RefTS does not exist.
     * - RefServ does not match RefTS.
     *
     * @version Release 6.5
     */        
    ETTV_ContentData_List_t ETTV_OutputData_GetL(in IPS_RefTS_t RefTS, in ServiceIdList_t SidList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);        


    struct PsipMgtInfo_t
    {
      unsigned short PID;
      unsigned short TableType;
      unsigned short VersionNumber;
    };
    
    typedef sequence<PsipMgtInfo_t> PsipMgtInfoList_t;
    
    struct TS_PsipMgtInfo_t
    {
      IPS_RefTS_t        RefTs;
      PsipMgtInfoList_t  PsipMgtInfoList;
    };
    
    typedef sequence<TS_PsipMgtInfo_t> TS_PsipMgtInfoList_t;
    
    /** Get PSIP-MGT TS inventory at the output
     * This will give you a list of all PSIP tables which are available. Tables
     * are only included if they are referenced in the MGT. Tabes which are
     * referenced in the MGT are: VCT, EIT, ETT, RRT.
     * You can filter the list by including a Table ID. Only tables with this
     * table ID will be returned. This is useful to retrieve a list of EIT
     * tables or a list of RRT tables. To find out which RRT tables are
     * available, use table ID 0xCA. To get a list of EIT tables, use table ID
     * 0xCB.
     * The Table Type which is returned is a table type as used in the MGT.
     * For EIT, table types range from 0x100 (EIT-0) to 0x17F (EIT-127).
     * For ETT, table types range from 0x200 (ETT-0) to 0x27F (ETT-127).
     * For RRT, table types range from 0x301 (region 1) to 0x3FF (region 255).
     * 
     * @param[in] RefPhys    The port the OutTS are attached to. 
     * @param[in] RefTsList  List of References of OutTs for which to return the MGT inventory. 
     *                       Empty list means all OutTs attached to RefPhys.
     * @param[in] TableId        Table ID filter, use 0xFFFFFFFF for all tables.
     * @return    TS_PsipMgtInfoList_t  
     * 
     * @exception  OpNotSupported  When called for main board.
     * @exception  OpNotSucceeded  In case of
     *                              - RefPhys does not exist.
     *                              - RefTs does not match RefPhys.
     *
     * @version Release 6.0
     */    
    TS_PsipMgtInfoList_t OutTS_MgtInventory_GetL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList, in unsigned long TableId)    
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Get PSIP-MGT TS inventory at the input
     * For more information, see OutTS_MgtInvertory_GetL.
     * 
     * @param[in] RefPhys    The port the InTS are attached to. 
     * @param[in] RefTsList  List of References of InTs for which to return the MGT inventory. 
     *                       Empty list means all InTs attached to RefPhys.
     * @param[in] TableId    Table ID filter, use 0xFFFFFFFF for all tables.
     * @return    TS_PsipMgtInfoList_t  
     * 
     * @exception  OpNotSupported  When called for main board.
     * @exception  OpNotSucceeded  In case of
     *                              - RefPhys does not exist.
     *                              - RefTs does not match RefPhys.
     *
     * @sa OutTS_MgtInvertory_GetL
     *
     * @version Release 6.0
     */    
    TS_PsipMgtInfoList_t InTS_MgtInventory_GetL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList, in unsigned long TableId)    
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);        
        

    /// @} end of group PSIP
    
    /// @} end of group mux
#endif // DISABLE_OTHERS
#ifndef DISABLE_BITRATES
    /** @defgroup bitrates Bitrate
     * This module contains types, enums and methods related to bitrate measurements.
     * @{
     */
    
    // Bitrate structures & enums
    // ------------------------------------------------------------------------------------
    /** General structure to hold bitrate measurement data. 
     *
     */
    struct BitRateMeasurement_t
    {
      unsigned long CurBitRate; ///< Current BitRate: 1 bit/s resolution - max 2 ^ 32-1
      unsigned long AvgBitRate; 
      unsigned long MinBitRate;
      unsigned long MaxBitRate;
    };

    struct TS_BitRateMeasurement_t
    {
      IPS_RefTS_t RefTS;
      BitRateMeasurement_t TotalRate;
      BitRateMeasurement_t StuffingRate;
    };
    
    /// A sequence of TS_BitRateMeasurement_t.
    typedef sequence <TS_BitRateMeasurement_t> TS_BitRateMeasurementList_t;
    
    struct ServiceBitRateMeasurement_t
    {
      IPS_Service_t Service;
      BitRateMeasurement_t Rate;
    };
    
    /// A sequence of ServiceBitRateMeasurement_t.
    typedef sequence <ServiceBitRateMeasurement_t> ServiceBitRateMeasurementList_t;

    struct TS_CompBitRateMeasurement_t
    {
      IPS_RefTS_t RefTS;
      unsigned short PID;
      string strCompType;         ///< PAT, SDT.
      BitRateMeasurement_t Rate;
    };
    
    /// A sequence of TS_CompBitRateMeasurement_t.
    typedef sequence <TS_CompBitRateMeasurement_t> TS_CompBitRateMeasurementList_t;

    struct ServiceCompBitRateMeasurement_t
    {
      IPS_Service_t Service;      
      unsigned short PID;
      string strCompType;         ///< PMT, ES, ES_ECM, ECM.
      octet ES_Type;              ///< dvb streamtype.   
      string strEsType;           ///< Interpretation of Es_Type in regard to m_EsTypeStandard of the TS. Read only.
      BitRateMeasurement_t Rate;
    };

    /// A sequence of ServiceCompBitRateMeasurement_t.
    typedef sequence <ServiceCompBitRateMeasurement_t> ServiceCompBitRateMeasurementList_t;

    
    /** A sequence of longs.
     * @note We've abandoned the idea to add an extra timer index. By sending 150 samples
     * each time zeroes will indicate missing measurements.
     */
    typedef sequence <unsigned long> BitRateSampleList_t;
    
    struct ServiceBitRateSample_t
    {
      IPS_Service_t Service;
      BitRateSampleList_t Sample;
    };
    
    /// A sequence of ServiceBitRateSample_t.
    typedef sequence <ServiceBitRateSample_t> ServiceBitRateSampleList_t;
    
    struct TRBitRateSample_t
    {
      IPS_Ref_t Ref;   ///< Identifies the unique location (Board, Port).
      unsigned long GroupID;
      BitRateSampleList_t Sample;
    };
    
    /// A sequence of TRBitRateSample_t.
    typedef sequence <TRBitRateSample_t> TRBitRateSampleList_t;
    
    struct TR_BitRateMeasurement_t
    {
       IPS_Ref_t PhysRef;
       unsigned long GroupID;
       BitRateMeasurement_t TotalRate;
       BitRateMeasurement_t StuffingRate;
    };
    
    /// A sequence of TR_BitRateMeasurement_t.
    typedef sequence <TR_BitRateMeasurement_t> TR_BitRateMeasurementList_t;
    
    // Bitrate IDL methods
    // ------------------------------------------------------------------------------------
    /** Get the bitrate information of incoming TS
     *
     * @param[in] RefTS Specifies BoardNr, PortNr & Ref to get the bitrates of.
     *
     * @return TS_BitRateMeasurementList_t A list of TS_BitRateMeasurement_t holding the requested bitrate information.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main Board.
     * @exception OpNotSucceeded In case invalid PhysRef (board or port) are used.
     *
     * @note
     * - The value 0xFFFF for PortNr and the value 0xFFFFFFFF for Ref means get the bitrate information of all TS on all InputPorts.
     * - The value 0xFFFF for PortNr and a valid Ref means search all InputPorts to find the TSref to get the bitrate from.
     * - A valid PortNr and the value 0xFFFFFFFF for Ref means get the bitrate information of all TSs on the specified InputPort.
     * - In case the board and port are valid and the Ref is invalid (and != 0xFFFFFFFF) an empty list will be returned.
     */
    TS_BitRateMeasurementList_t MM_GetInputTS_BitRate( in IPS_RefTS_t RefTS)  
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);    
    
    /** Get the bitrate information of outgoing TS
     *
     * @param[in] RefTS Specifies BoardNr, PortNr & Ref to get the bitrates of.
     *
     * @return TS_BitRateMeasurementList_t A list of TS_BitRateMeasurement_t holding the requested bitrate information.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main Board.
     * @exception OpNotSucceeded In case invalid PhysRef (board or port) are used.
     *
     * @note
     * - The value 0xFFFF for PortNr and the value 0xFFFFFFFF for Ref means get the bitrate information of all TS on all OutputPorts.
     * - The value 0xFFFF for PortNr and a valid Ref means search all OutputPorts to find the TSref to get the bitrate from.
     * - A valid PortNr and the value 0xFFFFFFFF for Ref means get the bitrate information of all TSs on the specified OutputPort.
     * - In case the board and port are valid and the Ref is invalid (and != 0xFFFFFFFF) an empty list will be returned.
     */
    TS_BitRateMeasurementList_t MM_GetOutputTS_BitRate( in IPS_RefTS_t RefTS) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get the service bitrate information of incoming services. 
     *
     * @param[in] RefTS Specifies BoardNr, PortNr & Ref to get the bitrates of.
     * @return ServiceBitRateMeasurementList_t A list of ServiceBitRateMeasurement_t holding the requested bitrate information.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main Board.
     * @exception OpNotSucceeded In case invalid PhysRef (board or port) are used.
     *
     * @note
     * - The value 0xFFFF for PortNr and the value 0xFFFFFFFF for Ref means get the bitrate information of all services of all TSs on all InputPorts.
     * - The value 0xFFFF for PortNr and a valid Ref means search all InputPorts to find the TSref to get the service bitrates from.
     * - A valid PortNr and the value 0xFFFFFFFF for Ref means get the bitrate information of all the services of all the TSs on the specified InputPort.
     * - In case the board and port are valid and the Ref is invalid (and != 0xFFFFFFFF) an empty list will be returned.
     */
    ServiceBitRateMeasurementList_t MM_GetInputTS_ServiceBitRate( in IPS_RefTS_t RefTS) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get the service bitrate information of outgoing services. 
     *
     * @param[in] RefTS Specifies BoardNr, PortNr & Ref to get the bitrates of.
     *
     * @return ServiceBitRateMeasurementList_t A list of ServiceBitRateMeasurement_t holding the requested bitrate information.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main Board.
     * @exception OpNotSucceeded In case invalid PhysRef (board or port) are used.
     *
     * @note
     * - The value 0xFFFF for PortNr and the value 0xFFFFFFFF for Ref means get the bitrate information of all services of all TSs on all OutputPorts.
     * - The value 0xFFFF for PortNr and a valid Ref means search all OutputPorts to find the TSref to get the service bitrates from.
     * - A valid PortNr and the value 0xFFFFFFFF for Ref means get the bitrate information of all the services of all the TSs on the specified OutputPort.
     * - In case the board and port are valid and the Ref is invalid (and != 0xFFFFFFFF) an empty list will be returned.
     */
    ServiceBitRateMeasurementList_t MM_GetOutputTS_ServiceBitRate( in IPS_RefTS_t RefTS) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get the component bitrate information of incoming TS's. 
     *
     * @param[in] RefTS Specifies BoardNr, PortNr & Ref to get the bitrates of.
     *
     * @return TS_CompBitRateMeasurementList_t A list of TS_CompBitRateMeasurement_t holding the requested bitrate information.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main Board.
     * @exception OpNotSucceeded In case invalid PhysRef (board or port) are used.
     *
     * @note
     * - The value 0xFFFF for PortNr and the value 0xFFFFFFFF for Ref means get the bitrate information of all TScomponents of all TSs on all InputPorts.
     * - The value 0xFFFF for PortNr and a valid Ref means search all OutputPorts to find the TSref to get the TScomponent bitrates from.
     * - A valid PortNr and the value 0xFFFFFFFF for Ref means get the bitrate information of all the TSComponents of all the TSs on the specified InputPort.
     * - In case the board and port are valid and the Ref is invalid (and != 0xFFFFFFFF) an empty list will be returned.
     */
    TS_CompBitRateMeasurementList_t MM_GetInputTS_ComponentBitRate( in IPS_RefTS_t RefTS) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get the component bitrate information of outgoing TS's. 
     *
     * @param[in] RefTS Specifies BoardNr, PortNr & Ref to get the bitrates of.
     *
     * @return TS_CompBitRateMeasurementList_t A list of TS_CompBitRateMeasurement_t holding the requested bitrate information.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main Board.
     * @exception OpNotSucceeded In case invalid PhysRef (board or port) are used.
     *
     * @note
     * - The value 0xFFFF for PortNr and the value 0xFFFFFFFF for Ref means get the bitrate information of all TScomponents of all TSs on all OutputPorts.
     * - The value 0xFFFF for PortNr and a valid Ref means search all OutputPorts to find the TSref to get the TScomponent bitrates from.
     * - A valid PortNr and the value 0xFFFFFFFF for Ref means get the bitrate information of all the TSComponents of all the TSs on the specified OutputPort.
     * - In case the board and port are valid and the Ref is invalid (and != 0xFFFFFFFF) an empty list will be returned.
     */
    TS_CompBitRateMeasurementList_t MM_GetOutputTS_ComponentBitRate( in IPS_RefTS_t RefTS) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get the component bitrate information of incoming services. 
     *
     * @param[in] RefTS Specifies BoardNr, PortNr & Ref to get the bitrates of.
     * @param[in] lstServices A list of service ID's. An empty list means all services.
     *
     * @return ServiceCompBitRateMeasurementList_t A list of ServiceCompBitRateMeasurement_t holding the requested bitrate information.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main Board.
     * @exception OpNotSucceeded In case invalid PhysRef (board or port) are used.
     *
     * @note
     * - The value 0xFFFF for PortNr and the value 0xFFFFFFFF for Ref means search all InputPorts for all TSs to find the service bitrates of the lstServices. 
     *    If the lstServices is empty all input service bitrates of the board will be returned.  
     * - The value 0xFFFF for PortNr and a valid Ref means search all InputPorts to find the TSref to get the service bitrates of the lstServices.
     *    If the lstSerivces is empty all input service bitrates of the TSref will be returned.
     * - A valid PortNr and the value 0xFFFFFFFF for Ref means search all TSs on the Port for the service bitrates of the lstServices.
     *    If the lstServices is empty all input service bitrates of the InputPort will be returned.
     * - In case the board and port are valid and the Ref is invalid (and != 0xFFFFFFFF) an empty list will be returned.
     */
    ServiceCompBitRateMeasurementList_t MM_GetInputSvcComponentBitRate( in IPS_RefTS_t RefTS, in ServiceIdList_t lstServices) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
  
    /** Get the component bitrate information of outgoing services. 
     *
     * @param[in] RefTS Specifies BoardNr, PortNr & Ref to get the bitrates of.
     * @param[in] lstServices A list of service ID's. An empty list means all services.
     *
     * @return ServiceCompBitRateMeasurementList_t A list of ServiceCompBitRateMeasurement_t holding the requested bitrate information.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main Board.
     * @exception OpNotSucceeded In case invalid PhysRef (board or port) are used.
     *
     * @note
     * - The value 0xFFFF for PortNr and the value 0xFFFFFFFF for Ref means search all OutputPorts for all TSs to find the service bitrates of the lstServices. 
     *    If the lstServices is empty all output service bitrates of the board will be returned.  
     * - The value 0xFFFF for PortNr and a valid Ref means search all OutputPorts to find the TSref to get the service bitrates of the lstServices.
     *    If the lstSerivces is empty all output service bitrates of the TSref will be returned.
     * - A valid PortNr and the value 0xFFFFFFFF for Ref means search all TSs on the Port for the service bitrates of the lstServices.
     *    If the lstServices is empty all output service bitrates of the OutputPort will be returned.
     * - In case the board and port are valid and the Ref is invalid (and != 0xFFFFFFFF) an empty list will be returned.
     */
    ServiceCompBitRateMeasurementList_t MM_GetOutputSvcComponentBitRate( in IPS_RefTS_t RefTS, in ServiceIdList_t lstServices) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);  
    
    /** Get the bitrate information of transrated services.
     *
     * @param[in] PhysRef Specifies BoardNr, PortNr to get the bitrates of.
     * @param[in] GroupID Specifies which the group the PIDs belong to. 
     * @param[in] InputServiceBitRate
     * @param[in] OutputServiceBitRate
     * @param[in] OutputGroupBitRate 
     *
     * @return InputServiceBitRate Requested input (before transrating) Service bitrate information.
     * @return OutputServiceBitRate Requested output (after transrating) Service bitrate information.
     * @return OutputGroupBitRate Requested output (after transrating) Transrater group bitrate information.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main Board.
     * @exception OpNotSucceeded In case invalid PhysRef (BoardNr PortNr) is used.
     *
     * @note
     * - In case the GroupID is Invalid empty lists are returned.
     */
    void MM_GetTR_GroupBitRate( in IPS_Ref_t PhysRef, in unsigned long GroupID, 
            out ServiceBitRateSampleList_t InputServiceBitRate, 
            out ServiceBitRateSampleList_t OutputServiceBitRate,
            out TRBitRateSample_t OutputGroupBitRate) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
            
    /** Reset bitrate counters.
     *
     * @param[in] RefTS Specifies BoardNr, PortNr & Ref to reset the bitrates of.
     * @param[in] bInput Specifies the input(true) or output(false) TS.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main Board.
     * @exception OpNotSucceeded In case invalid PhysRef (board or port) are used.
     *
     * @note
     * -  There are two types of bitrate reset:
     *      1. Reset the current values per (In or Output)TS (TS, Services and Pids) and not the history.
     *         How to activate: BoardNr =  valid, PortNr = valid, Ref = valid, bInput = valid. 
     *           
     *      2. Reset the complete bitratemodule of the board (Input and Output) including history.
     *         How to activate: BoardNr = valid, PortNr = 0xFFFF or = valid and the RefTS.Ref = 0xFFFFFFFF. 
     *         bInput has no infuence.
     */
    void MM_ResetTS_BitRate(in IPS_RefTS_t RefTS, in boolean bInput) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /// @} end of bitrates
#endif // DISABLE_BITRATES
#ifndef DISABLE_CLIP

    // Clip library
    ///////////////////////////////////////////////////////////////////////////////////////
    /** @defgroup cliplib Clip Library
     * This contains specific types, enums and methods for the clip library (used by slate and
     * logo insertion)
     * @{
     */
    typedef unsigned long ClipID_t;
    typedef sequence<ClipID_t> ClipID_List_t;

    struct SlateData_t
    {
      ClipID_t       ID;          // The unique clip Identifier
      string         Description; // A description for the Clip
      unsigned short Width;       // Horizontal Resolution;
      unsigned short Heigth;      // Vertical Resolution;
      unsigned short FrameRate;   // Framerate in milli-frames per second
      boolean        IsInUse;     // Indicates whether the clip is in use
    };
    typedef sequence<SlateData_t> SlateDataList_t;

    /** Add a slate clip to the clip library.
     *
     * @param[in]  BoardNr     The board on which to add the clip.
     * @param[in]  Description A description of the clip.
     * @param[in]  Clip        The clip data.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main
     * @exception OpNotSucceeded in case :
     * - the Clip is not a valid clip.
     * - No more entries available (maximum 512 clips in the library)
     *
     * @version Release 7.5
     **/
    void SlateLibrary_Add(in unsigned short BoardNr, in string Description, in ByteStream Clip)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Set the data for a slate clip in the clip library.
     *
     * @param[in]  BoardNr     The board on which to set the clip data
     * @param[in]  SlateDataL  A list of ClipData.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main
     * @exception OpNotSucceeded if ClipID in SlateData_t is not a valid clip id.
     *
     * @note Only the Description of the clip can be changed.
     *
     * @version Release 7.5
     **/
    void SlateLibrary_SetDataL(in unsigned short BoardNr, in SlateDataList_t SlateDataL)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get details about all slate clips in the library.
     *
     * @param[in]  BoardNr      The board on which to get the clip details.
     * @param[out] SlateDataList The list with data of all slate clips.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main
     * @exception OpNotSucceeded If the ClipID doesn't exist
     *
     * @version Release 7.5
     **/
    void SlateLibrary_GetDataL(in unsigned short BoardNr, out SlateDataList_t SlateDataList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Remove a slate clip from the clip library.
     *
     * @param[in]  BoardNr     The board on which to remove the clip.
     * @param[in]  SlateID_List A list of ClipID_t's of the clips to be deleted.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main
     * @exception OpNotSucceeded If the ClipID doesn't exist or the clip is still in use.
     *
     * @version Release 7.5
     **/
    void SlateLibrary_DeleteL(in unsigned short BoardNr, in ClipID_List_t SlateID_List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /// @} end of clip library
#endif // DISABLE_CLIP


    // Common Transcoder/MFP interface
    ///////////////////////////////////////////////////////////////////////////////////////      
    /** @defgroup transcoder Transcoder
     * This contains specific types, enums and methods for controling the transcoder part of the device.
     * @{
     */   

    /// Defines different modes for the Caption Service Descriptor.
    enum enTC_CaptionDescriptorMode_t
    {
      eTC_CaptionDescriptorMode_AutoMode,  ///< The Caption Service Descriptor will be passed to the output if present at the input. (factory default)
      eTC_CaptionDescriptorMode_AddMode,   ///< The Caption Service Descriptor is generated based on the input of the user.
      eTC_CaptionDescriptorMode_NoneMode,  ///< The Caption Service Descriptor will not be present at the output, even if present at the input.
      eTC_CaptionDescriptorMode_Reserved1, ///< future use undefined
      eTC_CaptionDescriptorMode_Reserved2, ///< future use undefined
      eTC_CaptionDescriptorMode_Reserved3  ///< future use undefined
    };    

    /** Configuration settings for a Closed Caption Service.
     */
    struct TC_CaptionInfo_t
    {
      string  LanguageCode;    ///< ISO_639_language_code. Fixed length of 3 bytes !
      boolean DigitalCC;       ///< 0 means line21 caption service
      boolean Line21_Field;    ///< Only interpreted if DigitalCC == 0. 0 means field 1, else field 2
      octet   CaptionSvcNbr;   ///< value in the range 1 to 63. Only interpreted if DigitalCC == 1
      boolean EasyReader;      ///< 1 means tailored for easy reading
      boolean WideAspectRatio; ///< 1 means 16:9 format; 0 means 4:3 format
    };
    typedef sequence<TC_CaptionInfo_t> TC_CaptionInfoList_t;

    /// @} end of Common Transcoder/MFP interface

    // Multi format processor (MFP)
    ///////////////////////////////////////////////////////////////////////////////////////

    /** @defgroup MFP Multi format processor (MFP)
     * This contains specific types, enums and methods for controlling the MFP part of the device.
     *
     * A quick overview of how the MFP IDL interface is typically used
     * ---------------------------------------------------------------
     *  - Configure the board to enable/disable audio processing: MFPB_GetBoardCfg/MFPB_SetBoardCfg
     *  - Check the available engine units (can depend on the audio processing mode, chassis, board version, ... ): MFPB_GetEngineUnitCfg
     *  - Configure the mode of the engine units e.g.: SD, HD, Mixed, Splice, ... : MFPB_SetEngineUnitCfg
     *  ...
     *  - Pass a service to the board (MFP will handle this as a delayed service): TC_ServiceAddL/ProcessorServiceAddL
     *  - Change MFP service settings e.g. the delay: MFPB_ServiceCfgGetL/MFPB_ServiceCfgSetL
     *  - To prepare processing, move the newly passed service to a slot on a engine unit: MFPB_ServiceCfgSetL/GetL
     *  - Check what components (PIDs) are processable, check if PIDs have matched with what settings: MFPB_ServiceComponentsGetL
     *  - Add decoders (with tracking ID = 0): MFPB_VideoDecodeCfgSetL, MFPB_AudioDecodeCfgSetL
     *  - Get tracking IDs of the newly added decoders: MFPB_VideoDecodeCfgGetL, MFPB_AudioDecodeCfgGetL
     *  - Add encoders with tracking ID of the respective decoders : MFPB_VideoEncodeCfgSetL, MFPB_AudioEncodeCfgSetL
     *  ...
     *  - Check what decoder/encoder settings have matched with what PID: MFPB_ServiceComponentsGetL
     *  - Check property bits if service/engine unit is processing: TC_ServiceGetL, MFPB_GetEngineUnitCfg
     *  - Check the decoder status: MFPB_VideoInformationGetL, MFPB_AudioInformationGetL
     *  ...
     *  - Optionally do some advanced settings (respective encoder must exist): MFPB_CaptionServiceCfgSetL/GetL, MFPB_AACAudioCfgSetL/GetL, MFPB_DolbyAudioCfgSetL/GetL
     *  - Optionally update decoder/encoder settings: MFPB_VideoDecodeCfgSetL, MFPB_AudioDecodeCfgSetL, MFPB_VideoEncodeCfgSetL, MFPB_AudioEncodeCfgSetL
     *  - Optionally move service between engine units or slots: MFPB_ServiceCfgSetL/GetL
     *  ...
     *  - Remove encoder. This will delete all but decoder settings (encoder, closed caption, AAC, Dolby, ... are deleted): MFPB_VideoEncodeCfgDeleteL, MFPB_AudioEncodeCfgDeleteL
     *  - Remove decoder. This will also delete all settings related to this tracking ID (encoder, closed caption, AAC, Dolby, ...): MFPB_VideoDecodeCfgDeleteL, MFPB_AudioDecodeCfgDeleteL
     *  - Remove service from MFP board (and all its settings eg, service, decoders, encoders, ... ): TC_ServiceDeleteL
     *  
     * @{
     */   
#ifndef DISABLE_MFP

    /** Request to restart the DCM_MFP application and restore the current state
     *
     * @version Release 10.0
     **/
    void MFP_RequestReset(in unsigned short BoardNr)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    ///< Description of how a Multi format processor (MFP) board should handle audio processing. Only used for 9900 chassis
    enum enMFPB_AudioProcessingMode_t
    {
      eMFPB_AudioProcessingMode_Disable,  /**< Audio processing is disabled on this board.(Default)
                                          * - 4 video engine units of type eMFPB_EngineUnitType_VideoAudio will be available
                                          *   these engine units can process only video.
                                          */
      eMFPB_AudioProcessingMode_Enable,   /**< Audio processing is enabled on this board.
                                          * - 3 video engine units of type eMFPB_EngineUnitType_VideoAudio will be available 
                                          *   these engine units can both process video and audio.
                                          * - 1 audio only engine unit of type eMFPB_EngineUnitType_AudioOnly will be available 
                                          *   this engine unit can only process audio.
                                          */
      eMFPB_AudioProcessingMode_Reserved3, ///< Reserved for future use      
      eMFPB_AudioProcessingMode_Reserved4, ///< Reserved for future use      
      eMFPB_AudioProcessingMode_Reserved5, ///< Reserved for future use      
      eMFPB_AudioProcessingMode_Reserved6, ///< Reserved for future use      
      eMFPB_AudioProcessingMode_Reserved7, ///< Reserved for future use      
      eMFPB_AudioProcessingMode_Reserved8  ///< Reserved for future use      
    }; 

    /** Structure to set/get transcoder board configuration.
     *
     * @version Release 10.0
     */
    struct MFPB_BoardCfg_t
    {
      enMFPB_AudioProcessingMode_t enMFPB_AudioProcessingMode; ///< How audio will be handled.
    };

    /** Get Board Configuration of a Multi format processor (MFP) board.      
     *
     * @param[in] SlotNbr          The slot number of a MFP board to retrieve the settings from
     * @param[out] MFPB_BoardCfg   The MFP board configuration.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a MFP board.
     * 
     * @version Release 10.0
     **/
    void MFPB_GetBoardCfg(in unsigned short SlotNbr, out MFPB_BoardCfg_t MFPB_BoardCfg)
      raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Apply a new Board Configuration on a Multi format processor (MFP) board.
     * This can cause interruptions in some or all processed streams.
     *
     * @param[in] SlotNbr          The slot number for the affected board
     * @param[in] MFPB_BoardCfg    The new board configuration
     * 
     * @exception OperationFailed
     * - Invalid board configuration
     * - Impossible to set mode without deleting audio or video components first
     *
     * @version Release 10.0
     **/
    void MFPB_SetBoardCfg(in unsigned short SlotNbr, in MFPB_BoardCfg_t MFPB_BoardCfg)
      raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Types of MFP resources
     *
     * @version Release 10.10
     */          
    enum enMFPB_Resources
    {
      eMFPB_Res_Audio,     ///< Audio resources
      eMFPB_Res_Reserved1, ///< Reserved for future use  
      eMFPB_Res_Reserved2, ///< Reserved for future use  
      eMFPB_Res_Reserved3, ///< Reserved for future use  
      eMFPB_Res_Reserved4, ///< Reserved for future use  
      eMFPB_Res_Reserved5, ///< Reserved for future use  
      eMFPB_Res_Reserved6, ///< Reserved for future use  
      eMFPB_Res_Reserved7, ///< Reserved for future use  
      eMFPB_Res_Reserved8, ///< Reserved for future use  
      eMFPB_Res_Reserved9  ///< Reserved for future use  
    };   

    /** Resource loads
     *
     * @version Release 10.10
     */
    struct ResourcesLoad_t
    {
      enMFPB_Resources   Resources; ///< The type of resources
      unsigned long      Load100;   ///< The relative load of resources times 100. If the value is 3456, the load is 34.56%.  
    };
    typedef sequence<ResourcesLoad_t> ResourcesLoad_List_t;

    /** Get measured load of MFP resources.
     *
     * @param[in]  BoardNr             The MFP board to retrieve the settings from.
     * @param[out] ResourcesLoad_List  List with the load of MFP resources.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a MFP board.
     *
     * @version Release 10.10
     **/
    void MFPB_GetMfpResourcesLoad(in unsigned short BoardNr, out ResourcesLoad_List_t ResourcesLoad_List)
            raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Identify a processing engine unit of a processor board.
     */
    struct RefProcessorEngineUnit_t
    {
      unsigned short EngineNr; /**< The processing engine.
                               * - Multi format processor (MFP) boards have 3 or 4 engines
                               *   (depending on the board level audio mode). EngineNr range: 0..3.
                               * - Multi format processor (MFP) 0xFFFE means delay engine
                               * - Multi format processor (MFP) 0xFFF0 means audio only  
                               */

      unsigned short UnitNr;   /**< The unit within a processing engine.
                               * - Multi format processor (MFP) boards have 1 unit per processing engine. UnitNr should always be 0.
                               */
    };
    typedef sequence<RefProcessorEngineUnit_t> RefProcessorEngineUnitList_t;    

    ///< Description of engine unit types (underlying hardware) for Multi format processor (MFP) boards. 
    enum enMFPB_EngineUnitType_t
    {
      eMFPB_EngineUnitType_VideoAudio,///< Video and or Audio processing (see MFPB_BoardCfg), on this engine a audio component will only be processed if the respective video is processed.
      eMFPB_EngineUnitType_AudioOnly, ///< On this engine you can only process audio. However services passed to this type can contain video, the video will be delayed with the same value.
      eMFPB_EngineUnitType_Reserved1, ///< Reserved for future use      
      eMFPB_EngineUnitType_Reserved2, ///< Reserved for future use      
      eMFPB_EngineUnitType_Reserved3, ///< Reserved for future use      
      eMFPB_EngineUnitType_Reserved4, ///< Reserved for future use      
      eMFPB_EngineUnitType_Reserved5, ///< Reserved for future use      
      eMFPB_EngineUnitType_Reserved6  ///< Reserved for future use      
    }; 

    ///< Description of engine unit modes for Multi format processor (MFP) boards.  
    enum enMFPB_EngineUnitMode_t
    {
      eMFPB_EngineUnitMode_SD_Transprocess,    ///< 6 SD transrating/coding of video + audio processing.
      eMFPB_EngineUnitMode_HD_Transprocess,    ///< 2 HD transrating/coding of video + audio processing.
      eMFPB_EngineUnitMode_SD_HD_Transprocess, ///< 3 SD and 1 HD transrating/coding of video + audio processing.
      eMFPB_EngineUnitMode_SD_Splice,          ///< 6 SD splicing and transrating/coding of video + audio processing.
      eMFPB_EngineUnitMode_HD_Splice,          ///< 1 HD splicing and transrating/coding of video + audio processing.
      eMFPB_EngineUnitMode_AudioOnly,          ///< All slots of a EngineUnitType audio only are always audio only
      eMFPB_EngineUnitMode_MultiRes,           ///< V12.0: all slots of a EngineUnitType MultiRes are always MultiRes only
      eMFPB_EngineUnitMode_Reserved7,          ///< Reserved for future use 
      eMFPB_EngineUnitMode_Reserved8,          ///< Reserved for future use
      eMFPB_EngineUnitMode_Reserved9,          ///< Reserved for future use
      eMFPB_EngineUnitMode_Reserved10,         ///< Reserved for future use
      eMFPB_EngineUnitMode_Reserved11,         ///< Reserved for future use
      eMFPB_EngineUnitMode_Reserved12,         ///< Reserved for future use
      eMFPB_EngineUnitMode_Reserved13,         ///< Reserved for future use
      eMFPB_EngineUnitMode_Reserved14,         ///< Reserved for future use
      eMFPB_EngineUnitMode_Reserved15         ///< Reserved for future use
    };

    struct MFPB_EngineUnitCfg_t
    {
      RefProcessorEngineUnit_t RefEngineUnit;         ///< unique reference to an engine unit
      enMFPB_EngineUnitType_t  enMFPB_EngineUnitType; ///< read only engine unit type
      enMFPB_EngineUnitMode_t  enMFPB_EngineUnitMode; ///< processing unit mode
      unsigned long            Delay;                 ///< For VideoAudio engines 3000 - 5000 ms (Total delay), in ms. 4000 by default. (For 10.0 and 10.10 with delays < 3000 are set to 3000)
                                                      ///< For AudioOnly engine 500 - 1500 ms (Total delay), in ms. 1500 by default.
      /** Read only Bitmap
       * - Bit 0: TRUE if the unit is processing video.
       * - Bit 1: TRUE if the unit is processing audio.
       **/
      unsigned long  MFPBEngineUnitProperty;
    };
    typedef sequence<MFPB_EngineUnitCfg_t> MFPB_EngineUnitCfgList_t;

    ///< Description of the slot type a service belongs to
    enum enMFPB_SlotType_t
    {
      eMFPB_SlotType_SD,        ///< SD slot type
      eMFPB_SlotType_HD,        ///< HD slot type
      eMFPB_SlotType_AudioOnly, ///< Services passed to this slot type, are only able to process audio
      eMFPB_SlotType_MultiRes,  ///< V12.0: services passed to this slot type can only have multiple resolution settings
      eMFPB_SlotType_Reserved5, ///< Reserved for future use
      eMFPB_SlotType_Reserved6, ///< Reserved for future use
      eMFPB_SlotType_Reserved7, ///< Reserved for future use
      eMFPB_SlotType_Reserved8  ///< Reserved for future use
    }; 

    enum enMFPB_AdaptSI_t
    {
      eMFPB_AdaptSI_Disabled,   ///< No SI adaptation
      eMFPB_AdaptSI_DVB,  ///< Adapt SI, prefer DVB ES type (AC-3 audio uses ES type 0x06 + AC-3 descriptor, MPEG-2 video uses ES type 0x02)
      eMFPB_AdaptSI_ATSC, ///< Adapt SI, prefer ATSC ES type (AC-3 audio uses ES type 0x81, MPEG-2 video uses ES type 0x02)
      eMFPB_AdaptSI_DC2   ///< Adapt SI, prefer DC-II ES type (AC-3 audio uses ES type 0x81, MPEG-2 video uses ES type 0x80)
    };

    enum enMFPB_MaxBitrateDescrMode_t
    {
      eMFPB_MaxBitrateDescrMode_Passthrough, ///< Use the input descriptor (default value)
      eMFPB_MaxBitrateDescrMode_Generate     ///< An ES level maximum bitrate descriptor will be generated that matches the bitrate after transcoding. Any service level descriptor is passed through.
    };

    struct MFPB_ServiceCfg_t
    {
      IPS_RefSvc_t      Service;
      RefProcessorEngineUnit_t RefEngineUnit; ///< The processor engine handling this service (engine nr == 0xFFFE can be used to delay services)

      enMFPB_SlotType_t enMFPB_SlotType;      ///< The slot type a service belongs to
      unsigned long   Delay;                  ///< For 500 - 5000 ms (Total delay), in ms. 4000 by default. The value is only used f engine nr == 0xFFFE, else the engine end to end delay is used.
      unsigned long   PCR_Interval;           ///< 10 - 100 ms, in ms. 37 by default.
      boolean         PCR_InVideo;            ///< Reserved for future use: Should the PCR be part of a video packet or should it use an empty packet (on the same PID).
      enMFPB_AdaptSI_t AdaptSI_Tables;        ///< Default Adapt SI using DVB : will automatically adapt PMT, EIT and SDT content where necessary
      enMFPB_MaxBitrateDescrMode_t  enMaxBitrateDescriptorMode;
    };
    typedef sequence<MFPB_ServiceCfg_t> MFPB_ServiceCfgList_t;  

    /** Get the current configuration of the Multi format processor (MFP) engine unit.
     *  This configuration determines how many SD, HD, audio, PIP and multi resolution streams the
     *  MFP engine can handle.
     *
     * @param[in]  BoardNr                    The Multi format processor (MFP) board to retrieve the settings from
     * @param[in]  RefProcessorEngineUnitList List of engine references to get information about. If
     *                                        empty, the function returns information for all engines.
     * @param[out] EngineUnitCfgList          A list of configuration data   
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a Multi format processor (MFP) board.
     * @exception OperationFailed 
     * - Invalid ProcessorEngine reference   
     *
     * @version Release 10.0
     **/
    void MFPB_GetEngineUnitCfg(in unsigned short BoardNr,in RefProcessorEngineUnitList_t RefProcessorEngineUnitList, out MFPB_EngineUnitCfgList_t EngineUnitCfgList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Apply a new processior engine unit configuration on a Multi format processor (MFP) board.
     *  This can cause interruptions in some or all processed streams.
     *
     * @param[in]  BoardNr          The Multi format processor (MFP) board to set the settings to.
     * @param[in]  EngineUnitCfgList  A list of configuration data
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a Multi format processor (MFP) board.    
     * @exception OperationFailed
     * - Invalid ProcessorEngine reference
     * - Invalid enMFPB_EngineMode
     * - Engine contains services, prohibiting a specific mode change
     *
     * @version Release 10.0
     **/
    void MFPB_SetEngineUnitCfg(in unsigned short BoardNr,in MFPB_EngineUnitCfgList_t EngineUnitCfgList)
      raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);


    struct MFPB_MPEG2FramePicturesCfg_t
    {
      RefProcessorEngineUnit_t RefEngineUnit;          ///< The processor engine handling this service (engine nr == 0xFFFE can be used to delay services)
      boolean                  bMPEG2FramePicture;     ///< Enable (true) or default disable (false) MPEG-2 Frame Pictures.
    };
    typedef sequence<MFPB_MPEG2FramePicturesCfg_t> MFPB_MPEG2FramePicturesCfgList_t;

    /** Get the current configuration of MPEG-2 Frame Pictures engine unit.
     *
     * @param[in]  BoardNr                   The Multi format processor (MFP) board to retrieve the settings from
     * @param[out] MPEG2FramePicturesCfgList List of all "MPEG-2 Frame Picture configurations" for this board.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a Multi format processor (MFP) board.
     *
     * @version Release 10.0.11
     **/
    void MFPB_GetMPEG2FramePicturesCfg(in unsigned short BoardNr, out MFPB_MPEG2FramePicturesCfgList_t MPEG2FramePicturesCfgList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);   

    /** Apply a new configuration of MPEG-2 Frame Pictures on a Multi format processor (MFP) engine unit.
     *
     * @param[in]  BoardNr                   The Multi format processor (MFP) board to set the settings to.
     * @param[in]  MPEG2FramePicturesCfgList A list of configuration data
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a Multi format processor (MFP) board.
     * @exception OperationFailed
     * - Invalid ProcessorEngine reference
     * - Invalid enMFPB_EngineMode
     * - Engine contains services, prohibiting a specific mode change
     *
     * @version Release 10.0.11
     **/
    void MFPB_SetMPEG2FramePicturesCfg(in unsigned short BoardNr, in MFPB_MPEG2FramePicturesCfgList_t MPEG2FramePicturesCfgList)
      raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Request to reset a DCM_MFP engine
     *
     * @param[in] SlotNr      The slot number of a MFP board to retrieve the settings from
     * @param[in] EngineNr    The engine to be reset (range: 0..3)
     * @version Release 10.0
     **/
    void MFPB_ResetEngine(in unsigned short SlotNr, in unsigned short EngineNr)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the Multi format processor (MFP) service settings.
     *
     * @param[in]  BoardNr          The Multi format processor (MFP) board to retrieve the settings from.
     * @param[in]  ServiceList      The list of services of interest.
     * @param[out] ServiceCfgList   A list of Multi format processor (MFP) service settings.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a Multi format processor (MFP) board.
     * @exception OperationFailed In case:
     * - invalid input references are used.
     *
     * @version Release 10.0
     **/
    void MFPB_ServiceCfgGetL(in unsigned short BoardNr, in IPS_Service_List_t ServiceList, out MFPB_ServiceCfgList_t ServiceCfgList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);                      

    /** Add or update the Multi format processor (MFP) service settings.
     *
     * @param[in]  BoardNr          The Multi format processor (MFP) board to set the settings to.
     * @param[in]  ServiceCfgList  A list of Multi format processor (MFP) service settings.
     *                             When there is no match between Service and RefProcessorEngine, the 
     *                             service will be added. When there is a match, the service configuration
     *                             is updated.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a Multi format processor (MFP) board.
     * @exception OperationFailed In case:
     * - invalid input Service references are used.
     * - invalid input ProcessorEngine references are used.  
     * - invalid settings were passed.
     *
     * @version Release 10.0
     **/
    void MFPB_ServiceCfgSetL(in unsigned short BoardNr, in MFPB_ServiceCfgList_t ServiceCfgList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);  

    typedef unsigned long MFPB_TrackingID_t;
    typedef sequence<MFPB_TrackingID_t> MFPB_TrackingID_List_t;

    struct MFPB_ServiceTrackingID_t
    {
      IPS_RefSvc_t  Service;
      MFPB_TrackingID_t  TrackingID;
    };
    typedef sequence<MFPB_ServiceTrackingID_t> MFPB_ServiceTrackingID_List_t;

    struct MFPB_Component_t
    {
      unsigned short  Pid;
      MFPB_TrackingID_t    TrackingId;     ///< 0 if the component matches no tracking criteria.
    };
    typedef sequence<MFPB_Component_t> MFPB_ComponentList_t;

    struct MFPB_ServiceComponents_t
    {
      IPS_RefSvc_t   Service;
      MFPB_ComponentList_t  VideoComponents;    ///< The video pids which can be processed
      MFPB_ComponentList_t  AudioComponents;    ///< The audio pids which can be processed
    };
    typedef sequence<MFPB_ServiceComponents_t> MFPB_ServiceComponentsList_t;

    /** Get the list of components which can be processed.
     *
     * @param[in]  BoardNr               The Multi format processor (MFP) board to retrieve the settings from.
     * @param[in]  ServiceList           The list of services of interest.
     * @param[out] ServiceComponentsList The list of components per service
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a Multi format processor (MFP) board.
     * @exception OperationFailed In case:
     * - invalid input references are used (ServiceList).
     *
     * @version Release 10.0
     **/
    void MFPB_ServiceComponentsGetL(in unsigned short BoardNr, in IPS_Service_List_t ServiceList, out MFPB_ServiceComponentsList_t ServiceComponentsList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);   

    enum enMFPB_ClosedCaptionFormat_t
    {
      eMFPB_ClosedCaptionFormat_None,              ///< Input contains no closed captions
      eMFPB_ClosedCaptionFormat_SA_Type_4,         ///< Reserved for future use 
      eMFPB_ClosedCaptionFormat_SCTE20,            ///< SCTE-20, reserved for future use
      eMFPB_ClosedCaptionFormat_EAI708,            ///< SCTE-21 / CEA 708
      eMFPB_ClosedCaptionFormat_Unkown,            ///< Input contains a unknown closed caption format
      eMFPB_ClosedCaptionFormat_SCTE21_608B,       ///< SCTE-21 / CEA 608
      eMFPB_ClosedCaptionFormat_SCTE21_4,          ///< SCTE 21 - Type 4, reserved for future use
      eMFPB_ClosedCaptionFormat_Reserved5,         ///< Reserved for future use 
      eMFPB_ClosedCaptionFormat_Reserved6          ///< Reserved for future use 
    };  

    struct MFPB_VideoResolution_t
    {
       unsigned short Height;
       unsigned short Width;
    };

    enum enMFPB_AspectRatio_t
    {
      enMFPB_AR_Unkown,
      enMFPB_AR_FollowInput,
      enMFPB_AR_4_3, 
      enMFPB_AR_16_9, 
      enMFPB_AR_14_9,
      enMFPB_AR_Reserved1,           ///< Reserved for future use 
      enMFPB_AR_Reserved2,           ///< Reserved for future use 
      enMFPB_AR_Reserved3,           ///< Reserved for future use 
      enMFPB_AR_Reserved4,           ///< Reserved for future use 
      enMFPB_AR_Reserved5,           ///< Reserved for future use 
      enMFPB_AR_Reserved6,           ///< Reserved for future use 
      enMFPB_AR_Reserved7,           ///< Reserved for future use 
      enMFPB_AR_Reserved8            ///< Reserved for future use 
    };

    enum enMFPB_VideoCodec_t
    {
      eMFPB_VideoCodec_Unkown,
      eMFPB_VideoCodec_Mpeg2,             ///< MPEG2 standard.
      eMFPB_VideoCodec_Avc,               ///< H.264 / AVC standard.
      eMFPB_VideoCodec_Reserved1,         ///< Reserved for future use
      eMFPB_VideoCodec_Reserved2,         ///< Reserved for future use
      eMFPB_VideoCodec_Reserved3,         ///< Reserved for future use
      eMFPB_VideoCodec_Reserved4          ///< Reserved for future use
    };
    
    struct MFPB_VideoStatus_t
    {
      enMFPB_ClosedCaptionFormat_t enClosedCaptionFormat;
      MFPB_VideoResolution_t       Resolution;            ///< Output resolution
      unsigned long                FrameRate1000;         ///< Framerate for 1000 seconds (fps*1000 eg, 29.97 Hz becomes 29970)
      enMFPB_AspectRatio_t         enDecoderAspectRatio;  ///< Aspect Ratio of the incomming video stream
      enMFPB_VideoCodec_t          enVideoDecoderCodec;   ///< Video codec of the incomming video stream
      //@see also TC_ServiceData_t for more status information (eg. VBI) 
    };    

    struct MFPB_VideoInformation_t
    {
      MFPB_TrackingID_t     TrackingId;
      MFPB_VideoStatus_t    DecoderStatus;
    };
    typedef sequence<MFPB_VideoInformation_t> MFPB_VideoInformationList_t;

    struct MFPB_VideoServiceInformation_t
    {
      IPS_RefSvc_t              Service;
      MFPB_VideoInformationList_t Video;
    };
    typedef sequence<MFPB_VideoServiceInformation_t> MFPB_VideoServiceInformationList_t;  

    /** Get video status information.
     * Information is only available for video streams which are currently being processed.
     *
     * @param[in]  BoardNr       The Multi format processor (MFP) board for which to configure processing.
     * @param[in]  ServiceList   The list of services of interest.
     * @param[out] VideoInfoList The status of the video streams.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a Multi format processor (MFP) board.
     * @exception OperationFailed In case:
     * - invalid input references are used (BoardNr, RefSvc).
     *
     * @version Release 10.0
     **/
    void MFPB_VideoInformationGetL(in unsigned short BoardNr, in IPS_Service_List_t ServiceList, out MFPB_VideoServiceInformationList_t VideoInfoList)
         raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);   

    /** Video decode settings together with fields identifying the video component they're for.
     *
     * @version Release 10.0
     */
    struct MFPB_VideoDecode_t
    {
      MFPB_TrackingID_t        TrackingId;         ///< 0 when creating a new entry
      TrackingCriterium_t      TrackingCriterium;
    };
    typedef sequence<MFPB_VideoDecode_t> MFPB_VideoDecodeList_t;

    struct MFPB_VideoDecodeCfg_t
    {
      IPS_RefSvc_t               Service;
      MFPB_VideoDecodeList_t     VideoDecodeList;
    };
    typedef sequence<MFPB_VideoDecodeCfg_t> MFPB_VideoDecodeCfgList_t;

    /** Set the video decoding settings.
     *
     * @param[in] BoardNr            The Multi format processor (MFP) board for which to configure
     *                               decoding
     * @param[in] VideoDecodeCfgList The video decoding settings
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed in case:
     *  - invalid input references are used (RefSvc)
     *  - if the configuration cannot be accepted by the processing engine mode
     *  - there are no more processing resources available
     *  - invalid settings are passed  
     *
     * @version Release 10.0
     */
    void MFPB_VideoDecodeCfgSetL(in unsigned short BoardNr,
                               in MFPB_VideoDecodeCfgList_t VideoDecodeCfgList)
        raises(TimeOut, OperationFailed, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);

    /** Get the video decoding settings.
     *
     * @param[in]  BoardNr            The Multi format processor (MFP) board to retrieve the settings
     *                                from
     * @param[in]  ServiceList        The list of services of interest.
     * @param[out] VideoDecodeCfgList The video decoding settings
     *
     * @version Release 10.0
     */
    void MFPB_VideoDecodeCfgGetL(in unsigned short BoardNr,
                               in IPS_Service_List_t ServiceList,
                               out MFPB_VideoDecodeCfgList_t VideoDecodeCfgList)
        raises(TimeOut, OperationFailed, OpNotSucceeded, OpNotAllowed, OpNotSupported);    

    /** Remove the video decoding settings.
     *
     * @param[in] BoardNr   The Multi format processor (MFP) board for which to configure decoding
     * @param[in] ToDelete  A list of IDs for video decoding settings to delete
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed In case:
     * - invalid input references are used (RefSvc, TrackingID).
     *
     * @version Release 10.0
     */
    void MFPB_VideoDecodeCfgDeleteL(in unsigned short BoardNr,
                                  in MFPB_ServiceTrackingID_List_t ToDelete)
        raises(TimeOut, OperationFailed, OpNotSucceeded, OpNotAllowed, OpNotSupported);    
    
    enum enMFPB_VideoEncodingMode_t
    {
      eMFPB_VideoEncodingMode_Transrate,         ///< Transrate video
      eMFPB_VideoEncodingMode_Transcode,         ///< Transcode video
      eMFPB_VideoEncodingMode_Reserved3,         ///< Reserved for future use      
      eMFPB_VideoEncodingMode_Reserved4,         ///< Reserved for future use      
      eMFPB_VideoEncodingMode_Reserved5,         ///< Reserved for future use      
      eMFPB_VideoEncodingMode_Reserved6          ///< Reserved for future use      
    };

    enum enMFPB_VideoEncoderCodec_t
    {
      eMFPB_VideoEncoderCodec_Mpeg2,             ///< MPEG2 standard.
      eMFPB_VideoEncoderCodec_Avc,               ///< H.264 / AVC standard.
      eMFPB_VideoEncoderCodec_Reserved3,         ///< Reserved for future use      
      eMFPB_VideoEncoderCodec_Reserved4,         ///< Reserved for future use      
      eMFPB_VideoEncoderCodec_Reserved5,         ///< Reserved for future use      
      eMFPB_VideoEncoderCodec_Reserved6          ///< Reserved for future use      
    };

    enum enMFPB_VideoMode_t
    {
      eMFPB_VideoMode_SD,                ///< SD service
      eMFPB_VideoMode_HD,                ///< HD service (future: Maximum HD, will be SD if input is SD)
      eMFPB_VideoMode_SD_Down,           ///< Decoder can be HD or SD, output will be (downconverted) SD, reserved for future use
      eMFPB_VideoMode_Reserved3,         ///< Reserved for future use      
      eMFPB_VideoMode_Reserved4,         ///< Reserved for future use
      eMFPB_VideoMode_Reserved5,         ///< Reserved for future use
      eMFPB_VideoMode_Reserved6          ///< Reserved for future use
    };

    enum enMFPB_VertResolution_t
    {
      eMFPB_VR_FollowInput,       ///< Height follows the height of the input
      eMFPB_VR_CustomResolution,  ///< Reserved for future use  
      eMFPB_VR_96,                ///< Height in pixels, applies to PIP, reserved for future use
      eMFPB_VR_128,               ///< Reserved for future use
      eMFPB_VR_144,               ///< Height in pixels, applies to PIP, reserved for future use
      eMFPB_VR_176,               ///< Reserved for future use
      eMFPB_VR_180,               ///< Height in pixels, reserved for future use
      eMFPB_VR_192,               ///< Height in pixels, applies to PIP, reserved for future use
      eMFPB_VR_216,               ///< Height in pixels, reserved for future use
      eMFPB_VR_240,               ///< Height in pixels, reserved for future use
      eMFPB_VR_270,               ///< Height in pixels, reserved for future use
      eMFPB_VR_288,               ///< Height in pixels, reserved for future use
      eMFPB_VR_360,               ///< Height in pixels, reserved for future use
      eMFPB_VR_384,               ///< Reserved for future use
      eMFPB_VR_396,               ///< Height in pixels, reserved for future use
      eMFPB_VR_480i,              ///< Height in pixels, applies to SD downconversion
      eMFPB_VR_480,               ///< Height in pixels, applies to SD, Reserved for future use        
      eMFPB_VR_540,               ///< Height in pixels, reserved for future use
      eMFPB_VR_576i,              ///< Height in pixels, applies to SD downconversion
      eMFPB_VR_576,               ///< Height in pixels, applies to SD, Reserved for future use        
      eMFPB_VR_720p,              ///< Height in pixels, applies to HD, Reserved for future use        
      eMFPB_VR_1080i,             ///< Height in pixels, applies to SD, Reserved for future use        
      eMFPB_VR_1152,              ///< Height in pixels, reserved for future use
      eMFPB_VR_1080p,             ///< Reserved for future use
      eMFPB_VR_280,               ///< Reserved for future use
      eMFPB_VR_Reserved3,         ///< Reserved for future use      
      eMFPB_VR_Reserved4,         ///< Reserved for future use      
      eMFPB_VR_Reserved5,         ///< Reserved for future use      
      eMFPB_VR_Reserved6,         ///< Reserved for future use
      eMFPB_VR_Reserved7,         ///< Reserved for future use
      eMFPB_VR_Reserved8,         ///< Reserved for future use
      eMFPB_VR_Reserved9,         ///< Reserved for future use
      eMFPB_VR_Reserved10,        ///< Reserved for future use
      eMFPB_VR_Reserved11,        ///< Reserved for future use
      eMFPB_VR_Reserved12,        ///< Reserved for future use
      eMFPB_VR_Reserved13,        ///< Reserved for future use
      eMFPB_VR_Reserved14,        ///< Reserved for future use
      eMFPB_VR_Reserved15,        ///< Reserved for future use
      eMFPB_VR_Reserved16,        ///< Reserved for future use      
      eMFPB_VR_Reserved17,        ///< Reserved for future use
      eMFPB_VR_Reserved18,        ///< Reserved for future use
      eMFPB_VR_Reserved19,        ///< Reserved for future use
      eMFPB_VR_Reserved20,        ///< Reserved for future use
      eMFPB_VR_Reserved21,        ///< Reserved for future use
      eMFPB_VR_Reserved22,        ///< Reserved for future use
      eMFPB_VR_Reserved23,        ///< Reserved for future use
      eMFPB_VR_Reserved24,        ///< Reserved for future use      
      eMFPB_VR_Reserved25,        ///< Reserved for future use
      eMFPB_VR_Reserved26,        ///< Reserved for future use
      eMFPB_VR_Reserved27,        ///< Reserved for future use
      eMFPB_VR_Reserved28,        ///< Reserved for future use
      eMFPB_VR_Reserved29,        ///< Reserved for future use
      eMFPB_VR_Reserved30         ///< Reserved for future use
    };

    enum enMFPB_HorizResolution_t
    {
      eMFPB_HR_FollowInput,            ///< Width follows the width of the input
      eMFPB_HR_FollowInputAspectRatio, ///< Width follows the aspect (width/height) ratio of the input 
      eMFPB_HR_CustomResolution,       ///< Reserved for future use
      eMFPB_HR_96,                     ///< Width in pixels, applies to PIP, reserved for future use
      eMFPB_HR_128,                    ///< Width in pixels, applies to PIP, reserved for future use 
      eMFPB_HR_176,                    ///< Width in pixels, applies to PIP, reserved for future use
      eMFPB_HR_192,                    ///< Width in pixels, applies to PIP, reserved for future use
      eMFPB_HR_320,                    ///< Width in pixels, applies to SD, can be used for horizontal scaling
      eMFPB_HR_352,                    ///< Width in pixels, applies to SD, can be used for horizontal scaling
      eMFPB_HR_384,                    ///< Width in pixels, reserved for future use
      eMFPB_HR_480,                    ///< Width in pixels, applies to SD, can be used for horizontal scaling
      eMFPB_HR_528,                    ///< Width in pixels, applies to SD, can be used for horizontal scaling
      eMFPB_HR_544,                    ///< Width in pixels, applies to SD, can be used for horizontal scaling
      eMFPB_HR_640,                    ///< Width in pixels, applies to SD, can be used for horizontal scaling
      eMFPB_HR_704,                    ///< Width in pixels, applies to SD, can be used for horizontal scaling
      eMFPB_HR_720,                    ///< Width in pixels, applies to SD, reserved for future use
      eMFPB_HR_854,                    ///< Width in pixels, reserved for future use
      eMFPB_HR_960,                    ///< Width in pixels, applies to HD, reserved for future use
      eMFPB_HR_1024,                   ///< Width in pixels, reserved for future use
      eMFPB_HR_1080,                   ///< Reserved for future use      
      eMFPB_HR_1152,                   ///< Reserved for future use      
      eMFPB_HR_1280,                   ///< Width in pixels, applies to HD, reserved for future use 
      eMFPB_HR_1408,                   ///< Width in pixels, applies to HD, reserved for future use
      eMFPB_HR_1440,                   ///< Width in pixels, applies to HD, reserved for future use               
      eMFPB_HR_1920,                   ///< Width in pixels, applies to HD, reserved for future use
      eMFPB_HR_368,                    ///< Width in pixels, applies to SD, can be used for horizontal scaling 
      eMFPB_HR_Ratio_1_2,              ///< Width in relation to horizontal input resolution, applies to HD horizontal scaling. 1/2 of input HR, only used if input HR is 1920 or 1280 else the behavior is like FollowInput.   
      eMFPB_HR_Ratio_2_3,              ///< Width in relation to horizontal input resolution, applies to HD horizontal scaling. 2/3 of input HR, only used if input HR is 1920 else the behavior is like FollowInput.   
      eMFPB_HR_Ratio_3_4,              ///< Width in relation to horizontal input resolution, applies to HD horizontal scaling. 3/4 of input HR, only used if input HR is 1920 or 1280 else the behavior is like FollowInput.   
      eMFPB_HR_Reserved1,              ///< Reserved for future use
      eMFPB_HR_Reserved2,              ///< Reserved for future use
      eMFPB_HR_Reserved3,              ///< Reserved for future use
      eMFPB_HR_Reserved4,              ///< Reserved for future use
      eMFPB_HR_Reserved5,              ///< Reserved for future use
      eMFPB_HR_Reserved6,              ///< Reserved for future use
      eMFPB_HR_Reserved7,              ///< Reserved for future use
      eMFPB_HR_Reserved8,              ///< Reserved for future use
      eMFPB_HR_Reserved9,              ///< Reserved for future use
      eMFPB_HR_Reserved10,             ///< Reserved for future use
      eMFPB_HR_Reserved11,             ///< Reserved for future use
      eMFPB_HR_Reserved12,             ///< Reserved for future use
      eMFPB_HR_Reserved13,             ///< Reserved for future use
      eMFPB_HR_Reserved14,             ///< Reserved for future use
      eMFPB_HR_Reserved15,             ///< Reserved for future use
      eMFPB_HR_Reserved16,             ///< Reserved for future use
      eMFPB_HR_Reserved17,             ///< Reserved for future use
      eMFPB_HR_Reserved18,             ///< Reserved for future use
      eMFPB_HR_Reserved19,             ///< Reserved for future use
      eMFPB_HR_Reserved20,             ///< Reserved for future use      
      eMFPB_HR_Reserved21,             ///< Reserved for future use
      eMFPB_HR_Reserved22,             ///< Reserved for future use
      eMFPB_HR_Reserved23,             ///< Reserved for future use
      eMFPB_HR_Reserved24,             ///< Reserved for future use
      eMFPB_HR_Reserved25,             ///< Reserved for future use
      eMFPB_HR_Reserved26              ///< Reserved for future use
    };

    enum enMFPB_FrameRate_t
    {
      eMFPB_FrameRate_FollowInput,      ///< Frame rate follows the frame rate of the input
      eMFPB_FrameRate_Reduction,        ///< Framerate will be defined by enMFPB_FrameRateReduction (@see MFPB_VideoEncoderTemplate_t). Reserved for future use.
      eMFPB_FrameRate_24Hz,             ///< Reserved for future use
      eMFPB_FrameRate_25Hz,             ///< Frame rate in Hz, applies to SD and HD, reserved for future use
      eMFPB_FrameRate_29_97Hz,          ///< Frame rate in Hz, applies to SD and HD, reserved for future use
      eMFPB_FrameRate_30Hz,             ///< Frame rate in Hz, applies to SD and HD, reserved for future use
      eMFPB_FrameRate_50Hz,             ///< Frame rate in Hz, applies to HD, reserved for future use
      eMFPB_FrameRate_59_94Hz,          ///< Frame rate in Hz, applies to HD, reserved for future use
      eMFPB_FrameRate_60Hz,             ///< Frame rate in Hz, applies to HD, reserved for future use
      eMFPB_FrameRate_Reserved9,        ///< Reserved for future use 
      eMFPB_FrameRate_Reserved10,       ///< Reserved for future use 
      eMFPB_FrameRate_Reserved11,       ///< Reserved for future use 
      eMFPB_FrameRate_Reserved12        ///< Reserved for future use 
    };

    enum enMFPB_FrameRateReduction_t
    {
      eMFPB_FrameRateReduction_None,           ///< Framerate will be defined by enMFPB_FrameRate (@see MFPB_VideoEncoderTemplate_t)
      eMFPB_FrameRateReduction_1_over_2,       ///< Reserved for future use
      eMFPB_FrameRateReduction_1_over_3,       ///< Reserved for future use    
      eMFPB_FrameRateReduction_1_over_4,       ///< Reserved for future use
      eMFPB_FrameRateReduction_1_over_5,       ///< Reserved for future use
      eMFPB_FrameRateReduction_1_over_6,       ///< Reserved for future use
      eMFPB_FrameRateReduction_1_over_30,      ///< Reserved for future use
      eMFPB_FrameRateReduction_1_over_60,      ///< Reserved for future use
      eMFPB_FrameRateReduction_Reserved9,      ///< Reserved for future use   
      eMFPB_FrameRateReduction_Reserved10,     ///< Reserved for future use   
      eMFPB_FrameRateReduction_Reserved11,     ///< Reserved for future use   
      eMFPB_FrameRateReduction_Reserved12      ///< Reserved for future use   
    };

    enum enMFPB_Profile_t
    {
      eMFPB_Profile_FollowInput,        ///< Applies to Mpeg2 and AVC, Reserved for future use
      eMFPB_Profile_Baseline,           ///< Applies to AVC, Reserved for future use  
      eMFPB_Profile_ConstrainedBaseline,///< Tools shared by baseline and main profile. Reserved for future use.
      eMFPB_Profile_Main,               ///< Applies to Mpeg2 and AVC (except Transrating AVC HD). Default for Mpeg2 and Avc SD.
      eMFPB_Profile_High,               ///< Applies to AVC (except Transrating AVC SD). Default for AVC HD. 
      eMFPB_Profile_Reserved1,          ///< Reserved for future use
      eMFPB_Profile_Reserved2,          ///< Reserved for future use
      eMFPB_Profile_Reserved3,          ///< Reserved for future use
      eMFPB_Profile_Reserved4,          ///< Reserved for future use
      eMFPB_Profile_Reserved5,          ///< Reserved for future use
      eMFPB_Profile_Reserved6           ///< Reserved for future use
    };  

    struct MFPB_VideoEncoderTemplate_t 
    {
      enMFPB_VertResolution_t     enMFPB_VertResolution;      ///< Vertical Resolution
      unsigned long               uCustomVertResolution;      ///< Future usage: Custom vertical resolution only used if enMFPB_VertResolution is 
      enMFPB_HorizResolution_t    enMFPB_HorizResolution;     ///< Horizontal Resolution
      unsigned long               uCustomHorizResolution;     ///< Future usage: Custom horizontal resolution only used if enMFPB_HorizResolution is
      enMFPB_FrameRate_t          enMFPB_FrameRate;           ///< Frame rate
      enMFPB_FrameRateReduction_t enMFPB_FrameRateReduction;  ///< Frame rate reduction, Reserved for future use
      enMFPB_Profile_t            enMFPB_Profile;             ///< Profile: see enMFPB_Profile_t for Mpeg2/Avc, transrate/transcode, SD/HD defaults and constraints.

      /** Bitrate in bps
       *   The meaning of the bitrate depends on the enBitrateMode (@see MFPB_VideoEncodeSettings_t).
       *   For CBR       : The constant output bit rate. (stuffed if needed)  
       *   For CappedVBR : The maximum output bit rate.
       *   For Statmux   : Backup bit rate when the statmux controller cannot manage the encoder bitrate.
       *          
       * - SD, Mpeg2 range: 0.8-15 Mbps   [3 Mbps by default]
       * - SD, Avc   range: 0.3-12.5 Mbps [1.5 Mbps by default]
       * - HD, Mpeg2 range: 1-45 Mbps     [15 Mbps by default]
       * - HD, Avc   range: 0.5-25 Mbps   [8 Mbps by default]
       **/
      unsigned long                   Bitrate;
    };

    enum enMFPB_BitrateMode
    {
      eMFPB_BitrateMode_CBR,       ///< Encoder rate control outputs with constant bit rate. ES stuffing when needed.
      eMFPB_BitrateMode_CappedVBR, ///< Encoder rate control outputs with a max bit rate. No ES stuffing when lower.
      eMFPB_BitrateMode_Statmux,   ///< No local rate control algorithm is used. Bit rate is managed by external statistical multiplex controller.
      eMFPB_BitrateMode_Reserved4, ///< Reserved for future use
      eMFPB_BitrateMode_Reserved5, ///< Reserved for future use
      eMFPB_BitrateMode_Reserved6  ///< Reserved for future use
    };

    enum enMFPB_GopStructure_t
    {
      eMFPB_GS_FollowInput,      ///< Reserved for future use: Mpeg2 and Avc: Follow input GOP size and structure. (GOP size, B-pictures, (AVC) IDR are ignored)
      eMFPB_GS_Fixed,            ///< In the GUI this is called "Custom". Mpeg2 and Avc: Fixed GOP size (can be violated), the number of B frames and (AVC) IDR interval.
      eMFPB_GS_Dynamic,          ///< Mpeg2 and Avc: The maximum number GOP size.(B-pictures are ignored)
      eMFPB_GS_KeepClosed,       ///< Mpeg2 and Avc: Keep closed GOP's (GOP size, B-pictures are ignored)
      eMFPB_GS_HardFixed,        ///< Mpeg2 and Avc: Fixed GOP size (guaranteed), the number of B frames and (AVC) IDR interval.
      eMFPB_GS_Reserved2,        ///< Reserved for future use (Close GOPs (GOP size, B-pictures, (AVC) IDR are ignored) )
      eMFPB_GS_Reserved3,        ///< Reserved for future use (Keep I Frames (GOP size, B-pictures, (AVC) IDR are ignored) )
      eMFPB_GS_Reserved4,        ///< Reserved for future use
      eMFPB_GS_Reserved5         ///< Reserved for future use
    };

    enum enMFPB_ClosedCaptions_t
    {
      eMFPB_ClosedCaptions_Disable,        ///< Disable closed captions at the output.
      eMFPB_ClosedCaptions_Auto,           ///< Copy closed caption from decoder if available, else empty CEA 708 closed caption fields will be present
      eMFPB_ClosedCaptions_TestField1,     ///< Reserved for future use, Test Pattern: Field 1
      eMFPB_ClosedCaptions_TestField2,     ///< Reserved for future use, Test Pattern: Field 2
      eMFPB_ClosedCaptions_TestField1_2,   ///< Reserved for future use, Test Pattern: Field 1 and 2
      eMFPB_ClosedCaptions_Manual,         ///< Reserved for future use, Manual
      eMFPB_ClosedCaptions_Reserved5,      ///< Reserved for future use
      eMFPB_ClosedCaptions_Reserved6,      ///< Reserved for future use
      eMFPB_ClosedCaptions_Reserved7,      ///< Reserved for future use
      eMFPB_ClosedCaptions_Reserved8,      ///< Reserved for future use
      eMFPB_ClosedCaptions_Reserved9,      ///< Reserved for future use
      eMFPB_ClosedCaptions_Reserved10      ///< Reserved for future use
    };
    
    /** Video encode settings.
     *
     * @version Release 10.0
     */
    struct MFPB_VideoEncodeSettings_t
    {
      enMFPB_VideoEncodingMode_t   enVideoEncodingMode;    ///< Processing mode TR/TC
      enMFPB_VideoEncoderCodec_t   enVideoEncoderCodec;    ///< Indicate whether Mpeg2/AVC is used
      enMFPB_VideoMode_t           enVideoMode;            ///< Indicate whether this is SD/HD 
      enMFPB_BitrateMode           enBitrateMode;          ///< Choose between CBR, Capped VBR and Statmux
      MFPB_VideoEncoderTemplate_t  SdOutputEncoderTemplate;///< Template for SD output
      MFPB_VideoEncoderTemplate_t  HdOutputEncoderTemplate;///< Template for HD output. Not used in SD mode

      enMFPB_GopStructure_t        enMFPB_GopStructure;    ///< The mode of the GOP structure(ignored for transrating, KeepClosed is used)
      boolean                      bHierarchical;          ///< AVC only. Hierarchical layered structure, default disabled (ignored for transrating + see GopStructure constraints)
      unsigned short               GopBPictures;           ///< Amount of B pictures. Range 0 to 5, default 2. 0 means IPP. (ignored for transrating + see GopStructure constraints)
      unsigned short               GopSize;                ///< Number of I coded frames per gop. Range: 1..600, default 15, 1 means no B or P frames (ignored for transrating + GopStructure constraints)

      /** AVCIDR_Interval
       *  This field has a 2 fold meaning
       *   1) AVC only: Insert nr of IDR frames per gop. Between 0 (no IDR, default) to 4, 0 is default. (ignored for transrating + see GopStructure constraints)
       *   2) Closed Gops disable 0 [default] or enable 1.Special values 0 and 1 can only be used when transcoding. Independend of format (Mpeg2 or AVC) or other Gop settings.
       *
       *   The value is ignored and set to 0 in cases it cannot be used.
       **/
      unsigned long                AVCIDR_Interval;

      enMFPB_ClosedCaptions_t      enClosedCaptions;       ///< Disable, auto, transcode, test
    };
    
    /** Video encode settings together with field identifying the video component they're for.
     *
     * @version Release 10.0
     */
    struct MFPB_VideoEncode_t
    {
      MFPB_TrackingID_t             TrackingId; ///< Must be equal to the tracking ID of a video decode
      MFPB_VideoEncodeSettings_t    Settings;
    };
    typedef sequence<MFPB_VideoEncode_t> MFPB_VideoEncodeList_t;

    struct MFPB_VideoEncodeCfg_t
    {
      IPS_RefSvc_t             Service;
      MFPB_VideoEncodeList_t   VideoEncodeList;
    };
    typedef sequence<MFPB_VideoEncodeCfg_t> MFPB_VideoEncodeCfgList_t;
    
    
    struct MFPB_MultiResABR_t
    {
      IPS_RefSvc_t   Service;          ///< Main MFP service reference
      boolean        FragmentsEnabled; ///< Enable ABR syncing via Fragments
      boolean        SegmentsEnabled;  ///< Enable ABR syncing via Segments
      unsigned long  FragmentLength;   ///< Fragment length in seconds (range: 1 to 60s)
      unsigned long  SegmentLength;    ///< Segment length in seconds (range: 1 to 60)
    }; ///< Note: it is required that FragmentLength and SegmentLength are a multiple of one another
    typedef sequence<MFPB_MultiResABR_t> MFPB_MultiResABR_List_t;
        
    struct MFPB_MultiResESAM_t
    { 
      IPS_RefSvc_t  Service;            ///< Main MFP service reference
      boolean       Enable;             ///< Flag indicating if ESAM is enabled for this service
      string        UrlPois;            ///< URL of the POIS Server to use for this service
      string        AcquisitionPointId; ///< Acquisition Point Identifier, defaults to User Tag. Max 255 characters
    }; 
    typedef sequence<MFPB_MultiResESAM_t> MFPB_MultiResESAM_List_t;

    struct MFPB_DefaultESAM_t
    {
      boolean  Enable;   ///< Flag indicating if ESAM is enabled for newly added services
      string   UrlPois;  ///< URL of the POIS Server.  Used as POIS URL for newly added services
    }; 

    /** Set the video encoding settings.
     *
     * @param[in] BoardNr            The Multi format processor (MFP) board for which to configure
     *                               encoding
     * @param[in] VideoEncodeCfgList The video encoding settings
     *
     * @note The TrackingID must always correspond to a video decode tracking ID
     *       configured with VideoDecodeCfgSetL(..).  *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed in case:
     * - invalid input references are used (RefSvc)
     * - no video decode was configured
     * - if the configuration cannot be accepted by the processing engine mode   
     * - invalid settings are passed  
     *
     * @version Release 10.0
     */
    void MFPB_VideoEncodeCfgSetL(in unsigned short BoardNr,
                               in MFPB_VideoEncodeCfgList_t VideoEncodeCfgList)
        raises(TimeOut, OperationFailed, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);  

    /** Get the video encoding settings.
     *
     * @param[in]  BoardNr            The Multi format processor (MFP) board to retrieve the settings
     *                                from
     * @param[in]  ServiceList        The list of services of interest.
     * @param[out] VideoEncodeCfgList The video encoding settings
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed in case:
     * - invalid input references are used (RefSvc)  
     *
     * @version Release 10.0
     */
    void MFPB_VideoEncodeCfgGetL(in unsigned short BoardNr,
                               in IPS_Service_List_t ServiceList,
                               out MFPB_VideoEncodeCfgList_t VideoEncodeCfgList)
        raises(TimeOut, OperationFailed, OpNotSucceeded, OpNotAllowed, OpNotSupported);        

    enum enMFPB_AspectRatioSigMode
    {
      eMFPB_AspectRatioModeSig_Manual,         ///< Aspect Ratio Signaling set to a user defined value.
      eMFPB_AspectRatioModeSig_Auto,           ///< Follow input and use user configured default as backup.
      eMFPB_AspectRatioModeSig_Reserved1,      ///< Reserved for future use
      eMFPB_AspectRatioModeSig_Reserved2,      ///< Reserved for future use
      eMFPB_AspectRatioModeSig_Reserved3,      ///< Reserved for future use
      eMFPB_AspectRatioModeSig_Reserved4,      ///< Reserved for future use
      eMFPB_AspectRatioModeSig_Reserved5,      ///< Reserved for future use
      eMFPB_AspectRatioModeSig_Reserved6       ///< Reserved for future use
    };

    enum enMFPB_AspectRatioSig
    {
      eMFPB_AspectRatioSig_4_3,            ///< Aspect Ratio Signaling 4:3
      eMFPB_AspectRatioSig_16_9,           ///< Aspect Ratio Signaling 16:9
      eMFPB_AspectRatioSig_14_9,           ///< Aspect Ratio Signaling 14:9
      eMFPB_AspectRatioSig_Reserved1,      ///< Reserved for future use
      eMFPB_AspectRatioSig_Reserved2,      ///< Reserved for future use
      eMFPB_AspectRatioSig_Reserved3,      ///< Reserved for future use
      eMFPB_AspectRatioSig_Reserved4,      ///< Reserved for future use
      eMFPB_AspectRatioSig_Reserved5,      ///< Reserved for future use
      eMFPB_AspectRatioSig_Reserved6       ///< Reserved for future use
    };

    /** @brief Active format descriptor*/
    enum enMFPB_AfdMode
    {
      eMFPB_AfdMode_Manual,         ///< Aspect Ratio Signaling set to a user defined value. (Not supported for HD->HD of SD->SD processing.)
      eMFPB_AfdMode_Auto,           ///< Follow input and use user configured default as backup.  (Not supported for HD->SD processing.)
      eMFPB_AfdMode_Reserved1,      ///< Reserved for future use
      eMFPB_AfdMode_Reserved2,      ///< Reserved for future use
      eMFPB_AfdMode_Reserved3,      ///< Reserved for future use
      eMFPB_AfdMode_Reserved4,      ///< Reserved for future use
      eMFPB_AfdMode_Reserved5,      ///< Reserved for future use
      eMFPB_AfdMode_Reserved6       ///< Reserved for future use
    };

    enum enMFPB_Afd
    {
      enMFPB_Afd_16_9_b_top,    ///< Box 16:9 (top)
      enMFPB_Afd_14_9_b_top,    ///< Box 14:9 (top)
      enMFPB_Afd_16_9_b_centre, ///< Box > 16:9 (centre)
      enMFPB_Afd_4_3_centre,    ///< 4:3 (centre)
      enMFPB_Afd_16_9_centre,   ///< 16:9 (centre)
      enMFPB_Afd_14_9_centre,   ///< 14:9 (centre)
      enMFPB_Afd_4_3_sp_14_9,   ///< 4:3 (with shoot and protect 14:9 centre)
      enMFPB_Afd_16_9_sp_14_9,  ///< 16:9 (with shoot and protect 14:9 centre)
      enMFPB_Afd_16_9_sp_4_3,   ///< 16:9 (with shoot and protect 4:3 centre)
      eMFPB_Afd_Reserved1,      ///< Reserved for future use
      eMFPB_Afd_Reserved2,      ///< Reserved for future use
      eMFPB_Afd_Reserved3,      ///< Reserved for future use
      eMFPB_Afd_Reserved4,      ///< Reserved for future use
      eMFPB_Afd_Reserved5,      ///< Reserved for future use
      eMFPB_Afd_Reserved6       ///< Reserved for future use
    };

    /** @brief Picture Adaptive Frame Field Encoding*/
    enum enMFPB_PAFF
    {
      enMFPB_PAFF_MBAFF,
      enMFPB_PAFF_PAFF,
      enMFPB_PAFF_Reserved1,      ///< Reserved for future use
      enMFPB_PAFF_Reserved2,      ///< Reserved for future use
      enMFPB_PAFF_Reserved3,      ///< Reserved for future use
      enMFPB_PAFF_Reserved4,      ///< Reserved for future use
      enMFPB_PAFF_Reserved5,      ///< Reserved for future use
      enMFPB_PAFF_Reserved6       ///< Reserved for future use
    };

    /** Video encode settings.
     *
     * @version Release 11.10
     */
    struct MFPB_VideoEncodeSettingsV2_t
    {
      enMFPB_VideoEncodingMode_t   enVideoEncodingMode;    ///< Processing mode TR/TC
      enMFPB_VideoEncoderCodec_t   enVideoEncoderCodec;    ///< Indicate whether Mpeg2/AVC is used
      enMFPB_VideoMode_t           enVideoMode;            ///< Indicate whether this is SD/HD 
      enMFPB_BitrateMode           enBitrateMode;          ///< Choose between CBR, Capped VBR and Statmux
      MFPB_VideoEncoderTemplate_t  SdOutputEncoderTemplate;///< Template for SD output
      MFPB_VideoEncoderTemplate_t  HdOutputEncoderTemplate;///< Template for HD output. Not used in SD mode

      enMFPB_GopStructure_t        enMFPB_GopStructure;    ///< The mode of the GOP structure(ignored for transrating, KeepClosed is used)
      boolean                      bHierarchical;          ///< AVC only. Hierarchical layered structure, default disabled (ignored for transrating + see GopStructure constraints)
      unsigned short               GopBPictures;           ///< Amount of B pictures. Range 0 to 5, default 2. 0 means IPP. (ignored for transrating + see GopStructure constraints)
      unsigned short               GopSize;                ///< Number of I coded frames per gop. Range: 1..600, default 15, 1 means no B or P frames (ignored for transrating + GopStructure constraints)

      /** AVCIDR_Interval
       *  This field has a 2 fold meaning
       *   1) AVC only: Insert nr of IDR frames per gop. Between 0 (no IDR, default) to 4, 0 is default. (ignored for transrating + see GopStructure constraints)
       *   2) Closed Gops disable 0 [default] or enable 1.Special values 0 and 1 can only be used when transcoding. Independend of format (Mpeg2 or AVC) or other Gop settings.
       *
       *   The value is ignored and set to 0 in cases it cannot be used.
       **/
      unsigned long                AVCIDR_Interval;

      enMFPB_ClosedCaptions_t      enClosedCaptions;       ///< Disable, auto, transcode, test
      enMFPB_AspectRatioSigMode    enAspectRatioSigMode;   ///< Aspect Ratio Signaling mode. Auto (fixed for HD->HD, SD->SD), manual (fixed for HD->SD)
      enMFPB_AspectRatioSig        enAspectRatioSig;       ///< Aspect Ratio Signaling value. The value set in manual mode or fallback value for auto enAspectRatioSigMode. (4:3 SD default, 16:9 HD default)
      enMFPB_AfdMode               enAfdMode;              ///< Active format descriptor mode, only used for HD->SD downconversion. Manual | auto (Default)
      enMFPB_Afd                   enAfd;                  ///< Active format descriptor value.The value set in manual mode or fallback value for auto enAfdMode. (enMFPB_Afd_16_9_sp_4_3 by default)
      enMFPB_PAFF                  enPAFF;                 ///< Reserved for future use, Picture Adaptive Frame Field Encoding MBAFF (default) | PAFF
    };
    
    /** Video encode settings together with field identifying the video component they're for.
     *
     * @version Release 11.10
     */
    struct MFPB_VideoEncodeV2_t
    {
      MFPB_TrackingID_t             TrackingId; ///< Must be equal to the tracking ID of a video decode
      MFPB_VideoEncodeSettingsV2_t    Settings;
    };
    typedef sequence<MFPB_VideoEncodeV2_t> MFPB_VideoEncodeV2List_t;

    struct MFPB_VideoEncodeCfgV2_t
    {
      IPS_RefSvc_t             Service;
      MFPB_VideoEncodeV2List_t   VideoEncodeList;
    };
    typedef sequence<MFPB_VideoEncodeCfgV2_t> MFPB_VideoEncodeCfgV2List_t;

    /** Set the video encoding settings.
     *
     * @param[in] BoardNr            The Multi format processor (MFP) board for which to configure
     *                               encoding
     * @param[in] VideoEncodeCfgList The video encoding settings
     *
     * @note The TrackingID must always correspond to a video decode tracking ID
     *       configured with VideoDecodeCfgSetL(..).  *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed in case:
     * - invalid input references are used (RefSvc)
     * - no video decode was configured
     * - if the configuration cannot be accepted by the processing engine mode   
     * - invalid settings are passed  
     *
     * @version Release 11.10
     */
    void MFPB_VideoEncodeCfgV2SetL(in unsigned short BoardNr,
                               in MFPB_VideoEncodeCfgV2List_t VideoEncodeCfgList)
        raises(TimeOut, OperationFailed, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);  

    /** Get the video encoding settings.
     *
     * @param[in]  BoardNr            The Multi format processor (MFP) board to retrieve the settings
     *                                from
     * @param[in]  ServiceList        The list of services of interest.
     * @param[out] VideoEncodeCfgList The video encoding settings
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed in case:
     * - invalid input references are used (RefSvc)  
     *
     * @version Release 11.10
     */
    void MFPB_VideoEncodeCfgV2GetL(in unsigned short BoardNr,
                               in IPS_Service_List_t ServiceList,
                               out MFPB_VideoEncodeCfgV2List_t VideoEncodeCfgList)
        raises(TimeOut, OperationFailed, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Remove the video encoding settings and related closed caption settings.
     *
     * @param[in] BoardNr   The Multi format processor (MFP) board
     * @param[in] ToDelete  A list of IDs for video encoding settings to delete
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed In case:
     * - invalid input references are used (RefSvc, TrackingID).
     *
     * @version Release 10.0
     */
    void MFPB_VideoEncodeCfgDeleteL(in unsigned short BoardNr,
                                  in MFPB_ServiceTrackingID_List_t ToDelete)
        raises(TimeOut, OperationFailed, OpNotSucceeded, OpNotAllowed, OpNotSupported); 


   enum enMFPB_MR_FrameRate_t
    {
      eMFPB_MR_FrameRate_30Hz,             
      eMFPB_MR_FrameRate_29_97Hz,          
      eMFPB_MR_FrameRate_25Hz,             
      eMFPB_MR_FrameRate_23_98Hz,          
      eMFPB_MR_FrameRate_24Hz,          
      eMFPB_MR_FrameRate_15Hz,          
      eMFPB_MR_FrameRate_14_99Hz,
      eMFPB_MR_FrameRate_12_5Hz,
      eMFPB_MR_FrameRate_12Hz,
      eMFPB_MR_FrameRate_11_99Hz,
      eMFPB_MR_FrameRate_10Hz,
      eMFPB_MR_FrameRate_9_99Hz,
      eMFPB_MR_FrameRate_50Hz,            
      eMFPB_MR_FrameRate_59_94Hz,
      eMFPB_MR_FrameRate_60Hz,
      eMFPB_MR_FrameRate_Reserved4,       ///< Reserved for future use 
      eMFPB_MR_FrameRate_Reserved5,       ///< Reserved for future use 
      eMFPB_MR_FrameRate_Reserved6,       ///< Reserved for future use 
      eMFPB_MR_FrameRate_Reserved7,       ///< Reserved for future use 
      eMFPB_MR_FrameRate_Reserved8,       ///< Reserved for future use 
      eMFPB_MR_FrameRate_Reserved9,       ///< Reserved for future use 
      eMFPB_MR_FrameRate_Reserved10       ///< Reserved for future use 
    };

    enum enMFPB_Level_t
    {
      eMFPB_Level_Auto,
      eMFPB_Level_1,
      eMFPB_Level_1b,
      eMFPB_Level_1_1,
      eMFPB_Level_1_2,
      eMFPB_Level_1_3,
      eMFPB_Level_2,
      eMFPB_Level_2_1,
      eMFPB_Level_2_2,
      eMFPB_Level_3,
      eMFPB_Level_3_1,
      eMFPB_Level_3_2,
      eMFPB_Level_4,
      eMFPB_Level_4_1,
      eMFPB_Level_4_2,
      eMFPB_Level_Reserved1,
      eMFPB_Level_Reserved2,      
      eMFPB_Level_Reserved3,
      eMFPB_Level_Reserved4,
      eMFPB_Level_Reserved5      
    };
    
    enum enMFPB_EntropyEncoding_t
    {
      eMFPB_EntropyEncoding_Auto,
      eMFPB_EntropyEncoding_CAVLC,  
      eMFPB_EntropyEncoding_CABAC,     ///< Not allowed in case of baseline profile
      eMFPB_EntropyEncoding_Reserved1,
      eMFPB_EntropyEncoding_Reserved2,
      eMFPB_EntropyEncoding_Reserved3
    };
    
    
    /** MultiResolution Video encode settings.
     *
     * @version Release 11.10
     */
    struct MFPB_MultiResVideoEncodeSettings_t
    {
      enMFPB_BitrateMode           enBitrateMode;          ///< Choose between CBR and Capped VBR
      unsigned long                uCustomVertResolution;  ///< Range: [1080-96] Multiple of 16 or one of (1080,720,600,576,544,480,360,320,288,272,240,224,180,160)
      unsigned long                uCustomHorizResolution; ///< Range: [1920-96] Multiple of 16 or one of (1920,1440,1280,1080,960,800,720,640,544,528,480,400,352,320,240,208,176,160,128)
      enMFPB_MR_FrameRate_t        enMFPB_FrameRate;
      enMFPB_Profile_t             enMFPB_Profile;
      enMFPB_Level_t               enLevel;
      enMFPB_EntropyEncoding_t     enEntropyEncoding;
      unsigned long                Bitrate;                ///< (kbps) Range: 300 kbps-64 Mbps

      enMFPB_GopStructure_t        enMFPB_GopStructure;    ///< The mode of the GOP structure (Follow input and keep closed GOP not allowed)
      boolean                      bHierarchical;          ///< AVC only. Hierarchical layered structure, default disabled
      unsigned short               GopBPictures;           ///< Amount of B pictures. Range 0 to 5, default 2. 0 means IPP.
      unsigned short               GopSize;                ///< Number of I coded frames per gop. Range: 1..600, default 15, 1 means no B or P frames 
      unsigned long                AVCIDR_Interval;        ///< Not used for the moment

      enMFPB_ClosedCaptions_t      enClosedCaptions;       ///< Disable, auto
    };

    /** MultiRes video encode settings together with field identifying the video component they're for.
     *
     * @version Release 11.10
     */
    struct MFPB_MultiResVideoEncode_t
    {
      MFPB_TrackingID_t                     TrackingId; ///< Must be equal to the tracking ID of a video decode
      MFPB_MultiResVideoEncodeSettings_t    Settings;
    };
    typedef sequence<MFPB_MultiResVideoEncode_t> MFPB_MultiResVideoEncodeList_t;

    struct MFPB_MultiResVideoEncodeCfg_t
    {
      IPS_RefSvc_t             Service; ///< MulitRes service reference
      MFPB_MultiResVideoEncodeList_t   VideoEncodeList;
    };
    typedef sequence<MFPB_MultiResVideoEncodeCfg_t> MFPB_MultiResVideoEncodeCfgList_t;
    
    /** Create and or set the video encoding settings for one or more multi resolution services
     *  belonging to one particular main service.
     *
     * @param[in] MainService        The main service for which to configure
     *                               the multi resolution video encodings
     * @param[in] MultiResVideoEncodeCfgList The video encoding settings for each multi resolution service
     *
     * @note The TrackingID must always correspond to a video decode tracking ID
     *       configured with VideoDecodeCfgSetL(..). 
     *       The IPS_RefSvc_t parameter in the VideoEncodeCfgList must match with an earlier
     *       created multi resolution service unless it is set to INVALID (all fields set to INVALID_REF or INVALID_SID).
     *       When set to INVALID, a new multi resolution service will be created with the given video settings.
     *       A new IPS_RefSvc_t and User Tag will be automatically allocated for this service.
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed in case:
     * - invalid references are used (RefSvc)
     * - no video decode was configured
     * - if the configuration cannot be accepted by the processing engine mode   
     * - invalid settings are passed  
     *
     * @version Release 11.10
     */
    void MFPB_MultiResVideoEncodeCfgSetL(in IPS_RefSvc_t MainService,
                               in MFPB_MultiResVideoEncodeCfgList_t MultiResVideoEncodeCfgList)
        raises(TimeOut, OperationFailed, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);  

    /** Get the video encoding settings for the multi resolution services
     *  belonging to one particular main service.
     *
     * @param[in]  MainService        The main service from which to retrieve the 
     *                                multi resolution video encodings settings
     * @param[out] MultiResVideoEncodeCfgList The video encoding settings for all multi resolution
     *                                services belonging to the specified main service.
     * @exception OpNotSupported When BoardNr is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed in case:
     * - invalid references are used (RefSvc)  
     *
     * @version Release 11.10
     */
    void MFPB_MultiResVideoEncodeCfgGetL(in IPS_RefSvc_t MainService,
                               out MFPB_MultiResVideoEncodeCfgList_t MultiResVideoEncodeCfgList)
        raises(TimeOut, OperationFailed, OpNotSucceeded, OpNotAllowed, OpNotSupported);       
    
    /**
     * Delete one or more multi resolution services on a MFP board from a particular main service.
     * The service is only deleted if the service is not passed anymore to an IO board.
     *
     * @param[in]  MainService        The main service from which to delete the 
     *                                multi resolution video encodings settings
     * @param[in] RefSvcList A list of multi resolution services to delete.
     *
     * @exception OpNotSucceeded In case
     * - Invalid references are used (RefSvcList).
     * - Inconsistency between BoardNr & ServiceList[x].Ref.PhysRef.BoardNr.
     * - At least one of the services is passed to an IO board.
     * @exception OpNotAllowed not logged in
     * @exception OpNotSupported if BoardNr is not the board number of a MFP board
     *
     * @version Release 11.10
     *
     */
    void MFPB_MultiResVideoEncodeDeleteL(in IPS_RefSvc_t MainService, in IPS_RefSvc_List_t RefSvcList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Set the ABR settings for all multi resolution services
     *  belonging to one particular main service.
     *
     * @param[in] SlotNbr The Multi format processor (MFP) board to apply the settings to
     * @param[in] MultiResABR_List The ABR settings for all multi resolution
     *                                services belonging to the specified main service.
     * @exception OpNotSupported When BoardNr is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed in case:
     * - invalid references are used (RefSvc)
     * - not a service on a MultiRes engine
     * - Invalid ABR settings supplied
     *
     * @version Release 11.10
     */        
    void MFPB_SetMultiResABR(in unsigned short SlotNbr, in MFPB_MultiResABR_List_t MultiResABR_List)        
        raises(TimeOut, OperationFailed, OpNotSucceeded, OpNotAllowed, OpNotSupported);      

    /** Get the ABR settings for all multi resolution services
     *  belonging to one particular main service.
     *
     * @param[in] SlotNbr The Multi format processor (MFP) board to apply the settings to
     * @param[in] RefSvcList A list of multi resolution services to delete.     
     * @param[out] MultiResABR_List The ABR settings for all multi resolution
     *                                services belonging to the specified main service.
     * @exception OpNotSupported When BoardNr is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed in case:
     * - invalid references are used (RefSvc)
     *
     * @version Release 11.10
     */            
    void MFPB_GetMultiResABR(in unsigned short SlotNbr, in IPS_RefSvc_List_t RefSvcList,
                               out MFPB_MultiResABR_List_t MultiResABR_List)
        raises(TimeOut, OperationFailed, OpNotSucceeded, OpNotAllowed, OpNotSupported);              

    /** Set the ESAM settings for all multi resolution services
     *  belonging to one particular main service.
     *
     * @param[in] SlotNbr The Multi format processor (MFP) board to apply the settings to
     * @param[in] MultiResESAM_List The ESAM settings for all multi resolution
     *                                services belonging to the specified main service.
     * @exception OpNotSupported When BoardNr is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed in case:
     * - invalid references are used (RefSvc)
     * - not a service on a MultiRes engine
     * - Invalid ESAM settings supplied
     *
     * @version Release 12.0
     */
    void MFPB_SetMultiResESAM(in unsigned short SlotNbr, in MFPB_MultiResESAM_List_t MultiResESAM_List)
        raises(TimeOut, OperationFailed, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the ESAM settings for all multi resolution services
     *  belonging to one particular main service.
     *
     * @param[in] SlotNbr The Multi format processor (MFP) board to get the settings from 
     * @param[in] RefSvcList A list of multi resolution services to get.     
     * @param[out] MultiResESAM_List The ESAM settings for all multi resolution
     *                                services belonging to the specified main service.
     * @exception OpNotSupported When BoardNr is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed in case:
     * - invalid references are used (RefSvc)
     *
     * @version Release 12.0
     */
    void MFPB_GetMultiResESAM(in unsigned short SlotNbr, in IPS_RefSvc_List_t RefSvcList,
                               out MFPB_MultiResESAM_List_t MultiResESAM_List)
        raises(TimeOut, OperationFailed, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the default ESAM settings for all new multi resolution services
     *  being added to a particular board.
     *
     * @param[in] SlotNbr The Multi format processor (MFP) board to apply the settings to
     * @param[in] DefaultESAM The ESAM settings for all new multi resolution
     *                                services being added to the specified MFP board.
     * @exception OpNotSupported When BoardNr is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed in case:
     * - Invalid ESAM settings supplied
     *
     * @version Release 12.0
     */
    void MFPB_SetDefaultESAM(in unsigned short SlotNbr, in MFPB_DefaultESAM_t DefaultESAM)
        raises(TimeOut, OperationFailed, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the default ESAM settings for all multi resolution services
     *  belonging to a particular board.
     *
     * @param[in] SlotNbr The Multi format processor (MFP) board to get the settings for 
     * @param[out] DefaultESAM The default ESAM settings for all multi resolution
     *                                services belonging to the specified MFP board.
     * @exception OpNotSupported When BoardNr is not a
     *                           Multi format processor (MFP) board.
     *
     * @version Release 12.0
     */
    void MFPB_GetDefaultESAM(in unsigned short SlotNbr, 
                               out MFPB_DefaultESAM_t DefaultESAM)
        raises(TimeOut, OperationFailed, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    // MFP - Audio settings
    ///////////////////////////////////////////////////////////////////////////////////////

    enum enMFPB_AudioFormat_t
    {
      eMFPB_AudioFormat_MPEG1_Layer2,
      eMFPB_AudioFormat_AC3,
      eMFPB_AudioFormat_DolbyDigitalPlus, 
      eMFPB_AudioFormat_DolbyDigitalPulse, ///< Reserved for future 
      eMFPB_AudioFormat_LC_AAC,            ///< When used in decoder, this is handled as AAC.
      eMFPB_AudioFormat_HE_AACv1,          ///< When used in decoder, this is handled as AAC.
      eMFPB_AudioFormat_HE_AACv2,          ///< When used in decoder, this is handled as AAC.
      eMFPB_AudioFormat_AAC,               ///< Wildcard AAC format: All possible AAC formats, only used for audio decoder settings.
      eMFPB_AudioFormat_Reserved9,         ///< Reserved for future 
      eMFPB_AudioFormat_Reserved10,        ///< Reserved for future 
      eMFPB_AudioFormat_Reserved11,        ///< Reserved for future 
      eMFPB_AudioFormat_Reserved12,        ///< Reserved for future 
      eMFPB_AudioFormat_Reserved13,        ///< Reserved for future 
      eMFPB_AudioFormat_Reserved14,        ///< Reserved for future 
      eMFPB_AudioFormat_Reserved15         ///< Reserved for future 
    };

    enum enMFPB_AudioChannelConfiguration_t
    {
      eMFPB_AudioChannelConfig_Mono,       ///< Cannot be used for a audio decoder. Cannot be used in combination with (encoder) format HE_AACv2 
      eMFPB_AudioChannelConfig_Stereo,
      eMFPB_AudioChannelConfig_ACC_5_1,    ///< 5.1 Channels. Cannot be used in combination with  formats MPEG1_Layer2 and HE_AACv2
      eMFPB_AudioChannelConfig_Reserved3,  ///< Reserved for future  
      eMFPB_AudioChannelConfig_Reserved4,  ///< Reserved for future  
      eMFPB_AudioChannelConfig_Reserved5,  ///< Reserved for future  
      eMFPB_AudioChannelConfig_Reserved6,  ///< Reserved for future  
      eMFPB_AudioChannelConfig_Reserved7,  ///< Reserved for future  
      eMFPB_AudioChannelConfig_Reserved8,  ///< Reserved for future  
      eMFPB_AudioChannelConfig_Reserved9,  ///< Reserved for future  
      eMFPB_AudioChannelConfig_Reserved10  ///< Reserved for future  
    };

    enum enMFPB_AudioStatusChannelConfiguration_t
    {
      eMFPB_AudioStatusChannelConfig_MPEGLII_1_0, ///< 1.0
      eMFPB_AudioStatusChannelConfig_MPEGLII_1_1, ///< 1+1
      eMFPB_AudioStatusChannelConfig_MPEGLII_2,   ///< 2.0 Stereo
      eMFPB_AudioStatusChannelConfig_MPEGLII_2_JS,///< 2.0 Joint Stereo
      eMFPB_AudioStatusChannelConfig_DD_1_0,      ///< 1/0
      eMFPB_AudioStatusChannelConfig_DD_1_1,      ///< 1+1
      eMFPB_AudioStatusChannelConfig_DD_2_0,      ///< 2/0
      eMFPB_AudioStatusChannelConfig_DD_3_0,      ///< 3/0
      eMFPB_AudioStatusChannelConfig_DD_2_1,      ///< 2/1
      eMFPB_AudioStatusChannelConfig_DD_3_1,      ///< 3/1
      eMFPB_AudioStatusChannelConfig_DD_2_2,      ///< 2/2
      eMFPB_AudioStatusChannelConfig_DD_3_2,      ///< 3/2
      eMFPB_AudioStatusChannelConfig_AAC_1_0,     ///< 1.0
      eMFPB_AudioStatusChannelConfig_AAC_2_0,     ///< 2.0
      eMFPB_AudioStatusChannelConfig_AAC_3_0,     ///< 3.0
      eMFPB_AudioStatusChannelConfig_AAC_4_0,     ///< 4.0
      eMFPB_AudioStatusChannelConfig_AAC_5_0,     ///< 5.0
      eMFPB_AudioStatusChannelConfig_AAC_5_1,     ///< 5.1 
      eMFPB_AudioStatusChannelConfig_AAC_7_1,     ///< 7.1, Reserved for future use
      eMFPB_AudioStatusChannelConfig_Reserved1,   ///< Reserved for future
      eMFPB_AudioStatusChannelConfig_Reserved2,   ///< Reserved for future
      eMFPB_AudioStatusChannelConfig_Reserved3,   ///< Reserved for future
      eMFPB_AudioStatusChannelConfig_Reserved4,   ///< Reserved for future
      eMFPB_AudioStatusChannelConfig_Reserved5,   ///< Reserved for future
      eMFPB_AudioStatusChannelConfig_Reserved6,   ///< Reserved for future
      eMFPB_AudioStatusChannelConfig_Reserved7,   ///< Reserved for future
      eMFPB_AudioStatusChannelConfig_Reserved8,   ///< Reserved for future
      eMFPB_AudioStatusChannelConfig_Reserved9,   ///< Reserved for future
      eMFPB_AudioStatusChannelConfig_Reserved10,  ///< Reserved for future
      eMFPB_AudioStatusChannelConfig_Reserved11,  ///< Reserved for future
      eMFPB_AudioStatusChannelConfig_Reserved12,  ///< Reserved for future
      eMFPB_AudioStatusChannelConfig_Reserved13,  ///< Reserved for future
      eMFPB_AudioStatusChannelConfig_Reserved14,  ///< Reserved for future
      eMFPB_AudioStatusChannelConfig_Reserved15,  ///< Reserved for future
      eMFPB_AudioStatusChannelConfig_Reserved16   ///< Reserved for future
    };  

    enum enMFPB_AudioSampleRate_t
    {
      eMFPB_AudioSampleRate_FollowInput,
      eMFPB_AudioSampleRate_22_05KHz,    ///< AAC only
      eMFPB_AudioSampleRate_24KHz,       ///< AAC only
      eMFPB_AudioSampleRate_32KHz,       ///< Not for Dolby formats
      eMFPB_AudioSampleRate_44_1KHz,     ///< Not for Dolby formats
      eMFPB_AudioSampleRate_48KHz,
      eMFPB_AudioSampleRate_Reserved1,   ///< Reserved for future
      eMFPB_AudioSampleRate_Reserved2,   ///< Reserved for future
      eMFPB_AudioSampleRate_Reserved3,   ///< Reserved for future
      eMFPB_AudioSampleRate_Reserved4,   ///< Reserved for future
      eMFPB_AudioSampleRate_Reserved5    ///< Reserved for future
    };

    enum enMFPB_AudioStatusSampleRate_t
    {
      eMFPB_AudioStatusSampleRate_22_05KHz,    ///< 22,05 kHz
      eMFPB_AudioStatusSampleRate_24KHz,       ///< 24 kHz
      eMFPB_AudioStatusSampleRate_32KHz,       ///< 32 kHz
      eMFPB_AudioStatusSampleRate_44_1KHz,     ///< 44,1 kHz
      eMFPB_AudioStatusSampleRate_48KHz,       ///< 48 kHz
      eMFPB_AudioStatusSampleRate_96KHz,       ///< 96 KHz
      eMFPB_AudioStatusSampleRate_88_2KHz,     ///< 88,2 KHz
      eMFPB_AudioStatusSampleRate_64KHz,       ///< 64 KHz
      eMFPB_AudioStatusSampleRate_16KHz,       ///< 16 KHz
      eMFPB_AudioStatusSampleRate_12KHz,       ///< 12 KHz
      eMFPB_AudioStatusSampleRate_11_025KHz,   ///< 11,025 KHz
      eMFPB_AudioStatusSampleRate_8KHz,        ///< 8 KHz
      eMFPB_AudioStatusSampleRate_7_35KHz,     ///< 7,35 KHz
      eMFPB_AudioStatusSampleRate_Reserved1,   ///< Reserved for future
      eMFPB_AudioStatusSampleRate_Reserved2,   ///< Reserved for future
      eMFPB_AudioStatusSampleRate_Reserved3,   ///< Reserved for future
      eMFPB_AudioStatusSampleRate_Reserved4,   ///< Reserved for future
      eMFPB_AudioStatusSampleRate_Reserved5,   ///< Reserved for future
      eMFPB_AudioStatusSampleRate_Reserved6,   ///< Reserved for future
      eMFPB_AudioStatusSampleRate_Reserved7,   ///< Reserved for future
      eMFPB_AudioStatusSampleRate_Reserved8,   ///< Reserved for future
      eMFPB_AudioStatusSampleRate_Reserved9,   ///< Reserved for future
      eMFPB_AudioStatusSampleRate_Reserved10,  ///< Reserved for future
      eMFPB_AudioStatusSampleRate_Reserved11,  ///< Reserved for future
      eMFPB_AudioStatusSampleRate_Reserved12,  ///< Reserved for future
      eMFPB_AudioStatusSampleRate_Reserved13,  ///< Reserved for future
      eMFPB_AudioStatusSampleRate_Reserved14,  ///< Reserved for future
      eMFPB_AudioStatusSampleRate_Reserved15,  ///< Reserved for future
      eMFPB_AudioStatusSampleRate_Reserved16   ///< Reserved for future
    };

    struct MFPB_AudioStatus_t
    {
      enMFPB_AudioFormat_t                      AudioFormat;
      enMFPB_AudioStatusChannelConfiguration_t  InputChannelConfig;
      enMFPB_AudioStatusSampleRate_t            SampleRate;
      boolean                                   bLfeEnable;          ///< LFE on(true)/off, only for AAC and Dolby.
      long                                      AudioLevel;          ///< Reserved for future
    };

    struct MFPB_AudioInformation_t
    {
      MFPB_TrackingID_t     TrackingId;
      MFPB_AudioStatus_t    DecoderStatus;
    };
    typedef sequence<MFPB_AudioInformation_t> MFPB_AudioInformationList_t;

    struct MFPB_AudioServiceInformation_t
    {
      IPS_RefSvc_t                 Service;
      MFPB_AudioInformationList_t  AudioInformation;
    };
    typedef sequence<MFPB_AudioServiceInformation_t> MFPB_AudioServiceInformationList_t;

    /** Get audio status information.
     * Information is only available for audio streams which are currently being processed.
     *
     * @param[in]  BoardNr       The Multi format processor (MFP) board for which to get information.
     * @param[in]  ServiceList   The list of services of interest.
     * @param[out] AudioInfoList The status of the audio streams.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a Multi format processor (MFP) board.
     * @exception OperationFailed In case:
     * - invalid input references are used (BoardNr, RefSvc).
     *
     * @version Release 10.10
     **/
    void MFPB_AudioInformationGetL(in unsigned short BoardNr, in IPS_Service_List_t ServiceList, out MFPB_AudioServiceInformationList_t AudioInfoList)
         raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Audio decode settings together with fields identifying the Audio component they're for.
     *
     * @version Release 10.0
     */
    struct MFPB_AudioDecode_t
    {
      MFPB_TrackingID_t                  TrackingId;         ///< 0 when creating a new entry
      TrackingCriterium_t                TrackingCriterium;
      enMFPB_AudioFormat_t               InputFormat;        ///< Format of the input

      /** Input channel configuration.
      * Allowed values are Stereo and 5.1.
      * Use stereo when mono, dual mono or stereo is expected at the input.
      **/
      enMFPB_AudioChannelConfiguration_t InputChannelConfig;
    };
    typedef sequence<MFPB_AudioDecode_t> MFPB_AudioDecodeList_t;

    struct MFPB_AudioDecodeCfg_t
    {
      IPS_RefSvc_t               Service;
      MFPB_AudioDecodeList_t     AudioDecodeList;
    };
    typedef sequence<MFPB_AudioDecodeCfg_t> MFPB_AudioDecodeCfgList_t;  


    /** Set the Audio decoding settings.
     *
     * @param[in] BoardNr            The Multi format processor (MFP) board for which to configure
     *                               decoding
     * @param[in] AudioDecodeCfgList The Audio decoding settings
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed in case:
     * - audio processing is disabled on this board 
     * - invalid input references are used (RefSvc)
     * - if the configuration cannot be accepted by the processing engine mode
     * - there are no more processing resources available
     * - invalid settings are passed
     *
     * @version Release 10.0
     */
    void MFPB_AudioDecodeCfgSetL(in unsigned short BoardNr,
                               in MFPB_AudioDecodeCfgList_t AudioDecodeCfgList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported, LicenseError);

    /** Get the Audio decoding settings.
     *
     * @param[in]  BoardNr            The Multi format processor (MFP) board to retrieve the settings
     *                                from
     * @param[in]  ServiceList        The list of services of interest, an empty list returns all services
     * @param[out] AudioDecodeCfgList The Audio decoding settings, this is an empty list when the service has no settings
     *
     * @exception OperationFailed in case:
     * - invalid input references are used (RefSvc)
     *
     * @version Release 10.0
     */
    void MFPB_AudioDecodeCfgGetL(in unsigned short BoardNr,
                               in IPS_Service_List_t ServiceList,
                               out MFPB_AudioDecodeCfgList_t AudioDecodeCfgList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Remove the Audio decoding settings.
     *
     * @param[in] BoardNr   The Multi format processor (MFP) board for which to configure decoding
     * @param[in] ToDelete  A list of IDs for Audio decoding settings to delete
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed In case:
     * - invalid input references are used (RefSvc, TrackingID).
     *
     * @version Release 10.0
     */
    void MFPB_AudioDecodeCfgDeleteL(in unsigned short BoardNr,
                                  in MFPB_ServiceTrackingID_List_t ToDelete)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);   

    /** Audio encode settings.
     *
     * @version Release 10.0
     */
    struct MFPB_AudioEncodeSettings_t
    {
      enMFPB_AudioFormat_t                enFormat;             ///< Audio encoding format, see enMFPB_AudioFormat_t for supported formats

      /** Bitrate in bps
       *
       * Valid values (in kbps)
       * - MPEG-1 Layer II:
       *    - Mono: 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, [Default 96]
       *    - Stereo + Dual Mono: 64, 96, 112, 128, 160, 192, 224, 256, 320, 384, [Default 192]
       * - Dolby Digital (AC-3):
       *    - Mono: 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320 [Default 112]. Bitrates 384, 448, 576 and 640 will be behave equivalent to 320 from release 10.10 onwards.  
       *    - Stereo: 96, 112, 128, 160, 192, 224, 256, 320, 384, 448, 512, 576, 640 [Default 224].
       *    - 5.1: 192, 224, 256, 320, 384, 448, 512, 576, 640 [Default 384]
       * - AAC-LC:
       *   - Mono: full range [32 kbps to (output sample rate in kHz * 6 * 1)],  96 kbps by default
       *   - Dual Mono: not supported 
       *   - Stereo: full range [32 kbps to (output sample rate in kHz * 6 * 2)], 128 kbps by default
       *   - 5.1: full range [64 kbps to (minimim between 640 kbps and { (25.2 * output sample rate in Hz + 8000)/1000 } ], 160 kbps by default
       * - HE AAC v1:
       *   - Mono: full range [32 kbps to (output sample rate in kHz * 3 * 1)],  96 kbps by default
       *   - Dual Mono: not supported
       *   - Stereo: full range [32 kbps to (output sample rate in kHz * 3 * 2)], 128 kbps by default
       *   - 5.1: full range [64 kbps to (minimim between 576 kbps and { (12.6 * output sample rate in Hz + 8000)/1000 } ], 160 kbps by default    
       * - HE AAC v2:
       *   - Mono: not support
       *   - Dual Mono: not supported
       *   - Stereo: full range [32 kbps to (output sample rate in kHz * 3 * 2)],  128 kbps by default   
       *   - 5.1: not supported  
       * -  Dolby Digital Plus:
       *   - Mono: 56, 64, 72, 80, 88, 96, 104, 112, 120, 128, 144, 160, 176, 192, 200, 208, 224, 232, 240, 248, 256, 272, 288, 304, 320 [Default 112].
       *   - Stereo + Dual Mono: 96, 104, 112, 120, 128, 144, 160, 176, 192, 200, 208, 224, 232, 240, 248, 256, 272, 288, 304, 320, 336, 352, 368, 384, 400, 448, 512, 576, 640 [Default 224].
       *   - 5.1: 192, 200, 208, 224, 232, 240, 248, 256, 272, 288, 304, 320, 336, 352, 368, 384, 400, 448, 512, 576, 640 [Default 384]
       *
       * Note: If the samplerate is set to followinput, it is assumed the incomming samplerate is 48kHz. If the real input is different, 
       *       the bitrate is set to the closed allowed value and the "Audio Bitrate Altered" alarm is raised.
       **/     
      unsigned long                       Bitrate;              ///< encoding bitrate Unit in [bps],
      long                                LevelAdjustment;      ///< Unit in dB times 10, Gui range -20 to 20 this is equivalent to value range -200 to 200.
      enMFPB_AudioSampleRate_t            enSampleRate;         ///< Must be follow input
      enMFPB_AudioChannelConfiguration_t  enStreamConfiguration;///< Number of output channels. If source contains less channels, basic up mix will be performed.
      long                                LipSyncAdjustment;    ///< +/- 300 ms for lipsync adjustment.

      //General audio processing settings
      boolean                             bCopyright;           ///< Not used (behaviour is follow input, or true if not available), Copyright, [yes (true) by default]
      boolean                             bOriginal;            ///< Not used (behaviour isfollow input, or true if not available), Original, [yes (true) by default]
    };

    /** Audio encode settings together with field identifying the Audio component they're for.
     *
     * @version Release 10.0
     */
    struct MFPB_AudioEncode_t
    {
      MFPB_TrackingID_t          TrackingId; ///< Must be equal to the tracking ID of a Audio decode
      MFPB_AudioEncodeSettings_t Settings;
    };
    typedef sequence<MFPB_AudioEncode_t> MFPB_AudioEncodeList_t;

    struct MFPB_AudioEncodeCfg_t
    {
      IPS_RefSvc_t             Service;
      MFPB_AudioEncodeList_t     AudioEncodeList;
    };
    typedef sequence<MFPB_AudioEncodeCfg_t> MFPB_AudioEncodeCfgList_t;

    /** Set the Audio encoding settings.
     *
     * @param[in] BoardNr            The Multi format processor (MFP) board for which to configure
     *                               encoding
     * @param[in] AudioEncodeCfgList The Audio encoding settings
     *
     * @note The TrackingID must always correspond to a Audio decode tracking ID
     *       configured with AudioDecodeCfgSetL(..).  *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed in case:
     * - audio processing is disabled on this board 
     * - invalid input references are used (RefSvc)
     * - no Audio decode was configured
     * - if the configuration cannot be accepted by the processing engine mode
     * - invalid settings are passed:
     *    - bitrate too high/low
     *    - ...
     * - There are no more processing resources available
     *
     * @version Release 10.0
     */
    void MFPB_AudioEncodeCfgSetL(in unsigned short BoardNr,
                               in MFPB_AudioEncodeCfgList_t AudioEncodeCfgList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported, LicenseError);

    /** Get the Audio encoding settings.
     *
     * @param[in]  BoardNr            The Multi format processor (MFP) board to retrieve the settings
     *                                from
     * @param[in]  ServiceList        The list of services of interest.
     * @param[out] AudioEncodeCfgList The Audio encoding settings
     *
     * @exception OperationFailed in case:
     * - invalid input references are used (RefSvc)
     *
     * @version Release 10.0
     */
    void MFPB_AudioEncodeCfgGetL(in unsigned short BoardNr,
                               in IPS_Service_List_t ServiceList,
                               out MFPB_AudioEncodeCfgList_t AudioEncodeCfgList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Remove the Audio encoding settings and all settings related to it (AAC/Dolby audio settings)
     *
     * @param[in] BoardNr   The Multi format processor (MFP) board for which to configure encoding
     * @param[in] ToDelete  A list of IDs for Audio encoding settings to delete
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed In case:
     * - invalid input references are used (RefSvc, TrackingID).
     *
     * @version Release 10.0
     */
    void MFPB_AudioEncodeCfgDeleteL(in unsigned short BoardNr,
                                  in MFPB_ServiceTrackingID_List_t ToDelete)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);   

    /** MPEG1-L2 audio processing settings.
     *
     * @version Release 10.10
     */
    struct MFPB_MPEGL2_AudioSettings_t
    {
      MFPB_TrackingID_t  TrackingId;            ///< Identifies the elementary streams encoder where the setting should be added to          
      boolean            bJointStereoEnable;    ///< Joint Stereo [true (enable) default, false (disable)].
    };
    typedef sequence<MFPB_MPEGL2_AudioSettings_t> MFPB_MPEGL2_AudioSettingsList_t;

    /** Configuration settings for the MPEG1-L2 audio settings of a service.
     */
    struct MFPB_MPEGL2AudioCfg_t
    {
      IPS_RefSvc_t                     Service;
      MFPB_MPEGL2_AudioSettingsList_t  MPEGL2_AudioSettingsList; ///< MPEG1-L2 Audio settings per ES
    };
    typedef sequence<MFPB_MPEGL2AudioCfg_t> MFPB_MPEGL2AudioCfgList_t;  

    /** Set the MPEG1-L2 audio processing settings.
     *
     * @param[in] BoardNr            The Multi format processor (MFP) board for which to configure
     *                               encoding
     * @param[in] MPEGL2AudioCfgList The MPEG1-L2 Audio settings
     *
     * @note The TrackingID must always correspond to a encoder tracking ID
     *       configured with AudioEncodeCfgSetL(..).  *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed in case:
     * - audio processing is disabled on this board
     * - invalid input references are used (RefSvc)
     * - no Audio encoder was configured
     * - related audio encoder with format different from MPEG1-L2
     * - if the configuration cannot be accepted by the processing engine mode
     * - invalid settings are passed:
     * - There are no more processing resources available
     *
     * @version Release 10.10
     */
    void MFPB_MPEGL2AudioCfgSetL(in unsigned short BoardNr,
                               in MFPB_MPEGL2AudioCfgList_t MPEGL2AudioCfgList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported, LicenseError);

    /** Get the MPEG1-L2 audio processing settings.
     *
     * @param[in]  BoardNr            The Multi format processor (MFP) board to retrieve the settings
     *                                from
     * @param[in]  ServiceList        The list of services of interest.
     * @param[out] MPEGL2AudioCfgList The MPEG1-L2 Audio settings
     *
     * @exception OperationFailed in case:
     * - invalid input references are used (RefSvc)
     *
     * @version Release 10.10
     */
    void MFPB_MPEGL2AudioCfgGetL(in unsigned short BoardNr,
                               in IPS_Service_List_t ServiceList,
                               out MFPB_MPEGL2AudioCfgList_t MPEGL2AudioCfgList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);      

    enum enMFPB_AAC_TransportPacketMode_t
    {
      eMFPB_PacketMode_MPEG2_ADTS,      ///< MPEG-2 ADTS
      eMFPB_PacketMode_MPEG4_ADTS,      ///< MPEG-4 ADTS (No CRC)
      eMFPB_PacketMode_MPEG4_LATM,      ///< MPEG-4 LATM/LOAS
      eMFPB_PacketMode_MPEG4_LATM_EXPL, ///< MPEG-4 LATM/LOAS explicit, AAC HE only
      eMFPB_PacketMode_MPEG4_ADTS_CRC,  ///< For Future functionality, MPEG-4 ADTS + CRC
      eMFPB_PacketMode_Reserved5,       ///< For Future functionality
      eMFPB_PacketMode_Reserved6,       ///< For Future functionality
      eMFPB_PacketMode_Reserved7,       ///< For Future functionality
      eMFPB_PacketMode_Reserved8        ///< For Future functionality
    };

    enum enMFPB_AAC_AdvancedEncodingTools
    {
      eMFPB_AET_None,       ///< For AAC-LC
      eMFPB_AET_TNS,        ///< TNS
      eMFPB_AET_PNS_TNS,    ///< PNS + TNS
      eMFPB_AET_SBR,        ///< For HE-AACv1: SBR
      eMFPB_AET_SBR_PS,     ///< For HE-AACv2: SBR + PS
      eMFPB_AET_DRC,        ///< For Future functionality
      eMFPB_AET_Reserved7,  ///< For Future functionality
      eMFPB_AET_Reserved8,  ///< For Future functionality
      eMFPB_AET_Reserved9,  ///< For Future functionality
      eMFPB_AET_Reserved10  ///< For Future functionality
    };

    /** AAC audio processing settings.
     *
     * @version Release 10.0
     */
    struct MFPB_AAC_AudioSettings_t
    {
      MFPB_TrackingID_t            TrackingId;      ///< Identifies the elementary streams encoder where the setting should be added to       

      //Basic AAC 
      enMFPB_AAC_TransportPacketMode_t    enTransportPacketizationMode; ///< Bit stream mode, [MPEG-4 LATM/LOAS by default]

      /** enAdvancedEncodingTools is constrained by:
       *  - MFPB_AudioEncodeSettings_t.enMFPB_AudioFormat_t (LC_AAC, HE_AACv1, HE_AACv2)
       *  - MFPB_AAC_AudioSettings_t.enMFPB_AAC_TransportPacketMode_t (MPEG2_ADTS, MPEG4_ADTS, MPEG4_LATM, MPEG4_LATM_EXPL)
       *
       *  Constraints when setting:
       *  - For HE_AACv1, enAdvancedEncodingTools must be eMFPB_AET_SBR
       *  - For future use: For HE_AACv2, enAdvancedEncodingTools must eMFPB_AET_SBR_PS
       *  - For LC_AAC + MPEG2_ADTS, enAdvancedEncodingTools cannot be eMFPB_AET_PNS_TNS
       *  - For LC_AAC + MPEG2_ADTS, enAdvancedEncodingTools cannot be eMFPB_AET_SBR 
       *  - For LC_AAC + MPEG2_ADTS, enAdvancedEncodingTools cannot be eMFPB_AET_SBR_PS
       *
       *  Defaults:
       *  - LC_AAC   [eMFPB_AET_None by default]
       *  - HE_AACv1 [eMFPB_AET_SBR by default]
       *  - For future use: HE_AACv2 [eMFPB_AET_SBR_PS by default]
       **/  
      enMFPB_AAC_AdvancedEncodingTools    enAdvancedEncodingTools;      ///< Advanced encoding tools

      // Multichannel specific
      boolean                             bLfeChannelEnable;            ///< LFE Channel Enable default true.
    };
    typedef sequence<MFPB_AAC_AudioSettings_t> MFPB_AAC_AudioSettingsList_t;

    /** Configuration settings for the AAC audio settings of a service.
     */
    struct MFPB_AacAudioCfg_t
    {
      IPS_RefSvc_t                   Service;
      MFPB_AAC_AudioSettingsList_t   AAC_AudioSettingsList; ///< AAC Audio settings per ES
    };
    typedef sequence<MFPB_AacAudioCfg_t> MFPB_AacAudioCfgList_t;  

    /** Set the AAC audio processing settings.
     *
     * @param[in] BoardNr            The Multi format processor (MFP) board for which to configure
     *                               encoding
     * @param[in] AacAudioCfgList The AAC Audio settings
     *
     * @note The TrackingID must always correspond to a encoder tracking ID
     *       configured with AudioEncodeCfgSetL(..).  *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed in case:
     * - audio processing is disabled on this board
     * - invalid input references are used (RefSvc)
     * - no Audio encoder was configured
     * - related audio encoder with format different from LC_AAC, HE_AACv1, HE_AACv2
     * - if the configuration cannot be accepted by the processing engine mode
     * - invalid settings are passed:
     *    - lMainMixingLevel too high/low
     *    - ...
     * - There are no more processing resources available
     *
     * @version Release 10.0
     */
    void MFPB_AACAudioCfgSetL(in unsigned short BoardNr,
                               in MFPB_AacAudioCfgList_t AacAudioCfgList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported, LicenseError);

    /** Get the AAC audio processing settings.
     *
     * @param[in]  BoardNr            The Multi format processor (MFP) board to retrieve the settings
     *                                from
     * @param[in]  ServiceList        The list of services of interest.
     * @param[out] AacAudioCfgList The AAC Audio settings
     *
     * @exception OperationFailed in case:
     * - invalid input references are used (RefSvc)
     *
     * @version Release 10.0
     */
    void MFPB_AACAudioCfgGetL(in unsigned short BoardNr,
                               in IPS_Service_List_t ServiceList,
                               out MFPB_AacAudioCfgList_t AacAudioCfgList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);      

    enum enMFPB_Dolby_BitStreamMode
    {
      eMFPB_BSM_CompleteMain,        ///< CompleteMain/Main
      eMFPB_BSM_MusicAndEffects,     ///< 
      eMFPB_BSM_VisualImpaired,      ///< 
      eMFPB_BSM_HearingImpaired,     ///< 
      eMFPB_BSM_Dialog,              ///< 
      eMFPB_BSM_Commentary,          ///< 
      eMFPB_BSM_EmergencyFlash,      ///< 
      eMFPB_BSM_MainMinusDialogue,   ///< For status only @see MFPB_DD_MetaDecStatus_t / @see MFPB_DD_MetaEncStatus_t
      eMFPB_BSM_VoiceOver,           ///< For status only @see MFPB_DD_MetaDecStatus_t / @see MFPB_DD_MetaEncStatus_t
      eMFPB_BSM_Karaoke,             ///< For status only @see MFPB_DD_MetaDecStatus_t / @see MFPB_DD_MetaEncStatus_t 
      eMFPB_BSM_Reserved7            ///< For Future functionality 
    };

    enum enMFPB_Dolby_DynamicRangeControl
    {
      eMFPB_DD_None,
      eMFPB_DD_FilmStandard,
      eMFPB_DD_FilmLight,
      eMFPB_DD_MusicStandard,
      eMFPB_DD_MusicLight,
      eMFPB_DD_Speech,
      eMFPB_DD_Reserved6, ///< For Future functionality 
      eMFPB_DD_Reserved7, ///< For Future functionality 
      eMFPB_DD_Reserved8, ///< For Future functionality 
      eMFPB_DD_Reserved9, ///< For Future functionality 
      eMFPB_DD_Reserved10 ///< For Future functionality 
    };

    enum enMFPB_Dolby_DigitalDeEmphasis
    {
      eMFPB_DDE_None,
      eMFPB_DDE_50_15us,
      eMFPB_DDE_Auto,      ///< For Future functionality 
      eMFPB_DDE_Reserved3, ///< For Future functionality 
      eMFPB_DDE_Reserved4, ///< For Future functionality 
      eMFPB_DDE_Reserved5, ///< For Future functionality 
      eMFPB_DDE_Reserved6  ///< For Future functionality 
    };

    enum enMFPB_Dolby_SurroundMode
    {
      eMFPB_DS_NotIndicated,
      eMFPB_DS_Disabled,
      eMFPB_DS_Enabled,
      eMFPB_DS_Reserver3,    ///< For Future functionality
      eMFPB_DS_Reserver4,    ///< For Future functionality
      eMFPB_DS_Reserver5,    ///< For Future functionality
      eMFPB_DS_Reserver6     ///< For Future functionality
    };

    enum enMFPB_Dolby_RoomType
    {
      eMFPB_DR_NotIndicated,
      eMFPB_DR_SmallRoom,
      eMFPB_DR_LargeRoom,
      eMFPB_DR_Reserved3,  ///< For Future functionality 
      eMFPB_DR_Reserved4,  ///< For Future functionality 
      eMFPB_DR_Reserved5,  ///< For Future functionality 
      eMFPB_DR_Reserved6   ///< For Future functionality 
    };

    /** Dolby audio processing settings.
     *
     * @version Release 10.0
     */
    struct MFPB_Dolby_AudioSettings_t
    {
      MFPB_TrackingID_t            TrackingId;      ///< Identifies the elementary streams encoder where the setting should be added to

      // Basic Dolby settings
      enMFPB_Dolby_BitStreamMode             enBitStreamMode;             ///< Bit stream mode, [CompleteMain by default]
      enMFPB_Dolby_DynamicRangeControl       enDynamicRangeControlLine;   ///< Dynamic range control (line), [FilmStandard by default]
      enMFPB_Dolby_DynamicRangeControl       enDynamicRangeControlRf;     ///< Dynamic range control (RF), [FilmStandard by default]
      boolean                                bBandwithLimitLowPassFilter; ///< Bandwith Limit Low Pass Filter, [Off (false) by default]
      boolean                                bDcHighPassFilter;           ///< DC High Pass Filter, [Off (false) by default]
      enMFPB_Dolby_DigitalDeEmphasis         enDigitalDeEmphasis;         ///< Digital De-Emphasis, [None by default]

      // Surround mode
      enMFPB_Dolby_SurroundMode              enSurroundMode;              ///< Surround Mode, [NotIndicated by default]
      long                                   lCentreMixLevel;             ///< For Future functionality, Unit in [dB]
      long                                   lSurroundMixLevel;           ///< For Future functionality, Unit in [dB]
      boolean                                bLFE_LowPassFilter;          ///< For Future functionality,
      boolean                                bPhaseShift;                 ///< For Future functionality 
      boolean                                bChannelAttenuation;         ///< For Future functionality

      // Dolby Digital Channel Settings
      boolean                                bMainProductInfoExists;        ///< Production Information Exists, [No (false) by default]
      enMFPB_Dolby_RoomType                  enRoomType;                    ///< Room Type, [SmallRoom by default]
      long                                   lMainMixingLevel;              ///< Mixing Level, Unit in [dB] - Range [80 <-> 111] - [105 by default]
      long                                   lMainDialogNormalizationLevel; ///< Dialog Normalization Level, Unit in [dB] - Range [-31 <-> -1] - [-23 by default]

      //Aux, only used in case of dual mono
      boolean                                bAuxProductionInfoExists;      ///< Aux Production Information Exists, [No (false) by default]
      enMFPB_Dolby_RoomType                  enAuxRoomType;                 ///< Aux Room Type, [SmallRoom by default]
      long                                   lAuxMixingLevel;               ///< Aux Mixing Level, Unit in [dB] - Range [80 <-> 111] - [105 by default]
      long                                   lAuxDialogNormalizationLevel;  ///< Aux Dialog Normalization Level, Unit in [dB] - Range [-31 <-> -1] - [-23 by default]

      // Extended BSI Settings
      enMFPB_Dolby_BitStreamMode             enExtendedBSI_BitStreamMode;   ///< For Future functionality,
      long                                   lLtRtCentreMixLevel;           ///< For Future functionality, Unit in [dB] 
      //Downmix mode is configured in encoder settings part
      long                                   lLtRtSurroundMixLevel;         ///< For Future functionality, Unit in [dB]
      long                                   lLoRoCentreMixLevel;           ///< For Future functionality, Unit in [dB]
      long                                   lLoRoSurroundMixLevel;         ///< For Future functionality, Unit in [dB]
      enMFPB_Dolby_SurroundMode              enSurroundExMode;              ///< For Future functionality
    };   
    typedef sequence<MFPB_Dolby_AudioSettings_t> MFPB_Dolby_AudioSettingsList_t;  

    /** Configuration settings for the Dolby audio settings of a service.
     */
    struct MFPB_DolbyAudioCfg_t
    {
      IPS_RefSvc_t                   Service;
      MFPB_Dolby_AudioSettingsList_t Dolby_AudioSettingsList; ///< Dolby Audio settings per ES
    };
    typedef sequence<MFPB_DolbyAudioCfg_t> MFPB_DolbyAudioCfgList_t;   

    /** Set the dolby audio processing settings.
     *
     * @param[in] BoardNr            The Multi format processor (MFP) board for which to configure
     *                               encoding
     * @param[in] DolbyAudioCfgList The dolby Audio settings
     *
     * @note The TrackingID must always correspond to a encoder tracking ID
     *       configured with AudioEncodeCfgSetL(..).  *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed in case:
     * - audio processing is disabled on this board 
     * - invalid input references are used (RefSvc)
     * - no Audio encoder was configured
     * - Audio encoder with format different from DolbyDigitalPlus or DolbyDigitalPulse was configured
     * - if the configuration cannot be accepted by the processing engine mode
     * - invalid settings are passed:
     *    - lMainMixingLevel too high/low
     *    - ...
     * - There are no more processing resources available
     *
     * @version Release 10.0
     */
    void MFPB_DolbyAudioCfgSetL(in unsigned short BoardNr,
                               in MFPB_DolbyAudioCfgList_t DolbyAudioCfgList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported, LicenseError);

    /** Get the dolby audio processing settings.
     *
     * @param[in]  BoardNr            The Multi format processor (MFP) board to retrieve the settings
     *                                from
     * @param[in]  ServiceList        The list of services of interest.
     * @param[out] DolbyAudioCfgList The dolby Audio settings
     *
     * @exception OperationFailed in case:
     * - invalid input references are used (RefSvc)
     *
     * @version Release 10.0
     */
    void MFPB_DolbyAudioCfgGetL(in unsigned short BoardNr,
                               in IPS_Service_List_t ServiceList,
                               out MFPB_DolbyAudioCfgList_t DolbyAudioCfgList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Select channels to keep when converting to stereo/dual mono
     *
     * @version Release 10.10
     */
    enum enMFPB_Downmix_ToStereo
    {
      eMFPB_Downmix_ToStereo_LTRT,
      eMFPB_Downmix_ToStereo_LORO,
      eMFPB_Downmix_ToStereo_Auto,
      eMFPB_Downmix_ToStereo_NotIndicated, ///< Do not indicate how to downconvert in dolby Meta data. Only use this in Dolby encoder settings.
      eMFPB_Downmix_ToStereo_Reserved2,    ///< For Future functionality
      eMFPB_Downmix_ToStereo_Reserved3,    ///< For Future functionality
      eMFPB_Downmix_ToStereo_Reserved4,    ///< For Future functionality
      eMFPB_Downmix_ToStereo_Reserved5,    ///< For Future functionality
      eMFPB_Downmix_ToStereo_Reserved6     ///< For Future functionality
    };

    /** Extended BSI Mode
     *
     * @version Release 10.10
     */
    enum enMFPB_ExtendedBSI_Mode
    {
      eMFPB_ExtendedBSI_Mode_Standard,
      eMFPB_ExtendedBSI_Mode_XBSI,
      eMFPB_ExtendedBSI_Mode_Reserved1, ///< For Future functionality 
      eMFPB_ExtendedBSI_Mode_Reserved2, ///< For Future functionality 
      eMFPB_ExtendedBSI_Mode_Reserved3, ///< For Future functionality 
      eMFPB_ExtendedBSI_Mode_Reserved4, ///< For Future functionality 
      eMFPB_ExtendedBSI_Mode_Reserved5, ///< For Future functionality 
      eMFPB_ExtendedBSI_Mode_Reserved6  ///< For Future functionality 
    };

    /** Extended Surround Mode
     *
     * @version Release 10.10
     */
    enum enMFPB_Dolby_SurroundExMode
    {
      eMFPB_DSExt_NotIndicated,
      eMFPB_DSExt_Disabled,      ///< Not Encoded in Dolby Digital Surround EX
      eMFPB_DSExt_Enabled,       ///< Encoded in Dolby Digital Surround EX
      eMFPB_DSExt_Reserverd1,    ///< For Future functionality
      eMFPB_DSExt_Reserverd2,    ///< For Future functionality
      eMFPB_DSExt_Reserverd3,    ///< For Future functionality
      eMFPB_DSExt_Reserverd4     ///< For Future functionality
    };

    /** Dolby audio processing settings.
     *
     * @version Release 10.10
     */
    struct MFPB_Dolby_AudioSettings_V2_t
    {
      MFPB_TrackingID_t            TrackingId;      ///< Identifies the elementary streams encoder where the setting should be added to

      // Basic Dolby settings
      enMFPB_Dolby_BitStreamMode             enBitStreamMode;             ///< Bit stream mode, [CompleteMain by default]
      enMFPB_Dolby_DynamicRangeControl       enDynamicRangeControlLine;   ///< Dynamic range control (line), [FilmStandard by default]
      enMFPB_Dolby_DynamicRangeControl       enDynamicRangeControlRf;     ///< Dynamic range control (RF), [FilmStandard by default]
      boolean                                bBandwithLimitLowPassFilter; ///< Bandwith Limit Low Pass Filter, [Off (false) by default]
      boolean                                bDcHighPassFilter;           ///< DC High Pass Filter, [Off (false) by default]
      enMFPB_Dolby_DigitalDeEmphasis         enDigitalDeEmphasis;         ///< Digital De-Emphasis, [None by default]

      // Surround mode (only used for multi-channel Dolby Digital encoding)
      boolean                                bLfeChannelEnable;           ///< LFE Channel Enable, [On (true) default, Off]
      enMFPB_Dolby_SurroundMode              enSurroundMode;              ///< Surround Mode, [NotIndicated by default]
      long                                   lCentreMixLevel;             ///< Center Mix Level (dB) times 10 (eg. value -45 will be -4.5 in the GUI). Discrete values [-3 (default), -4.5, -6]. Ingnored if enExtendedBSI_Mode is XBSI mode
      long                                   lSurroundMixLevel;           ///< Surround Mix Level (dB)  times 10 (eg. value -60 will be -6 in the GUI). Discrete values [-3 (default), -6, -99.9 (Infinite)]. Ingnored if enExtendedBSI_Mode is XBSI mode
      boolean                                bLFE_LowPassFilter;          ///< LFE Low Pass Filter, [On(true), Off default], Only used if LFE channel is enabled.
      boolean                                bPhaseShift;                 ///< Surround 90 deg Phase Shift, [On(true), Off default], Only used if LFE channel is enabled.
      boolean                                bChannelAttenuation;         ///< Surround Channel Attenuation, [On(true), Off default], Only used if LFE channel is enabled.

      // Dolby Digital Channel Settings
      boolean                                bMainProductInfoExists;        ///< Production Information Exists, [No (false) by default]
      enMFPB_Dolby_RoomType                  enRoomType;                    ///< Room Type, [SmallRoom by default]
      long                                   lMainMixingLevel;              ///< Mixing Level, Unit in [dB] - Range [80 <-> 111] - [105 by default]

      /* Dialog Normalization Level, Unit in [dB] - Range [-31 <-> -1] 
      *
      *  Defaults (at the moment the encoder is created. (the first time only):
      *  - Dolby, DolbyPlus, DolbyPulse decoder
      *    - Compression mode is line: the default value is -31
      *    - Compression mode is not line: the default value is -20
      *  - No Dolby, DolbyPlus, DolbyPulse decoder 
      *    - SI standaard ATSC, DC2: the default value is -24
      *    - SI standaard is not ATSC, DC2: the default value is -23  
      */
      long                                   lMainDialogNormalizationLevel;

      // Aux unsed in case of Dual Mono
      boolean                                bAuxProductionInfoExists;      ///< Aux Production Information Exists, [No (false) by default]. Only used for dual mono.
      enMFPB_Dolby_RoomType                  enAuxRoomType;                 ///< Aux Room Type, [SmallRoom by default]. Only used for dual mono.
      long                                   lAuxMixingLevel;               ///< Aux Mixing Level, Unit in [dB] - Range [80 <-> 111] - [105 by default]. Only used for dual mono.

      /* Aux Dialog Normalization Level, Unit in [dB] - Range [-31 <-> -1]. Only used for dual mono.
      *
      *  Defaults (at the moment the encoder is created. (the first time only):
      *  - Dolby, DolbyPlus, DolbyPulse decoder
      *    - Compression mode is line: the default value is -31
      *    - Compression mode is not line: the default value is -20
      *  - No Dolby, DolbyPlus, DolbyPulse decoder
      *    - SI standaard ATSC, DC2: the default value is -24
      *    - SI standaard is not ATSC, DC2: the default value is -23
      */    
      long                                   lAuxDialogNormalizationLevel;  ///< Aux Dialog Normalization Level, Unit in [dB] - Range [-31 <-> -1] - [-23 by default]. Only used for dual mono.

      // Extended BSI Settings (Meta data, not processing settings)
      enMFPB_ExtendedBSI_Mode                enExtBSI_Mode;                 ///< Extended BSI Mode. [standard, XBSI default]
      enMFPB_Downmix_ToStereo                enDownmix_ToStereo;            ///< Preferred Stereo Downmix Mode [LTRT, LORO, NotIndicated default]
      long                                   lLtRtCentreMixLevel;           ///< Lt/Rt Center Mix Level (dB) times 10 (eg. value -45 will be -4.5 in the GUI). Discrete values [3, 1.5, 0, -1.5, -3 (default), -4.5, -6, -99.9 (Infinite)] 
      long                                   lLtRtSurroundMixLevel;         ///< Lt/Rt Surround Mix Level (dB) times 10 (eg. value -45 will be -4.5 in the GUI). Discrete values [ -1.5, -3 (default), -4.5, -6, -99.9 (Infinite)]
      long                                   lLoRoCentreMixLevel;           ///< Lo/Ro Center Mix Level (dB) times 10 (eg. value -45 will be -4.5 in the GUI). Discrete values [3, 1.5, 0, -1.5, -3 (default), -4.5, -6, -99.9 (Infinite)]
      long                                   lLoRoSurroundMixLevel;         ///< Lo/Ro Surround Mix Level (dB) times 10 (eg. value -45 will be -4.5 in the GUI). Discrete values [-1.5, -3 (default), -4.5, -6, -99.9 (Infinite)]
      enMFPB_Dolby_SurroundExMode            enSurroundExMode;              ///< Dolby Surround Ex mode. Disabled default
    };
    typedef sequence<MFPB_Dolby_AudioSettings_V2_t> MFPB_Dolby_AudioSettingsList_V2_t; 

    /** Configuration settings for the Dolby audio settings of a service.
     */
    struct MFPB_DolbyAudioCfg_V2_t
    {
      IPS_RefSvc_t                   Service;
      MFPB_Dolby_AudioSettingsList_V2_t Dolby_AudioSettingsList; ///< Dolby Audio settings per ES
    };
    typedef sequence<MFPB_DolbyAudioCfg_V2_t> MFPB_DolbyAudioCfgList_V2_t;   

    /** Set the dolby audio processing settings.
     *
     * @param[in] BoardNr            The Multi format processor (MFP) board for which to configure
     *                               encoding
     * @param[in] DolbyAudioCfgList The dolby Audio settings
     *
     * @note The TrackingID must always correspond to a encoder tracking ID
     *       configured with AudioEncodeCfgSetL(..).  *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed in case:
     * - audio processing is disabled on this board 
     * - invalid input references are used (RefSvc)
     * - no Audio encoder was configured
     * - Audio encoder with format different from DolbyDigitalPlus or DolbyDigitalPulse was configured
     * - if the configuration cannot be accepted by the processing engine mode
     * - invalid settings are passed:
     *    - lMainMixingLevel too high/low
     *    - ...
     * - There are no more processing resources available
     *
     * @version Release 10.0
     */
    void MFPB_DolbyAudioCfgSetL_V2(in unsigned short BoardNr,
                               in MFPB_DolbyAudioCfgList_V2_t DolbyAudioCfgList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported, LicenseError);

    /** Get the dolby audio processing settings.
     *
     * @param[in]  BoardNr            The Multi format processor (MFP) board to retrieve the settings
     *                                from
     * @param[in]  ServiceList        The list of services of interest.
     * @param[out] DolbyAudioCfgList The dolby Audio settings
     *
     * @exception OperationFailed in case:
     * - invalid input references are used (RefSvc)
     *
     * @version Release 10.0
     */
    void MFPB_DolbyAudioCfgGetL_V2(in unsigned short BoardNr,
                               in IPS_Service_List_t ServiceList,
                               out MFPB_DolbyAudioCfgList_V2_t DolbyAudioCfgList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Select dual mono channels to keep when converting to mono
     *
     * @version Release 10.10
     */     
    enum enMFPB_Downmix_ToMono
    {
      eMFPB_Downmix_ToMono_Left,       ///< Keep left channel
      eMFPB_Downmix_ToMono_Right,      ///< Keep right channel
      eMFPB_Downmix_ToMono_Split,      ///< For Future functionality, keep both channels but as 2 mono channels. Put right channel on new PID.
      eMFPB_Downmix_ToMono_Reserved1,  ///< For Future functionality
      eMFPB_Downmix_ToMono_Reserved2,  ///< For Future functionality
      eMFPB_Downmix_ToMono_Reserved3,  ///< For Future functionality
      eMFPB_Downmix_ToMono_Reserved4   ///< For Future functionality
    };

    /** Extra MPEG1-L2 decoder settings per audio ES.
     *
     * @version Release 10.0
     */
    struct MFPB_AudioDecodeExtraMPEGL2Settings_t
    {
      MFPB_TrackingID_t            TrackingId;       ///< Identifies the elementary streams encoder where the setting should be added to (@see MFPB_AudioDecode_t)

      // Downmix: Dual-mono to mono settings 
      // Used when: dec is "stereo", content of audio ES is dual mono, enc is mono
      enMFPB_Downmix_ToMono        enDualMonoToMono; ///< Select how to convert dual mono channels to mono. [Left by default]
      unsigned short               Pid;              ///< For Future functionality. The new PID value for the extra right channel. Only used when enDualMonoToMono is split.
    };
    typedef sequence<MFPB_AudioDecodeExtraMPEGL2Settings_t> MFPB_AudioDecodeExtraMPEGL2SettingsList_t; 

    /** Configuration for extra MPEG1-L2 decoder settings per service.
     *
     * @version Release 10.0
     */
    struct MFPB_AudioDecodeExtraMPEGL2Cfg_t
    {
      IPS_RefSvc_t                        Service;
      MFPB_AudioDecodeExtraMPEGL2SettingsList_t AudioDecodeExtraMPEGL2SettingsList; ///< Extra decoder settings per ES
    };
    typedef sequence<MFPB_AudioDecodeExtraMPEGL2Cfg_t> MFPB_AudioDecodeExtraMPEGL2CfgList_t;

    /** Update extra MPEG1-L2 audio decoding options.
     *  The function can only be used on existing a audio decoders (update).
     *
     * @param[in] BoardNr                 The Multi format processor (MFP) board for which to configure
     *                                    decoding
     * @param[in] AudioDecodeExtraMPEGL2CfgList Extra audio decoder configurations for services
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed in case:
     * - audio processing is disabled on this board
     * - invalid input references are used (RefSvc)
     * - the refered audio decoder does not exist
     * - invalid settings are passed
     * 
     * @version Release 10.10
     */
    void MFPB_AudioDecodeExtraMPEGL2SetL(in unsigned short BoardNr,
                               in MFPB_AudioDecodeExtraMPEGL2CfgList_t AudioDecodeExtraMPEGL2CfgList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Get extra MPEG1-L2 audio decoding options.
     *  As soon as a audio decoder exists this fuction returns extra audio decoding options.
     *
     * @param[in]  BoardNr                 The Multi format processor (MFP) board to retrieve the settings
     *                                     from
     * @param[in]  ServiceList             The list of services of interest, an empty list returns all services
     * @param[out] AudioDecodeExtraMPEGL2CfgList Extra audio decoder configurations for services
     *
     * @exception OperationFailed in case:
     * - invalid input references are used (RefSvc)
     *
     * @version Release 10.10
     */
    void MFPB_AudioDecodeExtraMPEGL2GetL(in unsigned short BoardNr,
                               in IPS_Service_List_t ServiceList,
                               out MFPB_AudioDecodeExtraMPEGL2CfgList_t AudioDecodeExtraMPEGL2CfgList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Extra AAC decoder settings per audio ES.
     *
     * @version Release 10.10
     */     
    struct MFPB_AudioDecodeExtraAACSettings_t
    {
      MFPB_TrackingID_t       TrackingId;      ///< Identifies the elementary streams encoder where the setting should be added to (@see MFPB_AudioDecode_t)

      // Downmix: 5.1 to stereo
      // Used when: dec is 5.1, enc is stereo
      enMFPB_Downmix_ToStereo en5_1ToStereo;         ///< Select channels to keep when converting to stereo. Allowed values are LTRT and [LORO default].
      boolean                 bIsCenterCoefficient;  ///< Center Coefficient Present Yes(true)/[No default]
      long                    lCenterCoefficient;    ///< Center Coefficient TODO: range and default
      boolean                 bIsSurroundCoefficient;///< Surround Coefficient Present Yes(true)/[No default]
      long                    lSurroundCoefficient;  ///< Surround Coefficient TODO range and default
    };
    typedef sequence<MFPB_AudioDecodeExtraAACSettings_t> MFPB_AudioDecodeExtraAACSettingsList_t; 

    /** Configuration for extra AAC decoder settings per service.
     *
     * @version Release 10.10
     */       
    struct MFPB_AudioDecodeExtraAACCfg_t
    {
      IPS_RefSvc_t                   Service;
      MFPB_AudioDecodeExtraAACSettingsList_t AudioDecodeExtraAACSettingsList; ///< Extra AAC decoder settings per ES
    };
    typedef sequence<MFPB_AudioDecodeExtraAACCfg_t> AudioDecodeExtraAACCfgList_t;

    /** Update extra AAC audio decoding settings.
     *  The function can only be used on existing a audio decoders (update).
     *
     * @param[in] BoardNr            The Multi format processor (MFP) board for which to configure
     *                               decoding
     * @param[in] AudioDecodeExtraAACCfgList Extra AAC audio decoder configurations for services
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed in case:
     * - audio processing is disabled on this board
     * - invalid input references are used (RefSvc)
     * - the refered audio decoder does not exist
     * - invalid settings are passed
     * 
     * @version Release 10.10
     */
    void MFPB_AudioDecodeExtraAACSetL(in unsigned short BoardNr,
                               in AudioDecodeExtraAACCfgList_t AudioDecodeExtraAACCfgList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Get extra AAC audio decoding settings.
     *  As soon as a audio decoder exists this fuction returns extra AAC audio decoding options. 
     *
     * @param[in]  BoardNr            The Multi format processor (MFP) board to retrieve the settings
     *                                from
     * @param[in]  ServiceList        The list of services of interest, an empty list returns all services
     * @param[out] AudioDecodeExtraAACCfgList Extra AAC audio decoder configurations for services
     *
     * @exception OperationFailed in case:
     * - invalid input references are used (RefSvc)
     *
     * @version Release 10.10
     */
    void MFPB_AudioDecodeExtraAACGetL(in unsigned short BoardNr,
                               in IPS_Service_List_t ServiceList,
                               out AudioDecodeExtraAACCfgList_t AudioDecodeExtraAACCfgList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Dolby Dynamic Compression Mode
     *
     * @version Release 10.10
     */       
    enum enMFPB_DolbyDec_DynComp
    {
      eMFPB_DolbyDec_DynComp_Line,
      eMFPB_DolbyDec_DynComp_RF,
      eMFPB_DolbyDec_DynComp_Custom,
      eMFPB_DolbyDec_DynComp_None,
      eMFPB_DolbyDec_DynComp_Reserved1,  ///< For Future functionality
      eMFPB_DolbyDec_DynComp_Reserved2,  ///< For Future functionality
      eMFPB_DolbyDec_DynComp_Reserved3,  ///< For Future functionality
      eMFPB_DolbyDec_DynComp_Reserved4   ///< For Future functionality
    }; 

    /** Extra Dolby decoder settings per audio ES.
     *
     * @version Release 10.10
     */     
    struct MFPB_AudioDecodeExtraDolbySettings_t
    {
      MFPB_TrackingID_t            TrackingId;                  ///< Identifies the elementary streams encoder where the setting should be added to (@see MFPB_AudioDecode_t)

      // Downmix: Dual-mono to mono settings 
      // Used when: dec is "stereo", content of audio ES is dual mono, enc is mono
      enMFPB_Downmix_ToMono        enDualMonoToMono;            ///< Select how to convert dual mono channels to mono. [Left by default]
      unsigned short               Pid;                         ///< For Future functionality. The new PID value for the extra right channel. Only used when enDualMonoToMono is split.

      // Downmix: 5.1 to stereo
      // Used when: dec is 5.1, enc is stereo
      enMFPB_Downmix_ToStereo      en5_1ToStereo;               ///< Select channels to keep when converting to stereo. Allowed values are LTRT, [LORO default] and auto.

      //Dynamic Compression Mode
      enMFPB_DolbyDec_DynComp      enDynCompMode;               ///< Dynamic Compression Mode [Line by default]
      unsigned short               uCompressionCut10;           ///< Compression Cut times 10 (eg. value 9 will be 0.9 in the GUI). Range [0,10 default]. Only used in custom Dynamic Compression Mode, else ignored and set to 10 or 0 in case of DynComp_None.
      unsigned short               uCompressionBoost10;         ///< Compression Boost times 10 (eg. value 9 will be 0.9 in the GUI). Range [0,10 default]. Only used in custom Dynamic Compression Mode, else ignored and set to 10 or 0 in case of DynComp_None.
      unsigned short               uCompressionScalingFactor10; ///< For Future functionality. Compression Scaling factor times 10 (eg. value 9 will be 0.9 in the GUI). Range [0,10 default]. Only used in line and custom Dynamic Compression Mode  
      boolean                      bErrorConcealment;           ///< Error Concealment: [On default]/Off(false)
    };
    typedef sequence<MFPB_AudioDecodeExtraDolbySettings_t> MFPB_AudioDecodeExtraDolbySettingsList_t; 

    /** Configuration for extra Dolby decoder settings per service.
     *
     * @version Release 10.10
     */
    struct MFPB_AudioDecodeExtraDolbyCfg_t
    {
      IPS_RefSvc_t                   Service;
      MFPB_AudioDecodeExtraDolbySettingsList_t AudioDecodeExtraDolbySettingsList; ///< Extra Dolby decoder settings per ES
    };
    typedef sequence<MFPB_AudioDecodeExtraDolbyCfg_t> MFPB_AudioDecodeExtraDolbyCfgList_t;

    /** Update extra Dolby audio decoding settings.
     *  The function can only be used on existing a audio decoders (update).
     *
     * @param[in] BoardNr            The Multi format processor (MFP) board for which to configure
     *                               decoding
     * @param[in] AudioDecodeExtraDolbyCfgList Extra Dolby audio decoder configurations for services
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed in case:
     * - audio processing is disabled on this board
     * - invalid input references are used (RefSvc)
     * - the refered audio decoder does not exist
     * - invalid settings are passed
     *
     * @version Release 10.10
     */
    void MFPB_AudioDecodeExtraDolbySetL(in unsigned short BoardNr,
                               in MFPB_AudioDecodeExtraDolbyCfgList_t AudioDecodeExtraDolbyCfgList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Get extra Dolby audio decoding settings.
     *  As soon as a audio decoder exists this fuction returns extra Dolby audio decoding options.
     *
     * @param[in]  BoardNr            The Multi format processor (MFP) board to retrieve the settings
     *                                from
     * @param[in]  ServiceList        The list of services of interest, an empty list returns all services
     * @param[out] AudioDecodeExtraDolbyCfgList Extra Dolby audio decoder configurations for services
     *
     * @exception OperationFailed in case:
     * - invalid input references are used (RefSvc)
     *
     * @version Release 10.10
     */
    void MFPB_AudioDecodeExtraDolbyGetL(in unsigned short BoardNr,
                               in IPS_Service_List_t ServiceList,
                               out MFPB_AudioDecodeExtraDolbyCfgList_t AudioDecodeExtraDolbyCfgList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);   

    // MFP - Closed caption
    ///////////////////////////////////////////////////////////////////////////////////////

    /** Configuration settings for the Caption Service Descriptor of an ES.
     */
    struct MFPB_ES_CaptionInfo_t
    {
      MFPB_TrackingID_t            TrackingId;      ///< Identifies the elementary stream where the Caption Service Descriptor should be added to
      unsigned short               EncoderId;       ///< Set to 0 (main service only)
      enTC_CaptionDescriptorMode_t CaptionMode;
      TC_CaptionInfoList_t         CaptionInfoList; ///< factory default: empty list. In "Add" mode, a non-empty list must be present.
    };
    typedef sequence<MFPB_ES_CaptionInfo_t> MFPB_ES_CaptionInfoList_t;

    /** Configuration settings for the Caption Service Descriptor(s) of a service.
     */
    struct MFPB_Svc_CaptionInfo_t
    {
      IPS_RefSvc_t              Service;
      MFPB_ES_CaptionInfoList_t ES_CaptionInfoList;
    };
    typedef sequence<MFPB_Svc_CaptionInfo_t> MFPB_Svc_CaptionInfoList_t;

    /** Set the MFP closed caption descriptor setttings.
     *
     * @param[in]  BoardNr             The MFP board on which to apply the settings.
     * @param[in]  Svc_CaptionInfoList A list of caption service settings,
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder board.
     * @exception OperationFailed In case:
     * - invalid input references are used.
     * - invalid settings were passed.
     *
     * @version Release 10.0
     **/
    void MFPB_CaptionServiceCfgSetL(in unsigned short BoardNr, in MFPB_Svc_CaptionInfoList_t Svc_CaptionInfoList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Get the MFP closed caption descriptor setttings.
     *
     * @param[in]  BoardNr             The MFP board to retrieve the settings from.
     * @param[in]  ServiceList         The list of services of interest.
     * @param[out] Svc_CaptionInfoList A list of caption service settings.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a MFP board.
     * @exception OperationFailed In case:
     * - invalid input references are used.
     *
     * @version Release 10.0
     **/
    void MFPB_CaptionServiceCfgGetL(in unsigned short BoardNr, in IPS_Service_List_t ServiceList, 
         out MFPB_Svc_CaptionInfoList_t Svc_CaptionInfoList)
            raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);


    // MFP - Audio Meta Data
    ///////////////////////////////////////////////////////////////////////////////////////   

    /**
    * @brief Dolby meta data status for a specific component.
    * @version Release 10.20
    **/
    struct MFPB_DD_MetaStatus_t
    {
      //Equivalent as AudioStatus
      enMFPB_AudioFormat_t                      enAudioFormat;           ///< Dolby Digital or Dolby Digital Plus
      enMFPB_AudioStatusChannelConfiguration_t  enInputChannelConfig;    ///< Channel configuration
      enMFPB_AudioStatusSampleRate_t            enSampleRate;
      boolean                                   bLfeEnable;              ///< LFE on(true)/off, only for AAC and Dolby.
      long                                      lAudioLevel;             ///< Reserved for future

      //Dolby specific
      unsigned short                            uBitStreamID;            ///< Bit Stream ID
      enMFPB_Dolby_BitStreamMode                enBitStreamMode;         ///< Bit Stream Mode
      unsigned long                             uDataRate;               ///< Data Rate (bps)
      boolean                                   bMainProductInfoExists;  ///< Audio Production Info Exists
      long                                      lMainDialnorm;           ///< Dialnorm (dB) times 10
      long                                      lMainMixLevel;           ///< Mix Level (dB) times 10
      enMFPB_Dolby_RoomType                     enMainRoomType;          ///< Room Type
      boolean                                   bAuxProductInfoExists;   ///< Audio Production Info Exists
      long                                      lAuxDialnorm;            ///< Dialnorm (dB) times 10
      long                                      lAuxMixLevel;            ///< Mix Level (dB) times 10
      enMFPB_Dolby_RoomType                     enAuxRoomType;           ///< Room Type
      enMFPB_Dolby_SurroundMode                 enSurroundMode;          ///< Dolby Surround Mode
      enMFPB_Dolby_SurroundExMode               enSurroundExMode;        ///< Dolby Surround Ex mode
      long                                      lCentreMixLevel;         ///< Center Mix Level dB times 10 (eg. value -45 will be -4.5 in the GUI). Discrete values [-3, -4.5, -6].
      long                                      lSurroundMixLevel;       ///< Surround Mix Level dB  times 10 (eg. value -60 will be -6 in the GUI). Discrete values [-3, -6, -99.9 (Infinite)].
      enMFPB_ExtendedBSI_Mode                   enExtBSI_Mode;           ///< Extended BSI Mode.
      enMFPB_Downmix_ToStereo                   enDownmix_ToStereo;      ///< Preferred Stereo Downmix Mode
      long                                      lLtRtCentreMixLevel;     ///< Lt/Rt Center Mix Level (dB) times 10 (eg. value -45 will be -4.5 in the GUI). Discrete values [3, 1.5, 0, -1.5, -3, -4.5, -6, -99.9 (Infinite)]
      long                                      lLtRtSurroundMixLevel;   ///< Lt/Rt Surround Mix Level (dB) times 10 (eg. value -45 will be -4.5 in the GUI). Discrete values [ -1.5, -3, -4.5, -6, -99.9 (Infinite)]
      long                                      lLoRoCentreMixLevel;     ///< Lo/Ro Center Mix Level (dB) times 10 (eg. value -45 will be -4.5 in the GUI). Discrete values [3, 1.5, 0, -1.5, -3, -4.5, -6, -99.9 (Infinite)]
      long                                      lLoRoSurroundMixLevel;   ///< Lo/Ro Surround Mix Level (dB) times 10 (eg. value -45 will be -4.5 in the GUI). Discrete values [-1.5, -3, -4.5, -6, -99.9 (Infinite)]
      boolean                                   bCopyright;              ///< Copyright, yes (true)/no
      boolean                                   bOriginal;               ///< Original, yes (true)/no
    };    

    /**
    * @brief Dolby meta data status on the decoder side for a specific component.
    * @version Release 10.20
    **/
    struct MFPB_DD_MetaDecStatus_t
    {
      MFPB_TrackingID_t     TrackingId;
      MFPB_DD_MetaStatus_t  DD_MetaStatus;///< Status of the meta data
    }; 
    typedef sequence<MFPB_DD_MetaDecStatus_t> MFPB_DD_MetaDecStatusList_t;

    /**
    * @brief Dolby meta data status on the decoder side for a specific service.
    * @version Release 10.20
    **/     
    struct MFPB_ServiceDD_MetaDecStatus_t
    {
      IPS_RefSvc_t                 Service;
      MFPB_DD_MetaDecStatusList_t  DD_MetaDecStatusL;
    };
    typedef sequence<MFPB_ServiceDD_MetaDecStatus_t> MFPB_ServiceDD_MetaDecStatusList_t;    

    /** Get Dolby meta data status on the decoder.
     * Information is only available for audio streams which are currently being processed.
     *
     * @param[in]  BoardNr       The Multi format processor (MFP) board for which to get information.
     * @param[in]  ServiceList   The list of services of interest.
     * @param[out] StatusList    The status of the Dolby meta data status on the decoder side.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a Multi format processor (MFP) board.
     * @exception OperationFailed In case:
     * - invalid input references are used (BoardNr, RefSvc).
     *
     * @version Release 10.20
     **/
    void MFPB_DD_MetaDecStatusGetL(in unsigned short BoardNr, in IPS_Service_List_t ServiceList, out MFPB_ServiceDD_MetaDecStatusList_t StatusList)
         raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);   

    /** @brief Setting of how meta data should be passed between decoder and encoder.
     *
     * @version Release 10.20
     */      
    enum enMFPB_MetaDataPass_t
    {
      enMFPB_MetaDataCfg_Auto,       ///< Pass Meta data from decoder to encoder automatically. The result depend on varous factors but the state can be checked with eg. @see MFPB_DD_MetaDecStatusGetL
      enMFPB_MetaDataCfg_Manual,     ///< No Meta data is passed from decoder to encoder. The encoder meta data is generated based on the manual settings. (eg. @see MFPB_DolbyAudioCfgSetL )
      enMFPB_MetaDataCfg_Reserved1, ///< For Future functionality.
      enMFPB_MetaDataCfg_Reserved2, ///< For Future functionality. 
      enMFPB_MetaDataCfg_Reserved3, ///< For Future functionality. 
      enMFPB_MetaDataCfg_Reserved4, ///< For Future functionality. 
      enMFPB_MetaDataCfg_Reserved5, ///< For Future functionality. 
      enMFPB_MetaDataCfg_Reserved6  ///< For Future functionality. 
    };

    /** @brief audio meta data settings for a specific component.  
     *
     * @version Release 10.20
     */
    struct MFPB_MetaDataCfg_t
    {
      MFPB_TrackingID_t         TrackingId;

      enMFPB_MetaDataPass_t     enMetaDataPass; ///< Setting to determine how audio meta data is passed between decoder and encoder. Auto by default (Default manual for services set before 10.20)
    };
    typedef sequence<MFPB_MetaDataCfg_t> MFPB_MetaDataCfgList_t;

    /** @brief audio meta data settings for a specific service.
     *
     * @version Release 10.20
     */
    struct MFPB_ServiceMetaDataCfg_t   
    {
      IPS_RefSvc_t           Service;
      MFPB_MetaDataCfgList_t MetaDataCfgL;
    };
    typedef sequence<MFPB_ServiceMetaDataCfg_t> MFPB_ServiceMetaDataCfgList_t;        

    /** Set the audio meta data configuration.
     *
     * @param[in] BoardNr            The Multi format processor (MFP) board for which to configure
     *                               encoding
     * @param[in] MetaDataCfgList    The settings list
     *
     * @note The TrackingID must always correspond to a encoder tracking ID
     *       configured with AudioDecodeCfgSetL(..).  *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           Multi format processor (MFP) board.
     * @exception OperationFailed in case:
     * - audio processing is disabled on this board
     * - invalid input references are used (RefSvc)
     * - no Audio decoder was configured
     * - invalid settings are passed
     *
     * @version Release 10.20
     */
    void MFPB_MetaDataCfgSetL(in unsigned short BoardNr, in MFPB_ServiceMetaDataCfgList_t MetaDataCfgList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported, LicenseError);

    /** Get the audio meta data configuration.
     *
     * @param[in]  BoardNr            The Multi format processor (MFP) board to retrieve the settings
     *                                from
     * @param[in]  ServiceList        The list of services of interest.
     * @param[out] MetaDataCfgList    The with the current settings
     *
     * @exception OperationFailed in case:
     * - invalid input references are used (RefSvc)
     *
     * @version Release 10.20
     */
    void MFPB_MetaDataCfgGetL(in unsigned short BoardNr, in IPS_Service_List_t ServiceList, out MFPB_ServiceMetaDataCfgList_t MetaDataCfgList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);  

#endif // DISABLE_MFP
    /// @} end of MFP


#ifndef DISABLE_TRANSCODER
    // Transcoder
    /////////////////////////////////////////////////////////////////////////////////////// 
    
    /** @defgroup transcoder Transcoder
     * This contains specific types, enums and methods for controling the transcoder part of the device.
     * @{
     */

    struct TC_BoardCfg_t
    {
      unsigned long HD_Slots;
      unsigned long SD_Slots;
      unsigned long Audio_Slots;
    };

    struct TC_PossibleBoardCfg_t
    {
      boolean        isPossible;  ///< Is it possible to apply this board configuration
      TC_BoardCfg_t  BoardCfg;
    };
    typedef sequence<TC_PossibleBoardCfg_t> TC_PossibleBoardCfgList_t;

    /** Structure to set/get transcoder board configuration.
     *
     * @version Release 8.1
     */
    struct TC_BoardCfg_V2_t
    {
      unsigned long HD_Slots;
      unsigned long SD_Slots;
      unsigned long Audio_Slots;
      unsigned long Pip_Slots;
    };
    /** Structure to get possible board configurations for a transcoder board.
     *
     * @version Release 8.1
     */
    struct TC_PossibleBoardCfg_V2_t
    {
      boolean          isPossible;  ///< Is it possible to apply this board configuration
      TC_BoardCfg_V2_t BoardCfg;
    };
    typedef sequence<TC_PossibleBoardCfg_V2_t> TC_PossibleBoardCfgList_V2_t;

    struct EsEntry_t
    {
      IPS_RefSvc_t          RefSvcOut;
      IPS_RefPid_t          SrcPidRef;
      octet                 EsType;  // 0 = HD, 1 = SD, 2 = Audio, 3 = PIP
    };
    typedef sequence<EsEntry_t> EsList_t;

    typedef unsigned long  SelectionId_t;
    typedef sequence<SelectionId_t> SelectionIdList_t;

    struct SelectionListEntry_t
    {
      SelectionId_t         SelectionId;  // used to link to second choice user has to make (will be equal to InternalID in V1)
      // is DspPairID in first selection list, DspID in 2nd selection list
      EsList_t              EsList;
    };
    typedef sequence<SelectionListEntry_t> SelectionList_t;

    struct TC_Question_t
    {
      octet                 ChoicesToMake;   // Number of selections user has to make
      SelectionList_t       SelectionList; 
    };
    typedef sequence<TC_Question_t> TC_QuestionList_t;

    struct TC_DependantQuestion_t
    {
      SelectionIdList_t   Answers;
      TC_QuestionList_t   Questions;
    };
    typedef sequence<TC_DependantQuestion_t> TC_DependantQuestionList_t;

    enum enTC_Profile_t
    {
      eTC_Profile_Main,
      eTC_Profile_High
    };

    enum enTC_VBR_Quality_t
    {
      eTC_VBR_Best,
      eTC_VBR_Low_Valleys,
      eTC_VBR_Moderate_Valleys,
      eTC_VBR_Aggressive_Valleys,
      eTC_VBR_Very_Aggressive_Valleys
    };

    enum enTC_EncodingMode_t
    {
      eTC_EncodingMode_VBR,
      eTC_EncodingMode_CBR
    };

    enum enTC_ClosedCaptionMode_t
    {
      eTC_ClosedCaptionMode_Disabled,             ///< No closed captions in output
      eTC_ClosedCaptionMode_Transcode,            ///< Transcode to CEA 708
      eTC_ClosedCaptionMode_TestPattern_1,        ///< Test pattern for field 1
      eTC_ClosedCaptionMode_TestPattern_2,        ///< Test pattern for field 2
      eTC_ClosedCaptionMode_TestPattern_1_2       ///< Not supported
    };
    
    enum enTC_ClosedCaptionFormat_t
    {
      eTC_ClosedCaptionFormat_None,       ///< Input contains no closed captions
      eTC_ClosedCaptionFormat_SA_Type_4,  
      eTC_ClosedCaptionFormat_SCTE20,
      eTC_ClosedCaptionFormat_EAI708
    };
    
    enum enTC_PipResolution_t
    {
      eTC_PipResolution_96_96,       ///< 96 * 96
      eTC_PipResolution_SQCIF,       ///< 128 * 96
      eTC_PipResolution_QCIF,        ///< 176 * 144
      eTC_PipResolution_192_192,     ///< 192 * 192
      eTC_PipResolution_Reserved_1,  ///< future use, undefined
      eTC_PipResolution_Reserved_2,  ///< future use, undefined
      eTC_PipResolution_Reserved_3,  ///< future use, undefined
      eTC_PipResolution_Reserved_4   ///< future use, undefined
    };

    enum enTC_TemporalNoiseShaping_t
    {
      eTC_TNS_Disabled,
      eTC_TNS_Enabled
    };

    enum enTC_SpectralBandReplication_t
    {
      eTC_SBR_Disabled,   ///< HE-AAC
      eTC_SBR_Enabled     ///< AAC-LC
    };

    enum enTC_PerceptualNoiseSubstitution_t
    {
      eTC_PNS_Disabled,
      eTC_PNS_Enabled
    };
    
    enum enTC_TransportPacketizationMode_t
    {
      eTC_TPM_ADTS,
      eTC_TPM_LOAS,  ///< Supported from V07.05 onwards.
      eTC_TPM_ADIF,  ///< Debug only.
      eTC_TPM_RAW    ///< Debug only.
    };

    enum enTC_AudioSampleRate_t
    {
      eTC_AudioSampleRate_Auto,     ///< Follow input sample rate.
      eTC_AudioSampleRate_16KHz,
      eTC_AudioSampleRate_32KHz,
      eTC_AudioSampleRate_44_1KHz,  ///< 44.1 KHz
      eTC_AudioSampleRate_48KHz
    };
    
    enum enTC_AudioMode_t
    {
      eTC_AudioMode_Mono,                                           ///< 1/0
      eTC_AudioMode_Stereo,                                         ///< 2/0
      eTC_AudioMode_DualMono,                                       ///< 1+1
      eTC_AudioMode_Left_Right_Center,                              ///< 3/0
      eTC_AudioMode_Left_Right_Surround,                            ///< 2/1
      eTC_AudioMode_Left_Right_Center_Surround,                     ///< 3/1
      eTC_AudioMode_Left_Right_SurroundLeft_SurroundRight,          ///< 2/2
      eTC_AudioMode_Left_Right_Center_SurroundLeft_SurroundRight    ///< 3/2
    };

    typedef unsigned long TrackingID_t;
    typedef sequence<TrackingID_t> TrackingID_List_t;

    struct TC_ServiceTrackingID_t
    {
      IPS_RefSvc_t  Service;
      TrackingID_t  TrackingID;
    };
    typedef sequence<TC_ServiceTrackingID_t> TC_ServiceTrackingID_List_t;

    /** Video encode settings.
     *
     * @version Release 8.2
     */
    struct TC_VideoEncodeSettings_t
    {
      enTC_Profile_t           enProfile;   ///< Applies if the input is SD. The HD output is always high profile

      unsigned long            SD_Bitrate;  ///< 1.0 - 3.5Mbps, in bps. (Used whenever the input is SD, even if HD_Service is true).

      unsigned long            HD_Bitrate;  ///< 5.0 - 12.0Mbps, in bps.
      boolean                  LoopFilter;
      unsigned long            CPB_Delay;   ///< Maximum CPB removal delay, in ms. 500 - 1500 ms, and between (service delay - 1306) and (service delay - 452).
      enTC_VBR_Quality_t       enVBR_Quality;
      enTC_EncodingMode_t      enEncodingMode;
      enTC_ClosedCaptionMode_t enClosedCaptionMode;
    };

    /** Video decode settings together with fields identifying the video component they're for.
     *
     * @version Release 8.2
     */
    struct TC_VideoDecode_t
    {
      TrackingID_t             TrackingId;         ///< 0 when creating a new entry
      TrackingCriterium_t      TrackingCriterium;
      boolean                  HD_Service; /**< If set both SD and HD services can be transcoded.
                                            *   SD services will use the SD_Bitrate defined by the
                                            *   encoding settings, HD services will use the
                                            *   HD_Bitrate defined by the encoding settings.
                                            */
    };
    typedef sequence<TC_VideoDecode_t> TC_VideoDecodeList_t;

    /** Video encode settings together with field identifying the video component they're for.
     *
     * @version Release 8.2
     */
    struct TC_VideoEncode_t
    {
      TrackingID_t             TrackingId; ///< Must be equal to the tracking ID of a video decode
      TC_VideoEncodeSettings_t Settings;
    };
    typedef sequence<TC_VideoEncode_t> TC_VideoEncodeList_t;

    /** Video transcode settings.
     *
     * This is a combination of video decode and encode settings.
     *
     * @deprecated The types TC_VideoEncodeSettings_t, TC_VideoDecode_t and TC_VideoEncode_t
     *             should be used instead of this type and TC_Video_t.
     *
     * @version Release 7.5
     */
    struct TC_VideoSettings_t
    {
      enTC_Profile_t           enProfile;   ///< Applies if the input is SD. The HD output is always high profile
      unsigned long            SD_Bitrate;  ///< 1.0 - 3.5Mbps, in bps. (Used whenever the input is SD, even if HD_Service is true).
      unsigned long            HD_Bitrate;  ///< 5.0 - 12.0Mbps, in bps.
      boolean                  HD_Service;  ///< If set both SD and HD services can be transcoded. SD services will use SD_Bitrate, HD services will use HD_Bitrate.
      boolean                  LoopFilter;
      unsigned long            CPB_Delay;   ///< Maximum CPB removal delay, in ms. 500 - 1500 ms, and between (service delay - 1306) and (service delay - 452).
      enTC_VBR_Quality_t       enVBR_Quality;
      enTC_EncodingMode_t      enEncodingMode;
      enTC_ClosedCaptionMode_t enClosedCaptionMode;
    };

    struct TC_VideoResolution_t
    {
       unsigned short Height;
       unsigned short Width;
    };

    struct TC_VideoStatus_t
    {
      enTC_ClosedCaptionFormat_t enClosedCaptionFormat;
      TC_VideoResolution_t       Resolution;
    };

    /** Video transcode settings together with fields identifying the video component they're for.
     *
     * @deprecated The types TC_VideoDecode_t and TC_VideoEncode_t should be used instead of
     *             this type.
     *
     * @version Release 7.5
     */
    struct TC_Video_t
    {
      TrackingID_t        TrackingId;         ///< 0 when creating a new entry
      TrackingCriterium_t TrackingCriterium;
      TC_VideoSettings_t  Settings;
    };
    typedef sequence<TC_Video_t> TC_VideoList_t;

    struct TC_VideoInformation_t
    {
      TrackingID_t        TrackingId;
      TC_VideoStatus_t    Status;
    };
    typedef sequence<TC_VideoInformation_t> TC_VideoInformationList_t;
   
    struct TC_PipSettings_t
    {
      enTC_PipResolution_t       enResolution;        ///< Output resolution
      unsigned long              Bitrate;             ///< 150 - 400kbps, in bps.
      unsigned long              GOP_Length;          ///< Lenght of the GOP. 1 - 30 frames.
      unsigned long              CPB_Delay;           ///< Maximum CPB removal delay, in ms. 500 - 1500 ms, and between (service delay - 1306) and (service delay - 452).
      enTC_ClosedCaptionMode_t   enClosedCaptionMode; ///< Closed caption transcoding mode
      unsigned long              PCR_Interval;        ///< 10 - 300 ms, in ms.
      boolean                    PCR_InPip;           ///< Should the PCR be part of a PIP packet or should it use an empty packet (on the same PID).
    };

    struct TC_Pip_t
    {
      TrackingID_t        TrackingId; /**< Must be equal to the tracking ID of a video decode (preferred)
                                       *   or the tracking ID of a video transcode (deprecated).
                                       *   See TC_PipCfgSetL(..) for more info.
                                       */
      TC_PipSettings_t    Settings;
    };
    typedef sequence<TC_Pip_t> TC_PipList_t;

    struct TC_AudioSettings_t
    {
      unsigned long                      Bitrate;        ///< 8 - 128 kbps for HE-AAC, 8 - 576 kbps 
                                                         ///< for AAC-LC or 8 - 192 kpbs for VBR. In bps.
      boolean                            bAllowAC3;      ///< Transcode AC-3 input. Requires an AC3 extension license.
      enTC_EncodingMode_t                enAudioEncodingMode;  ///< Remark: This setting is ignored, the audio output is always CBR.
      enTC_TemporalNoiseShaping_t        enTemporalNoiseShaping;
      enTC_SpectralBandReplication_t     enSpectralBandReplication;     ///< Cannot be activated if Perceptual Noise Substitution is enabled.
      enTC_PerceptualNoiseSubstitution_t enPerceptualNoiseSubstitution; ///< Cannot be activated if Spectral Band Replication is enabled.
      enTC_TransportPacketizationMode_t  enTransportPacketizationMode;
      short                              LevelControl;   ///< -20 to 20 dB, in 1/1000 dB.
    };

    struct TC_AudioStatus_t
    {
      enTC_AudioSampleRate_t  enSampleRate;
      enTC_AudioMode_t        enMode;
      unsigned long           AdjustedBitrate; ///< The real output bitrate, after input mode and sample rate have been taken into account
    };

    struct TC_Audio_t
    {
      TrackingID_t        TrackingId;  ///< 0 when creating a new entry
      TrackingCriterium_t TrackingCriterium;
      TC_AudioSettings_t  Settings;
    };
    typedef sequence<TC_Audio_t> TC_AudioList_t;
    
    struct TC_AudioInformation_t
    {
      TrackingID_t        TrackingId;
      TC_AudioStatus_t    Status;
    };
    typedef sequence<TC_AudioInformation_t> TC_AudioInformationList_t;

    enum enTC_MaximumBitrateDescriptorMode_t
    { 
      eTC_MaximumBitrateDescriptorMode_Passthrough, ///< Use the input descriptor (default value)
      eTC_MaximumBitrateDescriptorMode_Generate     ///< An ES level maximum bitrate descriptor will be generated that matches the bitrate after transcoding. Any service level descriptor is passed through.
    };

    struct TC_ServiceCfg_t 
    {
      IPS_RefSvc_t    Service;
      enTC_MaximumBitrateDescriptorMode_t enMaximumBitrateDescriptorMode;
      unsigned long   Delay;          ///< 1000 - 2800 ms (Total delay), in ms. See TC_VideoSettings_t::CPB_Delay for additional restrictions.
      unsigned long   PCR_Interval;   ///< 10 - 300 ms, in ms.
      boolean         PCR_InVideo;    ///< Should the PCR be part of a video packet or should it use an empty packet (on the same PID).
      boolean         AdaptSI_Tables; ///< Default true : will automatically adapt PMT, EIT and SDT tables where necessary
    };
    typedef sequence<TC_ServiceCfg_t> TC_ServiceCfgList_t;

    struct TC_VideoDecodeCfg_t
    {
      IPS_RefSvc_t             Service;
      TC_VideoDecodeList_t     VideoDecodeList;
    };
    typedef sequence<TC_VideoDecodeCfg_t> TC_VideoDecodeCfgList_t;

    struct TC_VideoEncodeCfg_t
    {
      IPS_RefSvc_t             Service;
      TC_VideoEncodeList_t     VideoEncodeList;
    };
    typedef sequence<TC_VideoEncodeCfg_t> TC_VideoEncodeCfgList_t;

    struct TC_VideoCfg_t
    {
      IPS_RefSvc_t    Service;
      TC_VideoList_t  Video;
    };
    typedef sequence<TC_VideoCfg_t> TC_VideoCfgList_t;

    struct TC_VideoServiceInformation_t
    {
      IPS_RefSvc_t              Service;
      TC_VideoInformationList_t Video;
    };
    typedef sequence<TC_VideoServiceInformation_t> TC_VideoServiceInformationList_t;

    struct TC_PipCfg_t
    {
      IPS_RefSvc_t Service;
      TC_PipList_t Pip;
    };
    typedef sequence<TC_PipCfg_t> TC_PipCfgList_t;

    struct TC_AudioCfg_t
    {
      IPS_RefSvc_t    Service;
      TC_AudioList_t  Audio;
    };
    typedef sequence<TC_AudioCfg_t> TC_AudioCfgList_t;
    
    struct TC_AudioServiceInformation_t
    {
      IPS_RefSvc_t              Service;
      TC_AudioInformationList_t Audio;
    };
    typedef sequence<TC_AudioServiceInformation_t> TC_AudioServiceInformationList_t;

    struct TC_Component_t
    {
      unsigned short  Pid;
      TrackingID_t    TrackingId;     ///< 0 if the component matches no tracking criteria.
    };
    typedef sequence<TC_Component_t> TC_ComponentList_t;

    struct TC_ServiceComponents_t
    {
      IPS_RefSvc_t   Service;
      TC_ComponentList_t  VideoPids;    ///< The video pids which can be transcoded
      TC_ComponentList_t  AudioPids;    ///< The audio pids which can be transcoded
    };
    typedef sequence<TC_ServiceComponents_t> TC_ServiceComponentsList_t;

    /** Configuration settings for the Caption Service Descriptor of an ES.
     */
    struct TC_ES_CaptionInfo_t
    {
      TrackingID_t                 TrackingId; ///< Identifies the elementary stream where the Caption Service Descriptor should be added to
      boolean                      PipService; ///< 0 means for main service; 1 means for PIP service
      enTC_CaptionDescriptorMode_t CaptionMode;
      TC_CaptionInfoList_t         CaptionInfoList; ///< factory default: empty list. In "Add" mode, a non-empty list must be present.
    };
    typedef sequence<TC_ES_CaptionInfo_t> TC_ES_CaptionInfoList_t;

    /** Configuration settings for the Caption Service Descriptor(s) of a service.
     */
    struct TC_Svc_CaptionInfo_t
    {
      IPS_RefSvc_t            Service;
      TC_ES_CaptionInfoList_t ES_CaptionInfoList;
    };
    typedef sequence<TC_Svc_CaptionInfo_t> TC_Svc_CaptionInfoList_t;

    /** Get the current configuration of the transcoder.
     *  This configuration determines how many SD, HD or audio streams the 
     *  transcoder board can handle.
     * 
     * @param[in]  BoardNr               The transcoder board to retrieve the settings from.
     * @param[out] BoardCfg              The transcoder board configuration.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder board.
     * @exception OpNotSucceeded in case:
     *    - the number of PIP slots in the current configuration is different from 0:
     *      PIP slots are not supported by this function. Use TC_GetBoardCfg_V2()
     *      instead.
     * 
     * @version Release 7.5
     **/
    void TC_GetBoardCfg(in unsigned short BoardNr, out TC_BoardCfg_t BoardCfg) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the current configuration of the transcoder.
     *  This configuration determines how many SD, HD, audio and PIP streams the
     *  transcoder board can handle.
     * 
     * @param[in]  BoardNr               The transcoder board to retrieve the settings from.
     * @param[out] BoardCfg              The transcoder board configuration.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder board.
     * 
     * @version Release 8.1
     **/
    void TC_GetBoardCfg_V2(in unsigned short BoardNr, out TC_BoardCfg_V2_t BoardCfg) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get a list of all board configurations whether they can be applied or not.
     * A board configuration can be applied if it has at least as many slots 
     * as there are configured transcodes for each type.
     *
     * @param[in]  BoardNr               The transcoder boar to retrieve the settings from.
     * @param[out] BoardCfgList          A list of all board configurations.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder board.
     * 
     * @version Release 7.5
     **/
    void TC_GetPossibleBoardCfgL(in unsigned short BoardNr, out TC_PossibleBoardCfgList_t BoardCfgList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get a list of all board configurations whether they can be applied or not.
     * A board configuration can be applied if it has at least as many slots 
     * as there are configured transcodes for each type.
     *
     * @param[in]  BoardNr               The transcoder boar to retrieve the settings from.
     * @param[out] BoardCfgList          A list of all board configurations.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder board.
     * 
     * @version Release 8.1
     **/
    void TC_GetPossibleBoardCfgL_V2(in unsigned short BoardNr, out TC_PossibleBoardCfgList_V2_t BoardCfgList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Apply a new Board Configuration on a Transcoder board.      
     * This can cause interruptions in some or all transcoded streams.
     *
     * @param[in] SlotNbr                          The slotnumber for the affected board
     * @param[in] BoardCfg                         The new board configuration that the user likes to apply
     * 
     * @exception OpNotSucceeded
     * - Impossible board configuration
     * - Impossible to set mode without deleting audio or video components first
     *
     * @version Release 7.5
     **/
    void TC_SetBoardCfg(in unsigned short SlotNbr, in TC_BoardCfg_t BoardCfg)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Apply a new Board Configuration on a Transcoder board.
     * This can cause interruptions in some or all transcoded streams.
     *
     * @param[in] SlotNbr                          The slotnumber for the affected board
     * @param[in] BoardCfg                         The new board configuration that the user likes to apply
     * 
     * @exception OpNotSucceeded
     * - Impossible board configuration
     * - Impossible to set mode without deleting audio or video components first
     *
     * @version Release 8.1
     **/
    void TC_SetBoardCfg_V2(in unsigned short SlotNbr, in TC_BoardCfg_V2_t BoardCfg)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the list of components which can be transcoded.
     * 
     * @param[in]  BoardNr               The transcoder board to retrieve the settings from.
     * @param[in]  ServiceList           The list of services of interest.
     * @param[out] ServiceComponentsList  The list of components per service
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder board.
     * @exception OpNotSucceeded In case:
     * - invalid input references are used (ServiceList).
     * 
     * @version Release 7.5
     **/
    void TC_ServiceComponentsGetL(in unsigned short BoardNr, in IPS_Service_List_t ServiceList, out TC_ServiceComponentsList_t ServiceComponentsList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the transcoder service settings.
     * 
     * @param[in]  BoardNr          The transcoder board to retrieve the settings from.
     * @param[in]  ServiceList      The list of services of interest.
     * @param[out] ServiceCfgList   A list of transcoder service settings.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder board.
     * @exception OpNotSucceeded In case:
     * - invalid input references are used.
     * 
     * @version Release 7.5
     **/
    void TC_ServiceCfgGetL(in unsigned short BoardNr, in IPS_Service_List_t ServiceList, out TC_ServiceCfgList_t ServiceCfgList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Update the transcoder service settings.
     * 
     * @param[in]  BoardNr         The transcoder board to retrieve the settings from.
     * @param[in]  ServiceCfgList  A list of transcoder service settings.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder board.
     * @exception OpNotSucceeded In case:
     * - invalid input references are used.
     * - invalid settings were passed.
     * 
     * @version Release 7.5
     **/
    void TC_ServiceCfgSetL(in unsigned short BoardNr, in TC_ServiceCfgList_t ServiceCfgList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the video transcoding settings.
     *
     * @param[in]  BoardNr       The transcoder board to retrieve the settings from.
     * @param[in]  ServiceList   The list of services of interest.
     * @param[out] VideoCfgList  A list of video transcoding settings.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder board.
     * @exception OpNotSucceeded In case:
     * - invalid input references are used (Ref, RefPid).
     *
     * @deprecated Use TC_VideoDecodeCfgGetL(..) and TC_VideoEncodeCfgGetL(..) instead.
     *
     * @version Release 7.5
     **/
    void TC_VideoCfgGetL(in unsigned short BoardNr, in IPS_Service_List_t ServiceList, out TC_VideoCfgList_t VideoCfgList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the video transcoding settings.
     *
     * @param[in]  BoardNr       The transcoder board for which to configure transcoding.
     * @param[in]  VideoCfgList  A list of video transcoding settings.
     *
     * @note Only streamtype tracking is supported.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder board.
     * @exception OpNotSucceeded In case:
     * - invalid input references are used (RefSvc).
     * - invalid settings are passed:
     *    - bitrate too high/low
     *    - ...
     * - There are no more transcoding resources available
     *
     * @deprecated Use TC_VideoDecodeCfgSetL(..) and TC_VideoEncodeCfgSetL(..) instead.
     *
     * @version Release 7.5
     **/
    void TC_VideoCfgSetL(in unsigned short BoardNr, in TC_VideoCfgList_t VideoCfgList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);

    /** Remove video transcoding settings.
     *
     * @param[in]  BoardNr       The transcoder board for which to configure transcoding.
     * @param[in]  ToDelete      A list of IDs for video settings to delete
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder board.
     * @exception OpNotSucceeded In case:
     * - invalid input references are used (RefSvc, TrackingID).
     *
     * @deprecated Use TC_VideoDecodeCfgDeleteL(..) and TC_VideoEncodeCfgDeleteL(..) instead.
     *
     * @version Release 7.5
     **/
    void TC_VideoCfgDeleteL(in unsigned short BoardNr, in TC_ServiceTrackingID_List_t ToDelete)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the PIP transcoding settings.
     *
     * @param[in]  BoardNr       The transcoder board to retrieve the settings from.
     * @param[in]  ServiceList   The list of services of interest.
     * @param[out] PipCfgList    A list of PIP transcoding settings.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder board.
     * @exception OpNotSucceeded In case:
     * - invalid input references are used (Ref, RefPid).
     * 
     * @version Release 8.1
     **/
    void TC_PipCfgGetL(in unsigned short BoardNr, in IPS_Service_List_t ServiceList, out TC_PipCfgList_t PipCfgList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the PIP transcoding settings.
     *
     * @param[in]  BoardNr       The transcoder board for which to configure transcoding.
     * @param[in]  PipCfgList    A list of PIP transcoding settings.
     *
     * @note The TrackingID of the PIP must always correspond to one of the following tracking ID's:
     * - a tracking ID of a video decode configured with TC_VideoDecodeCfgSetL(..). Then it is
     *   possible to configure PIP without a video encode. This option is supported since
     *   release 8.2 and is the preferred way.
     * - a tracking ID of a video transcode configured with TC_VideoCfgSetL(..). Then it is not
     *   possible to configure PIP without a video transcode. This option should be avoided.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder board.
     * @exception OpNotSucceeded In case:
     * - invalid input references are used (RefSvc).
     * - invalid settings are passed:
     *    - bitrate too high/low
     *    - ...
     * - There are no more transcoding resources available
     * 
     * @version Release 8.1
     **/
    void TC_PipCfgSetL(in unsigned short BoardNr, in TC_PipCfgList_t PipCfgList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);

    /** Remove PIP transcoding settings.
     *
     * @param[in]  BoardNr       The transcoder board for which to configure transcoding.
     * @param[in]  ToDelete      A list of IDs for PIP settings to delete
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder board.
     * @exception OpNotSucceeded In case:
     * - invalid input references are used (RefSvc, TrackingID).
     * 
     * @version Release 8.1
     **/
    void TC_PipCfgDeleteL(in unsigned short BoardNr, in TC_ServiceTrackingID_List_t ToDelete)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get video status information.
     * Information is only available for video streams which are currently being transcoded.
     *
     * @param[in]  BoardNr       The transcoder board for which to configure transcoding.
     * @param[in]  ServiceList   The list of services of interest.
     * @param[out] VideoInfoList The status of the video streams.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder board.
     * @exception OpNotSucceeded In case:
     * - invalid input references are used (RefSvc, TrackingID).
     * 
     * @version Release 7.5
     **/
    void TC_VideoInformationGetL(in unsigned short BoardNr, in IPS_Service_List_t ServiceList, out TC_VideoServiceInformationList_t VideoInfoList)
         raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the audio transcoding settings.
     *
     * @param[in]  BoardNr       The transcoder board to retrieve the settings from.
     * @param[in]  ServiceList   The list of services of interest.
     * @param[out] AudioCfgList  A list of audio transcoding settings.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder board.
     * @exception OpNotSucceeded In case:
     * - invalid input references are used (Ref, RefPid).
     * 
     * @version Release 7.5
     **/
    void TC_AudioCfgGetL(in unsigned short BoardNr, in IPS_Service_List_t ServiceList, out TC_AudioCfgList_t AudioCfgList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the audio transcoding settings.
     *
     * @param[in]  BoardNr       The transcoder board for which to configure transcoding.
     * @param[in]  AudioCfgList  A list of audio transcoding settings.
     *
     * @note Only streamtype tracking is supported.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder board.
     * @exception OpNotSucceeded In case:
     * - invalid input references are used (RefSvc).
     * - invalid settings are passed:
     *    - bitrate too high/low
     *    - ...
     * - There are no more transcoding resources available
     * 
     * @version Release 7.5
     **/
    void TC_AudioCfgSetL(in unsigned short BoardNr, in TC_AudioCfgList_t AudioCfgList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);

    /** Remove audio transcoding settings.
     *
     * @param[in]  BoardNr       The transcoder board for which to configure transcoding.
     * @param[in]  ToDelete      A list of IDs for audio settings to delete
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder board.
     * @exception OpNotSucceeded In case:
     * - invalid input references are used (RefSvc, TrackingID).
     * 
     * @version Release 7.5
     **/
    void TC_AudioCfgDeleteL(in unsigned short BoardNr, in TC_ServiceTrackingID_List_t ToDelete)
         raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get audio status information.
     * Information is only available on audio streams which are currently being transcoded.
     *
     * @param[in]  BoardNr       The transcoder board for which to configure transcoding.
     * @param[in]  ServiceList   The list of services of interest.
     * @param[out] AudioInfoList The status of the audio streams.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder board.
     * @exception OpNotSucceeded In case:
     * - invalid input references are used (RefSvc, TrackingID).
     * 
     * @version Release 7.5
     **/
    void TC_AudioInformationGetL(in unsigned short BoardNr, in IPS_Service_List_t ServiceList, out TC_AudioServiceInformationList_t AudioInfoList)
         raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

         
    /** Get the service bitrate information of transcoded services. 
     *
     * @param[in] RefTS Specifies BoardNr, PortNr & Ref to get the bitrates of.
     *
     * @return ServiceBitRateMeasurementList_t A list of ServiceBitRateMeasurement_t holding the requested bitrate information.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder board.
     * @exception OpNotSucceeded In case invalid PhysRef (board or port) are used.
     *
     * @note
     * - The value 0xFFFF for PortNr and the value 0xFFFFFFFF for Ref means get the bitrate information of all services on a transcoder board.
     * - The value 0xFFFF for PortNr and a valid Ref means get the bitrate information of a single service on a transcoder board.
     *
     * @version Release 7.5
     **/
    ServiceBitRateMeasurementList_t MM_GetTC_ServiceBitRate( in IPS_RefTS_t RefTS) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Get the component bitrate information of transcoded services. 
     *
     * @param[in] RefTS Specifies BoardNr, PortNr & Ref to get the bitrates of.
     * @param[in] lstServices A list of service ID's. An empty list means all services.
     *
     * @return ServiceCompBitRateMeasurementList_t A list of ServiceCompBitRateMeasurement_t holding the requested bitrate information.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder board.
     * @exception OpNotSucceeded In case invalid PhysRef (board or port) are used.
     *
     * @note
     * - The value 0xFFFF for PortNr and the value 0xFFFFFFFF for Ref means get the bitrate information of all services on a transcoder board.
     * - The value 0xFFFF for PortNr and a valid Ref means get the bitrate information of a single service on a transcoder board.
     *
     * @version Release 7.5
     **/
    ServiceCompBitRateMeasurementList_t MM_GetTC_SvcComponentBitRate( in IPS_RefTS_t RefTS, in ServiceIdList_t lstServices) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);        
         
    /** Set the transcoder caption service setttings.
     *
     * @param[in]  BoardNr             The transcoder board on which to apply the settings.
     * @param[in]  Svc_CaptionInfoList A list of caption service settings,
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder board.
     * @exception OpNotSucceeded In case:
     * - invalid input references are used.
     * - invalid settings were passed.
     *
     * @version Release 7.5
     **/
    void TC_CaptionServiceCfgSetL(in unsigned short BoardNr, in TC_Svc_CaptionInfoList_t Svc_CaptionInfoList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the transcoder caption service setttings.
     *
     * @param[in]  BoardNr             The transcoder board to retrieve the settings from.
     * @param[in]  ServiceList         The list of services of interest.
     * @param[out] Svc_CaptionInfoList A list of caption service settings.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder board.
     * @exception OpNotSucceeded In case:
     * - invalid input references are used.
     *
     * @version Release 7.5
     **/
    void TC_CaptionServiceCfgGetL(in unsigned short BoardNr, in IPS_Service_List_t ServiceList, out TC_Svc_CaptionInfoList_t Svc_CaptionInfoList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the video decoding settings.
     *
     * @param[in] BoardNr            The transcoder board for which to configure
     *                               decoding
     * @param[in] VideoDecodeCfgList The video decoding settings
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           transcoder board.
     * @exception OpNotSucceeded in case:
     *    - invalid input references are used (RefSvc)
     *    - there are no more transcoding resources available
     *
     * @version Release 8.2
     */
    void TC_VideoDecodeCfgSetL(in unsigned short BoardNr,
                               in TC_VideoDecodeCfgList_t VideoDecodeCfgList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);

    /** Get the video decoding settings.
     *
     * @param[in]  BoardNr            The transcoder board to retrieve the settings
     *                                from
     * @param[in]  ServiceList        The list of services of interest.
     * @param[out] VideoDecodeCfgList The video decoding settings
     *
     * @version Release 8.2
     */
    void TC_VideoDecodeCfgGetL(in unsigned short BoardNr,
                               in IPS_Service_List_t ServiceList,
                               out TC_VideoDecodeCfgList_t VideoDecodeCfgList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Remove the video decoding settings.
     *
     * @param[in] BoardNr   The transcoder board for which to configure decoding
     * @param[in] ToDelete  A list of IDs for video decoding settings to delete
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           transcoder board.
     * @exception OpNotSucceeded In case:
     * - invalid input references are used (RefSvc, TrackingID).
     *
     * @version Release 8.2
     */
    void TC_VideoDecodeCfgDeleteL(in unsigned short BoardNr,
                                  in TC_ServiceTrackingID_List_t ToDelete)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Set the video encoding settings.
     *
     * @param[in] BoardNr            The transcoder board for which to configure
     *                               encoding
     * @param[in] VideoEncodeCfgList The video encoding settings
     *
     * @note The TrackingID must always correspond to a video decode tracking ID
     *       configured with VideoDecodeCfgSetL(..).  *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           transcoder board.
     * @exception OpNotSucceeded in case:
     *    - invalid input references are used (RefSvc)
     *    - no video decode was configured
     *
     * @version Release 8.2
     */
    void TC_VideoEncodeCfgSetL(in unsigned short BoardNr,
                               in TC_VideoEncodeCfgList_t VideoEncodeCfgList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);

    /** Get the video encoding settings.
     *
     * @param[in]  BoardNr            The transcoder board to retrieve the settings
     *                                from
     * @param[in]  ServiceList        The list of services of interest.
     * @param[out] VideoEncodeCfgList The video encoding settings
     *
     * @version Release 8.2
     */
    void TC_VideoEncodeCfgGetL(in unsigned short BoardNr,
                               in IPS_Service_List_t ServiceList,
                               out TC_VideoEncodeCfgList_t VideoEncodeCfgList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Remove the video encoding settings.
     *
     * @param[in] BoardNr   The transcoder board for which to configure encoding
     * @param[in] ToDelete  A list of IDs for video encoding settings to delete
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           transcoder board.
     * @exception OpNotSucceeded In case:
     * - invalid input references are used (RefSvc, TrackingID).
     *
     * @version Release 8.2
     */
    void TC_VideoEncodeCfgDeleteL(in unsigned short BoardNr,
                                  in TC_ServiceTrackingID_List_t ToDelete)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /// @} end of transcoder
    
    // Logo Insertion
    /////////////////////////////////////////////////////////////////////////////////////// 
    
    /** @defgroup logo Logo Insertion
     * This contains specific types, enums and methods for controlling the logo insertion part of the device.
     * @{
     */

    /// Processor board mode.
    enum enTC_BoardMode_t
    {
      eTC_BoardMode_Transcode,     ///< Processor board only supports video, audio & PIP transcodes
      eTC_BoardMode_LogoInsertion, ///< Processor board only supports logo insertion
      eTC_BoardMode_Reserved_1, ///< not supported yet
      eTC_BoardMode_Reserved_2, ///< not supported yet
      eTC_BoardMode_Reserved_3, ///< not supported yet
      eTC_BoardMode_Reserved_4, ///< not supported yet
      eTC_BoardMode_Reserved_5  ///< not supported yet
    };

    typedef unsigned long FontCfgID_t;
    typedef sequence<FontCfgID_t> FontCfgID_List_t;

    struct FontCfg_t
    {
      FontCfgID_t    FontCfgID;   /**< unique font configuration identifier
                                   * (must be 0 when adding a new font configuration)
                                   */
      string         FontCfgName; ///< font configuration name, maximum 64 characters
      /** Read only Bitmap
       * - Bit 0: TRUE if the font is in use.
       **/
      unsigned long  FontProperty;
    };
    typedef sequence<FontCfg_t> FontCfgList_t;

    typedef unsigned long LogoCfgID_t;
    typedef sequence<LogoCfgID_t> LogoCfgID_List_t;

    /// Playout modes for animated logos
    enum enLogoPlayoutMode_t
    {
      eLogoPlayout_Normal,     ///< once forward
      eLogoPlayout_Palindrome, ///< once forward, once reverse
      eLogoPlayout_Reserved_1, ///< not supported yet
      eLogoPlayout_Reserved_2, ///< not supported yet
      eLogoPlayout_Reserved_3  ///< not supported yet
    };

    struct LogoCfg_t
    {
      LogoCfgID_t    LogoCfgID;   /**< unique logo configuration identifier
                                   * (must be 0 when adding a new logo configuration)
                                   */
      string         LogoCfgName; ///< logo configuration name, maximum 64 characters
      unsigned short X_Position;  ///< X position in pixels (range [0, 1920[), left is 0
      unsigned short Y_Position;  ///< Y position in pixels (range [0, 1080[), top is 0
      unsigned short Opacity;     ///< 10 * opacity in % and in steps of .5 % (e.g. Opacity = 105 means 10.5 %), 
                                  ///< 100% opaque means not transparent at all.
      boolean        DefaultShow; ///< True if the logo should be displayed by default
      unsigned short FadeIn;      ///< in frames, max 300 frames, 0 is instant display
      unsigned short FadeOut;     ///< in frames, max 300 frames, 0 is instant removal
      boolean        AnimatedLogo; ///< False: static logo, true: animated logo
      enLogoPlayoutMode_t enPlayoutMode; ///< Playout mode for animated logos.
      unsigned short LoopCount;     /**< Number of times an animated logo should be displayed:
                                     *   loop count of 0 means animation is played continously,
                                     *   loop count of 3 means animation is played three times
                                     */
      boolean        RemoteLogo; ///< Is the logo locally or remotely stored.


      /**  URL to remote logo
       *
       * Some examles:
       * - http://ipV4/pathtologo
       * - http://ipV4:80/pathtologo 
       * - http://[ipV6]/pathtologo
       * - http://[ipV6]:port/pathtologo    
       **/  
      string         UrlRemoteLogo; ///< URL of the remote logo. Not applicable if RemoteLogo is false.

      /** Read only Bitmap
       * - Bit 0: TRUE if the logo is in use.
       **/
      unsigned long  LogoProperty;
    };
    typedef sequence<LogoCfg_t> LogoCfgList_t;

    struct MaximumLogoSize_t
    {
      unsigned short MaxLogoWidth; ///Maximum logo width in pixels, 0 means unlimited.
      unsigned short MaxLogoHeight;///Maximum logo height in pixels, 0 means unlimited.
    };

    typedef unsigned long LogoFileNumber_t;
    
    struct LogoCfgFileNumber_t
    {
      LogoCfgID_t      LogoCfgID;
      LogoFileNumber_t LogoFileNumber;
    };
    typedef sequence<LogoCfgFileNumber_t> LogoCfgFileNumberList_t;

    enum enTC_LogoCfgSource_t
    {
      eTC_LogoCfgSource_Local,
      eTC_LogoCfgSource_SCTE35,
      eTC_LogoCfgSource_Reserved1,
      eTC_LogoCfgSource_Reserved2,
      eTC_LogoCfgSource_Reserved3
    };

    struct Color_t
    {
      octet R;
      octet G;
      octet B;
    };
    
    typedef unsigned long BannerCfgID_t;
    typedef sequence<BannerCfgID_t> BannerCfgID_List_t;

    struct BannerCfg_t
    {
      BannerCfgID_t  BannerCfgID;     /**< unique banner configuration identifier
                                      * BannerCfgID 0 will be the default banner, it will always
                                      * exist and is undeletable.
                                      * (must also be 0 when adding a new Banner configuration)
                                      */
      string         BannerCfgName;   ///< Banner configuration name, maximum 64 characters
      Color_t        BannerColor;     ///< Only applicable for creating a solid colored banner.
      unsigned short BannerOpacity;   ///< 10 * opacity in % (e.g. OpacityX10 = 11 means an opacity of 1.1%),
                                      ///< 100% opaque means not transparent at all.
      unsigned short BannerWidth;     ///< In pixels.
      unsigned short BannerHeight;    ///< In pixels.
      unsigned short BannerX_Position;///< In pixels, upper left hand corner is (x,y) = (0,0).
      unsigned short BannerY_Position;///< In pixels.
      unsigned short BannerFadeIn;    ///< in frames, max 300 frames, 0 is instant display
      unsigned short BannerFadeOut;   ///< in frames, max 300 frames, 0 is instant removal   
      LogoCfgID_List_t BannerLogoIDs; ///< Logos to display along with the banner
      FontCfgID_t    TextFontID;      ///< The font ID to be used
      Color_t        TextColor;       ///< Text color
      unsigned short TextOpacity;     ///< 10 * opacity in % (e.g. OpacityX10 = 11 means an opacity of 1.1%),
                                      ///< 100% opaque means not transparent at all.
      unsigned short TextHeight;      ///< In pixels. Must be smaller or equal to BannerHeight
      unsigned short TextMaxWidth;    ///< In pixels. Must be smaller or equal to BannerWidth
      unsigned short TextLoopCount;   /**< Number of times an banner should be displayed:
                                      *   loop count of 0 means animation is played continously,
                                      *   loop count of 3 means animation is played three times
                                      */
      long           TextSpeed;       ///< Scrolling speed of the text in pixels/frame. Positive values scroll
                                      ///< from right to left, negative values from left to right.
      /** Read only Bitmap
       * - Bit 0: TRUE if the Banner is in use.
       **/
      unsigned long  BannerProperty;
    };
    typedef sequence<BannerCfg_t> BannerCfgList_t;

    enum enBannerTextEncoding_t
    {
      eBannerTextEncoding_ASCII,     ///< ASCII-Latin1 ISO-8859-1
      eBannerTextEncoding_UTF8,      ///< UTF-8
      eBannerTextEncoding_Reserved3, ///< Reserved for future use
      eBannerTextEncoding_Reserved4, ///< Reserved for future use
      eBannerTextEncoding_Reserved5, ///< Reserved for future use
      eBannerTextEncoding_Reserved6, ///< Reserved for future use
      eBannerTextEncoding_Reserved7, ///< Reserved for future use
      eBannerTextEncoding_Reserved8  ///< Reserved for future use
    };

    ///< Behaviour when the banner is stopped
    enum enBannerStopType_t
    {
      eBannerStopType_Direct,    ///< Banner stops immediately
      eBannerStopType_OnLoop,    ///< Banner stops if current loop is finished
      eBannerStopType_Reserved3, ///< Reserved for future use
      eBannerStopType_Reserved4, ///< Reserved for future use
      eBannerStopType_Reserved5, ///< Reserved for future use
      eBannerStopType_Reserved6, ///< Reserved for future use
      eBannerStopType_Reserved7, ///< Reserved for future use
      eBannerStopType_Reserved8  ///< Reserved for future use
    };

    struct BannerCfg_V2_t
    {
      BannerCfgID_t  BannerCfgID;     /**< unique banner configuration identifier
                                      * BannerCfgID 0 will be the default banner, it will always
                                      * exist and is undeletable.
                                      * (must also be 0 when adding a new Banner configuration)
                                      */
      string         BannerCfgName;   ///< Banner configuration name, maximum 64 characters
      Color_t        BannerColor;     ///< Only applicable for creating a solid colored banner.
      unsigned short BannerOpacity;   ///< 10 * opacity in % (e.g. OpacityX10 = 11 means an opacity of 1.1%),
                                      ///< 100% opaque means not transparent at all.
      unsigned short BannerWidth;     ///< In pixels.
      unsigned short BannerHeight;    ///< In pixels.
      unsigned short BannerX_Position;///< In pixels, upper left hand corner is (x,y) = (0,0).
      unsigned short BannerY_Position;///< In pixels.
      unsigned short BannerFadeIn;    ///< in frames, max 300 frames, 0 is instant display
      unsigned short BannerFadeOut;   ///< in frames, max 300 frames, 0 is instant removal
      LogoCfgID_List_t BannerLogoIDs; ///< Logos to display along with the banner
      FontCfgID_t    TextFontID;      ///< The font ID to be used
      Color_t        TextColor;       ///< Text color
      unsigned short TextOpacity;     ///< 10 * opacity in % (e.g. OpacityX10 = 11 means an opacity of 1.1%),
                                      ///< 100% opaque means not transparent at all.
      unsigned short TextHeight;      ///< In pixels. Must be smaller or equal to BannerHeight
      unsigned short TextMaxWidth;    ///< In pixels. Must be smaller or equal to BannerWidth
      unsigned short TextLoopCount;   /**< Number of times an banner should be displayed:
                                      *   loop count of 0 means animation is played continously,
                                      *   loop count of 3 means animation is played three times
                                      */
      long           TextSpeed;       ///< Scrolling speed of the text in pixels/frame. Positive values scroll
                                      ///< from right to left, negative values from left to right.
      /** Read only Bitmap
       * - Bit 0: TRUE if the Banner is in use.
       **/
      unsigned long  BannerProperty;
      string         DefaultBannerText;     /**< Default banner text, encoded in UTF-8, 
                                            *    If the text is empty (contains no characters) and the default 
                                            *    banner text must be used, the banner is not displayed.
                                            */
      enBannerStopType_t enBannerStopType;  ///< Behaviour when the banner is stopped. From version release 9.0
    };
    typedef sequence<BannerCfg_V2_t> BannerCfg_V2_List_t;   

    struct TC_Banner_t
    {
      BannerCfgID_t BannerCfgID;
      string        BannerText;    /**< Encoded in ASCII
                                   *    For an empty text (no characters), the banner text will be used
                                   *    as defined in the corresponding banner configuration.
                                   */
      unsigned long BannerTimeout; ///< Time (in seconds) the banner may remain on screen. (0 for no timeout)
                                   ///< The banner is removed if the loop count or timeout is reached, whichever is first.
    };

    struct TC_Banner_V2_t
    {
      BannerCfgID_t BannerCfgID;
      string        BannerText;    /**< Encoded according to BannerTextEncoding
                                   *    For an empty text (no characters), the banner text will be used
                                   *    as defined in the corresponding banner configuration.
                                   */
      unsigned long BannerTimeout; ///< Time (in seconds) the banner may remain on screen. (0 for no timeout)
                                   ///< The banner is removed if the loop count or timeout is reached, whichever is first.
      enBannerTextEncoding_t  BannerTextEncoding ; ///< Encoding  of  the BannerText  
    };

    enum enTC_AllowedBanner_t
    {
      eTC_AllowedBanner_None,
      eTC_AllowedBanner_Text_Only,     ///< A text crawl without logos
      eTC_AllowedBanner_Text_Static,   ///< A text crawl and one or more static logos
      eTC_AllowedBanner_Text_Animated, ///< A text crawl and one or more static or animated logos
      eTC_AllowedBanner_Reserved1,     ///< Reserved for future use
      eTC_AllowedBanner_Reserved2,     ///< Reserved for future use
      eTC_AllowedBanner_Reserved3,     ///< Reserved for future use
      eTC_AllowedBanner_Reserved4      ///< Reserved for future use
    };

    enum enTC_BannerPriority_t
    {
      eTC_BannerPriority_Keep_Logos,    ///< Do not remove active logos (unless there are not enough resources)
      eTC_BannerPriority_Remove_Logos,  ///< Remove logos before activating the banner
      eTC_BannerPriority_Reserved1,     ///< Reserved for future use
      eTC_BannerPriority_Reserved2,     ///< Reserved for future use
      eTC_BannerPriority_Reserved3      ///< Reserved for future use
    };

    enum enTC_EAS_Control_t
    {
      eTC_EAS_Control_Disabled,  ///< Do not insert EAS alerts
      eTC_EAS_Control_Enabled,   ///< Insert EAS alerts
      eTC_EAS_Control_Reserved1, ///< Reserved for future use
      eTC_EAS_Control_Reserved2, ///< Reserved for future use
      eTC_EAS_Control_Reserved3  ///< Reserved for future use
    };

    struct TC_BannerSettings_t
    {
      IPS_RefSvc_t          RefSvc;
      enTC_AllowedBanner_t  enAllowedBanner;
      enTC_BannerPriority_t enBannerPriority;
      enTC_EAS_Control_t    enEAS_Control;    ///< Only affects banners triggered through StartEAS()
    };
    typedef sequence<TC_BannerSettings_t> TC_BannerSettingsList_t;
  
    struct TC_BannerStatus_t
    { 
      BannerCfgID_t BannerCfgID;    ///< The configuration of the active banner
      boolean       bIsEAS_Banner;  ///< True if the banner is an EAS alert banner
    };
    typedef sequence<TC_BannerStatus_t> TC_BannerStatusList_t;

    struct TC_ServiceBannerStatus_t
    {
      IPS_RefSvc_t          RefSvc;
      TC_BannerStatusList_t Banners; ///< The list of active banners (always zero or one elements)
    };
    typedef sequence<TC_ServiceBannerStatus_t> TC_ServiceBannerStatusList_t;
 
    typedef unsigned long TC_ServiceLogoID_t;

    struct TC_LogoSetting_t
    {
      TC_ServiceLogoID_t ServiceLogoID;
      LogoCfg_t          LogoCfg;           ///< logo configuration
      boolean            ShowLogoStatus;    ///< Is the logo currently show in the video?
    };
    typedef sequence<TC_LogoSetting_t> TC_LogoSettingList_t;

    struct TC_Logo_t
    {
      IPS_RefSvc_t         Service;
      TC_LogoSettingList_t Logo;
    };
    typedef sequence<TC_Logo_t> TC_LogoList_t;

    struct TC_LogoDisplay_t
    {
      TC_ServiceLogoID_t ServiceLogoID;
      boolean            bDisplay;  ///< True if the logo should be inserted in the video
      boolean            bFade;     ///< True if the fade in/out time should be respected. False for instant changes.
    };
    typedef sequence<TC_LogoDisplay_t> TC_LogoDisplayList_t;

    struct TC_ServiceLogoDisplay_t
    {
      IPS_RefSvc_t         Service;
      TC_LogoDisplayList_t LogoDisplay;
    };
    typedef sequence<TC_ServiceLogoDisplay_t> TC_ServiceLogoDisplayList_t;

    struct TC_LogoCfg_t
    {
      IPS_RefSvc_t         Service;
      TC_ServiceLogoID_t   ServiceLogoID;
      LogoCfg_t            LogoCfg;
      enTC_LogoCfgSource_t enLogoCfgSource;
    };
    typedef sequence<TC_LogoCfg_t> TC_LogoCfgList_t;

    typedef unsigned long TC_KeyerID_t;
    struct TC_LogoKeyerID_t
    {
      IPS_RefSvc_t         Service;         ///< read-only
      TC_ServiceLogoID_t   ServiceLogoID;   ///< read-only
      TC_KeyerID_t         KeyerID;
      enTC_LogoCfgSource_t enLogoCfgSource; ///< read-only
    };
    typedef sequence<TC_LogoKeyerID_t> TC_LogoKeyerID_List_t; 

    struct TC_ServiceLogoCfgID_t 
    {
      IPS_RefSvc_t       Service;
      TC_ServiceLogoID_t ServiceLogoID;
      LogoCfgID_t        LogoCfgID;
    };
    typedef sequence<TC_ServiceLogoCfgID_t> TC_ServiceLogoCfgID_List_t;

    /** Add a logo to the logo library.
     *
     * @param[in]  LogoCfg    Configuration data of the logo.
     * @param[in]  FileFormat Indicates how the logo data is encoded. This must be "png" for still 
     *                        logos and "mng" for animated logos.
     * @param[in]  Logo       The logo data. This must be a png of mng file. For remote logos this should be empty.
     *
     * @exception OpNotSucceeded in case:
     * - the logo is not a valid logo.
     * - no more entries are available (maximum 128 logos).
     * - a logo of the same name already exists in the logo library.
     *
     * @version Release 8.1
     **/
    void LogoLibrary_Add(in LogoCfg_t LogoCfg, in string FileFormat, in ByteStream Logo)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Export (=download) a logo from the logo library.
     *
     * @param[in]  LogoCfgID   ID of the requested logo.
     * @param[in]  FileFormat  Indicates how the logo data must be encoded. This must be "png" if a 
     *                         still image is expected. And a "mng" if a animated logo is expected.
     * @param[out] Logo        The logo data. This is a png or mng file.
     *
     * @exception OpNotSucceeded in case:
     * - the logo ID is not valid.
     *
     * @version Release 8.1
     **/
    void LogoLibrary_ExportLogo(in LogoCfgID_t LogoCfgID, in string FileFormat,
        out ByteStream Logo)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get information about logos in the logo library.
     *
     * @param[in]  LogoCfgID_List List of logo ID's to get information about. If
     *                            empty, the function returns information for all logos.
     * @param[out] LogoCfgList    A list of logo configuration data
     *
     * @version Release 8.1
     **/
    void LogoLibrary_LogoCfgGetL(in LogoCfgID_List_t LogoCfgID_List, out LogoCfgList_t LogoCfgList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Update about certain logos in the logo library.
     * The 'AnimatedLogo' flag can't be updated.
     *
     * @param[in] LogoCfgList A list of logo configuration data
     *
     * @exception OpNotSucceeded in case:
     * - one of the logo ID's is not valid.
     * - one of elements in the list is not valid, e.g. if one of the elements.
     *   defines a logo name which another logo already has as name.
     *
     * @version Release 8.1
     **/
    void LogoLibrary_LogoCfgSetL(in LogoCfgList_t LogoCfgList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Remove one or more logos from the logo library.
     *
     * @param[in] LogoCfgID_List ID's of the logos to remove
     *
     * @exception OpNotSucceeded in case of:
     * - one of the logo ID's is invalid.
     * - one of the logo configurations is in use.
     *
     * @version Release 8.1
     **/
    void LogoLibrary_LogoCfgDeleteL(in LogoCfgID_List_t LogoCfgID_List)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the mapping between LogoCfgID and LogoFileNumber.
     *
     * @param[in]  LogoCfgID_List List of logo ID's to get information about. If
     *                            empty, the function returns information for all logos.
     * @param[out] LogoCfgFileNumbers The mapping between the logo config numbers and the logo file numbers.
     * 
     * @exception OpNotSucceeded in case:
     * - Invalid references are used (LogoID)
     *
     * @version Release 8.1
     **/
    void LogoLibrary_LogoCfgFileNrGetL(in LogoCfgID_List_t LogoCfgID_List, out LogoCfgFileNumberList_t LogoCfgFileNumbers)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Set the mapping between LogoCfgID and LogoFileNumber.
     * The LogoFileNumber must be part of [1, 16].
     * A mapping can be removed by setting the LogoFileNumber to 0.
     *
     * @param[in] LogoCfgFileNumbers The mapping between the logo config numbers and the logo file numbers.
     * 
     * @exception OpNotSucceeded in case:
     * - Invalid references are used (LogoID)
     * - Multiple LogoCfgIDs would get the same LogoFileNumber.
     *
     * @version Release 8.1
     **/
    void LogoLibrary_LogoCfgFileNrSetL(in LogoCfgFileNumberList_t LogoCfgFileNumbers)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set device-wide maximum logo size.
    *   The maximum accepted size for logos added in the future will be set.
    *   Already uploaded logo's can be larger!
    *   All remote logos will always follow these maxima.
    *
    * @param[in] MaxLogoSize The maximum logo size.
    *
    * @version Release 8.2
    **/
    void LogoLibrary_SetMaxLogoSize(in MaximumLogoSize_t MaxLogoSize)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the device-wide maximum logo size.
    *   Get the maximum accepted size for logos added in the future.
    *   Already uploaded logo's can be larger!
    *   All remote logos will always follow these maxima.    
    *
    * @param[out] MaxLogoSize The maximum logo size.
    *
    * @version Release 8.2
    **/
    void LogoLibrary_GetMaxLogoSize(out MaximumLogoSize_t MaxLogoSize)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);    

    /** Add a Font to the Font library.
     *
     * @param[in]  FontCfg    Configuration data of the Font.
     * @param[in]  FileFormat Indicates how the Font data is encoded. This must be "ttf".
     * @param[in]  Font       The Font data. This must be a TrueTypeFont (ttf) file.
     *
     * @exception OpNotSucceeded in case:
     * - the Font is not a valid Font.
     * - no more entries are available (maximum 128 Fonts).
     * - a Font of the same name already exists in the Font library.
     *
     * @version Release 8.2
     **/
    void FontLibrary_Add(in FontCfg_t FontCfg, in string FileFormat, in ByteStream Font)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get information about fonts in the font library.
     *
     * @param[in]  FontCfgID_List List of font ID's to get information about. If
     *                            empty, the function returns information for all fonts.
     * @param[out] FontCfgList    A list of font configuration data
     *
     * @version Release 8.2
     **/
    void FontLibrary_FontCfgGetL(in FontCfgID_List_t FontCfgID_List, out FontCfgList_t FontCfgList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Update certain Fonts in the Font library.
     *
     * @param[in] FontCfgList A list of Font configuration data
     *
     * @exception OpNotSucceeded in case:
     * - one of the Font ID's is not valid.
     * - one of elements in the list is not valid, e.g. if one of the elements.
     *   defines a Font name which another Font already has as name.
     *
     * @version Release 8.2
     **/
    void FontLibrary_FontCfgSetL(in FontCfgList_t FontCfgList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Remove one or more Fonts from the Font library.
     *
     * @param[in] FontCfgID_List ID's of the Fonts to remove
     *
     * @exception OpNotSucceeded in case of:
     * - one of the Font ID's is invalid.
     * - one of the Font configurations is in use.
     *
     * @version Release 8.2
     **/
    void FontLibrary_FontCfgDeleteL(in FontCfgID_List_t FontCfgID_List)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Add a Banner to the Banner library.
     *
     * @param[in]  BannerCfg    Configuration data of the Banner.
     *
     * @exception OpNotSucceeded in case:
     * - the Banner is not a valid Banner.
     * - no more entries are available (maximum 256 Banners).
     * - a Banner of the same name already exists in the Banner library.
     *
     * @version Release 8.2
     **/
    void BannerLibrary_Add(in BannerCfg_t BannerCfg)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Add a Banner to the Banner library.
     *
     * @param[in]  BannerCfg    Configuration data of the Banner.
     *
     * @exception OpNotSucceeded in case:
     * - the Banner is not a valid Banner.
     * - no more entries are available (maximum 256 Banners).
     * - a Banner of the same name already exists in the Banner library.
     *
     * @version Release 8.9
     **/
    void BannerLibrary_V2_Add(in BannerCfg_V2_t BannerCfg)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get information about Banners in the Banner library.
     *
     * @param[in]  BannerCfgID_List List of Banner ID's to get information about. If
     *                            empty, the function returns information for all Banners.
     * @param[out] BannerCfgList    A list of Banner configuration data
     *
     * @version Release 8.2
     **/
    void BannerLibrary_BannerCfgGetL(in BannerCfgID_List_t BannerCfgID_List, out BannerCfgList_t BannerCfgList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get information about Banners in the Banner library.
     *
     * @param[in]  BannerCfgID_List List of Banner ID's to get information about. If
     *                            empty, the function returns information for all Banners.
     * @param[out] BannerCfgList    A list of Banner configuration data
     *
     * @version Release 8.9
     **/
    void BannerLibrary_BannerCfg_V2_GetL(in BannerCfgID_List_t BannerCfgID_List, out BannerCfg_V2_List_t BannerCfgList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);    

    /** Update certain Banners in the Banner library.
     *
     * @param[in] BannerCfgList A list of Banner configuration data
     *
     * @exception OpNotSucceeded in case:
     * - one of the Banner ID's is not valid.
     * - one of elements in the list is not valid, e.g. if one of the elements.
     *   defines a Banner name which another Banner already has as name.
     *
     * @version Release 8.2
     **/
    void BannerLibrary_BannerCfgSetL(in BannerCfgList_t BannerCfgList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Update certain Banners in the Banner library.
     *
     * @param[in] BannerCfgList A list of Banner configuration data
     *
     * @exception OpNotSucceeded in case:
     * - one of the Banner ID's is not valid.
     * - one of elements in the list is not valid, e.g. if one of the elements.
     *   defines a Banner name which another Banner already has as name.
     *
     * @version Release 8.9
     **/
    void BannerLibrary_BannerCfg_V2_SetL(in BannerCfg_V2_List_t BannerCfgList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Remove one or more Banners from the Banner library.
     *
     * @param[in] BannerCfgID_List ID's of the Banners to remove
     *
     * @exception OpNotSucceeded in case of:
     * - one of the Banner ID's is invalid.
     * - one of the Banner configurations is in use.
     *
     * @version Release 8.2
     **/
    void BannerLibrary_BannerCfgDeleteL(in BannerCfgID_List_t BannerCfgID_List)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the processor board mode.
     *
     * @param[in]  BoardNr      The processor board number
     * @param[out] enBoardMode  Requested board mode
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           processor board.
     * @version Release 8.1
     **/
    void TC_GetBoardMode(in unsigned short BoardNr, out enTC_BoardMode_t enBoardMode)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the processor board mode.
     *
     * @param[in] BoardNr      The processor board number
     * @param[in] enBoardMode  Board mode to set
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           processor board.
     * @exception OpNotSucceeded if the new board mode is different from the current
     *            board mode and there are currently transcodes or logo insertions configured.
     *
     * @version Release 8.1
     **/
    void TC_SetBoardMode(in unsigned short BoardNr, in enTC_BoardMode_t enBoardMode)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
 
    /** Update the logo settings on the logo processing board.
     * @note: The settings done through this call are not persistent.
     *
     * @param[in] BoardNr     The processor board number
     * @param[in] LogoCfgList The updated logo configurations
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a
     *                           processing board.
     * @exception OpNotSucceeded If the service doesn't exist or doesn't have a logo with that ID configured.
     *
     * @version Release 8.1
     **/
    void TC_LogoCfgSetL(in unsigned short BoardNr, in TC_LogoCfgList_t LogoCfgList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the current logo ID to keyer ID mapping.
     *
     * @param[in]  BoardNr      The processor board number
     * @param[in]  SvcList      The list of services of interest
     * @param[in]  LogoKeyerIDs The logo ID to keyer ID mappings.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder board.
     * @exception OpNotSucceeded in case:
     * - invalid input references are used (RefSvc)
     *
     * @version Release 8.1
     **/
    void TC_LogoKeyerGetL(in unsigned short BoardNr, in IPS_Service_List_t SvcList, out TC_LogoKeyerID_List_t LogoKeyerIDs)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
   
    /** Update the LogoID <-> Keyer ID mapping .
     * A keyer ID of 0 means no keyer is assigned.
     * Any other keyer ID ([1-8]) can only be assigned to one logo (per services).
     * An assigned keyer ID can be removed by setting it to 0.
     *
     * @param[in] BoardNr      The processor board number
     * @param[in] LogoKeyerIDs The logo ID to keyer ID mappings.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder board.
     * @exception OpNotSucceeded in case:
     * - Invalid references are used (RefSvc, LogoID)
     * - One keyer ID is assigned to multiple logos
     * - The keyer ID is invalid
     *
     * @version Release 8.1
     **/
    void TC_LogoKeyerUpdateL(in unsigned short BoardNr, in TC_LogoKeyerID_List_t LogoKeyerIDs)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Add one or more logo configurations to one or more services.
     * The ServiceLogoID must be set to 0.
     * 
     * @param[in] BoardNr      The processor board number
     * @param[in] LogoToAdd Logo configurations to add
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder
     *                                                 board.
     * @exception OpNotSucceeded in case:
     * - invalid input references are used (RefSvc, LogoCfgID)
     * - no more entries are available
     *
     * @version Release 8.1
     **/
    void TC_LogoAddL(in unsigned short BoardNr, in TC_ServiceLogoCfgID_List_t LogoToAdd)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);
    
    /** Remove one or more logo configurations from one or more services.
     * If the logo is currently displayed it will be removed immediately.
     *
     * @param[in] BoardNr        The processor board number
     * @param[in] LogosToDelete  List of logo configurations to delete
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder
     *                                                 board.
     * @exception OpNotSucceeded in case:
     * - invalid input references are used (RefSvc, LogoCfgID)
     *
     * @version Release 8.1
     **/
    void TC_LogoDeleteL(in unsigned short BoardNr, in TC_ServiceLogoCfgID_List_t LogosToDelete)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get logo transcoding settings.
     *
     * @param[in]  BoardNr           The processor board number
     * @param[in]  ServiceList       The list of services of interest
     * @param[out] LogoList       Requested logo transcoding settings
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder
     *                                                  board.
     * @exception OpNotSucceeded in case:
     * - invalid input references are used (RefSvc)
     *
     * @version Release 8.1
     */
    void TC_LogoGetL(in unsigned short BoardNr, in IPS_Service_List_t ServiceList,
        out TC_LogoList_t LogoList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Update the display status of logos.
     * These settings are not persistent.
     *
     * @param[in]  BoardNr           The processor board number
     * @param[in]  LogoDisplayList   The new logo display settings.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not a transcoder
     *                                                  board.
     * @exception OpNotSucceeded in case:
     * - invalid input references are used (RefSvc, LogoCfgID)
     * - Too many logos would be displayed
     *
     * @version Release 8.1
     **/
    void TC_LogoDisplayL(in unsigned short BoardNr, in TC_ServiceLogoDisplayList_t LogoDisplayList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the banner configuration
     *
     * @param[in]  BoardNr            The board number
     * @param[in]  ServiceList        The list of service to retrieve the settigns for
     * @param[out] BannerSettingsList The banner configurations
     *
     * @exception OpNotSucceeded in case:
     * - The board is not a transcoder board
     * - One of the services does not exist
     *
     * @version Release 8.2
     **/
    void TC_BannerSettingsGetL(in unsigned short BoardNr, in IPS_Service_List_t ServiceList, out TC_BannerSettingsList_t BannerSettingsList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Update the banner configuration
     *
     * @param[in]  BoardNr       The board number
     * @param[in]  BannerSettingsList The new banner configurations
     *
     * @exception OpNotSucceeded in case:
     * - The board is not a transcoder board
     * - One of the services does not exist
     *
     * @version Release 8.2
     **/
    void TC_BannerSettingsSetL(in unsigned short BoardNr, in TC_BannerSettingsList_t BannerSettingsList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);

    /** Start a banner
     *
     * @param[in]  BoardNr     The board number
     * @param[in]  ServiceList The list of services to insert the banner into, an empty list means all services
     * @param[in]  Banner      The banner to insert
     *
     * @exception OpNotSucceeded in case:
     * - The board is not a transcoder board
     * - One of the services does not exist
     * @exception LicenseError in case:
     * - The service is not configured to accept banners
     *
     * @version Release 8.2
     **/
    void TC_StartBanner(in unsigned short BoardNr, in IPS_Service_List_t ServiceList, in TC_Banner_t Banner)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);
  
    /** Start a banner
     *
     * @param[in]  BoardNr     The board number
     * @param[in]  ServiceList The list of services to insert the banner into, an empty list means all services
     * @param[in]  Banner      The banner to insert
     *
     * @exception OpNotSucceeded in case:
     * - The board is not a transcoder board
     * - One of the services does not exist
     * @exception LicenseError in case:
     * - The service is not configured to accept banners
     *
     * @version Release 8.7
     **/
    void TC_StartBanner_V2(in unsigned short BoardNr, in IPS_Service_List_t ServiceList, in TC_Banner_V2_t Banner)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);       

    /** Retrieve the list of banner statuses.
     *
     * @param[in]  BoardNr     The board number
     * @param[in]  ServiceList The list of services to query, an empty list means all services
     * @param[out] Banners     The list of banner statuses
     *
     * @exception OpNotSucceeded in case:
     * - The board is not a transcoder board
     * - One of the services does not exist
     *
     * @version Release 8.2
     **/
    void TC_BannerStatusGetL(in unsigned short BoardNr, in IPS_Service_List_t ServiceList, out TC_ServiceBannerStatusList_t Banners)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);
 
    /** Start an EAS message.
     * This will insert a banner into all services (on logo insertion boards) 
     * which have their enEAS_Control field set to Enabled.
     *
     * @param[in]  SAME      The SAME code of the alert
     * @param[in]  AlertText The text to show encoded in ASCII
     *                       For an empty text (no characters), the banner text will be used
     *                       as defined in the corresponding banner configuration.
     * @param[in]  BannerTimeout The maximum duration of the banner (in seconds) (0 for no timeout)
     *
     * @version Release 8.2
     **/
    void StartEAS(in string SAME, in string AlertText, in unsigned long BannerTimeout)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Start an EAS message.
     * This will insert a banner into all services (on logo insertion boards)
     * which have their enEAS_Control field set to Enabled.
     *
     * @param[in]  SAME      The SAME code of the alert
     * @param[in]  AlertText The text to show. For an empty text (no characters), the banner text will be used
     *                       as defined in the corresponding banner configuration.     
     * @param[in]  BannerTimeout The maximum duration of the banner (in seconds) (0 for no timeout)
     * @param[in]  AlertTextEncoding The encoding of the AlertText
     *
     * @version Release 8.7
     **/
    void StartEAS_V2(in string SAME, in string AlertText, in unsigned long BannerTimeout,in enBannerTextEncoding_t  AlertTextEncoding)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Start an EAS message.
     * This will insert a banner into all services (on logo insertion boards)
     * which have their enEAS_Control field set to Enabled.
     *
     * @param[in]  SAME              The SAME code of the alert
     * @param[in]  AlertText         The text to show. For an empty text (no characters), the banner text will be used
     *                               as defined in the corresponding banner configuration.
     * @param[in]  BannerTimeout     The maximum duration of the banner (in seconds) (0 for no timeout)
     * @param[in]  AlertTextEncoding The encoding of the AlertText
     * @param[in]  TextLoopCount     Number of times an banner should be displayed
     *                               loop count of 0 means banner is played continously,
     *                               loop count of 3 means banner is played three times
     *                               loop count of 0xFFFE means the TextLoopCount of the corresponding banner configuration is used
     *
     * @version Release 8.9
     **/
    void StartEAS_V3(in string SAME, in string AlertText, in unsigned long BannerTimeout,in enBannerTextEncoding_t  AlertTextEncoding, in unsigned short TextLoopCount)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Stop any banner in the service
     * This will stop any active banner (and EAS) in all of the listed services.
     *
     * @param[in]  BoardNr The board number
     * @param[in]  ServiceList The services where the banners must be stopped.
     *                         An empty list means all services.
     *
     * @exception OpNotSucceeded in case:
     * - The board is not a transcoder board
     * - One of the services does not exist
     *
     * @version Release 8.2
     **/
    void TC_StopBanner(in unsigned short BoardNr, in IPS_Service_List_t ServiceList) 
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Stop all banners on all services
     * This will stop any active banner (and EAS) on any logo insertion board
     *
     * @version Release 8.2
     **/
    void StopBanners()
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /**
     * @brief Get the DSP currently processing a certain PID.
     * Not supported if the board is in eTC_BoardMode_LogoInsertion mode.
     *
     * @param[in]   SlotNbr  transcoder board to set in loop back mode
     * @param[in]   RefPid   The PID for which to find the DSP
     *
     * @exception OpNotSupported  when called for non-transcoder boards.
     * @exception OpNotSucceeded  if the PID is not being transcoded
     *
     * @version Release 7.1
     **/
    unsigned short TC_GetDSP_Number(in unsigned short SlotNbr, in IPS_RefPid_t RefPid)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /// @} end of logo insertion

#endif // DISABLE_TRANSCODER

    // Transrater Resource Counting (in function of DPI Capacity Check)
    /////////////////////////////////////////////////////////////////////////////////////// 
    
    /** @defgroup TR_ResourceCounting Transrater Resource Counting
     * This contains specific types, enums and methods for controlling the Transrater Resource Counting part of the device.
     * @{
     */    
#ifndef DISABLE_TRANSRATER 

    /// Video format needed to calculate different loads on TR board
    enum enTR_VideoFormat
    {
      eTR_NTSC,
      eTR_PAL,
      eTR_VideoFormat_Reserved1,
      eTR_VideoFormat_Reserved2,
      eTR_VideoFormat_Reserved3,
      eTR_VideoFormat_Reserved4,
      eTR_VideoFormat_Reserved5,
      eTR_VideoFormat_Reserved6
    };
 
    /// Settings needed to calculate different loads on TR board which can be modified by user  
    struct TR_ResourceCountingSettings_t
    {
      enTR_VideoFormat      eTR_VideoFormat;
      unsigned long         ulMaxSD_Bitrate;     ///< in bps
      unsigned long         ulMaxHD_Bitrate;     ///< in bps
      unsigned long         ulMaxAudioBitrate;   ///< in bps
      unsigned short        usMaxNbrOfAudios;
    };

    /// Calculated loads on TR board available for user  
    struct TR_ResourceCountingLoads_t
    {
      unsigned short        usCurrentLoad;                 ///< in 0.01%
      unsigned short        usMaxReachedLoad;              ///< in 0.01%
      unsigned short        usMaxLoadSimultanousSplices;   ///< in 0.01%
    };

    /** Enable/disable denying of splice_request based on available resources.
     *
     * For splicing sufficient subgroup resources must be available in order to guarantee a successful splice.
     * When enabled, resource checking is done and if needed, the splice_request is denied
     * with a splice_response containing RC 114 = Splice Queue Full.
     *
     * @param[in] BoardNr
     * @param[in] bEnabled 
     *
     * @exception OpNotSucceeded  In case of invalid BoardNr or when no transrater board is available
     *
     * @version Release 8.2
     */    
     void TR_SetGuaranteedSplicesEnabled(in unsigned short BoardNr, in boolean bEnabled) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Query whether denying of splice_request based on available resources is enabled/disabled.
     *
     * @param[in] BoardNr
     * @param[out] bEnabled 
     *
     * @exception OpNotSucceeded  In case of invalid BoardNr or when no transrater board is available
     *
     * @version Release 8.2
     */    
     void TR_GetGuaranteedSplicesEnabled(in unsigned short BoardNr, out boolean bEnabled) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Resets the maximum reached load on a TR board. 
     *
     * @param[in] BoardNr
     *
     * @exception OpNotSucceeded  In case of invalid BoardNr or when no transrater board is available
     *
     * @version Release 8.2
     */    
     void TR_ResetMaximumReachedLoad(in unsigned short BoardNr) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set settings needed to calculate different loads on TR board 
     *
     * @param[in] BoardNr
     * @param[in] TR_ResourceCountingSettings
     *
     * @exception OpNotSucceeded  In case of invalid BoardNr or when no transrater board is available
     *
     * @version Release 8.2
     */    
     void TR_SetResourceCountingSettings(in unsigned short BoardNr, in TR_ResourceCountingSettings_t TR_ResourceCountingSettings) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get settings needed to calculate different loads on TR board  
     *
     * @param[in] BoardNr
     * @param[out] TR_ResourceCountingSettings
     *
     * @exception OpNotSucceeded  In case of invalid BoardNr or when no transrater board is available
     *
     * @version Release 8.2
     */    
     void TR_GetResourceCountingSettings(in unsigned short BoardNr, out TR_ResourceCountingSettings_t TR_ResourceCountingSettings) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
     
    /** Get calculated loads on TR board
     *
     * @param[in] BoardNr
     * @param[out] TR_ResourceCountingLoads
     *
     * @exception OpNotSucceeded  In case of invalid BoardNr or when no transrater board is available
     *
     * @version Release 8.2
     */    
     void TR_GetResourceCountingLoads(in unsigned short BoardNr, out TR_ResourceCountingLoads_t TR_ResourceCountingLoads) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
     
    /** Set flag to take/don't take load into account depending on streaming state of service.
     *
     * When set to true, the load of a transrated/spliceable service which is not streaming, 
     * is not taken into account.
     *
     * @param[in] BoardNr
     * @param[in] bStopStreamingReducesLoad 
     *
     * @exception OpNotSucceeded  In case of invalid BoardNr or when no transrater board is available
     *
     * @version Release 8.5
     */    
     void TR_SetStopStreamingReducesLoad(in unsigned short BoardNr, in boolean bStopStreamingReducesLoad) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get flag to take/don't take load into account depending on streaming state of service.
     *
     * @param[in] BoardNr
     * @param[out] bStopStreamingReducesLoad 
     *
     * @exception OpNotSucceeded  In case of invalid BoardNr or when no transrater board is available
     *
     * @version Release 8.5
     */    
     void TR_GetStopStreamingReducesLoad(in unsigned short BoardNr, out boolean bStopStreamingReducesLoad) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /// @} end of Transrater Resource Counting (in function of DPI Capacity Check)    
    
    // TRANSRATER
    /////////////////////////////////////////////////////////////////////////////////////// 
    
    /** @defgroup transrater Transrater
     * This contains specific types, enums and methods for controlling the transrater part of the device.
     * @{
     */

    // Transrater structures & enums
    // ------------------------------------------------------------------------------------
    struct TR_GroupID_t
    {
      unsigned long ID; ///< Group ID in the range [2, 501], group ID 1 may not be used.
      long Status; ///< Status field (for future use).
    }; ///< Used for referencing transrater staging groups.
    
    typedef sequence<TR_GroupID_t> TR_GroupID_List_t;///< A sequence of TR_GroupID_t.

    enum eTR_ServiceMode
    {
      SrvM_PassThrough, ///< The service is only delayed, not transrated.
      SrvM_StatMux, ///< The service is part of a statmux group and transrated according to the maximum rate of that group also, not only it's own min max bitrate.
      SrvM_RateLimit ///< The service is transrated only to it's own max bitrate (in fact minimum equals maximum bitrate in case of rate limit).
    }; ///<  The transrater service mode is the way the service should be handld by the transrater board.
 
    enum eTR_BoardDelayMode
    {
      DM_NormalDelay, ///< Normal delay.
      DM_LowDelay ///< Low delay (for future use).
    }; ///< The delay mode of the transrater board. Delay is the time difference between a non-transrated and transrated service.  

    enum eTR_GroupType
    {
      MultiTS, ///< A group that can contain multiple single program transport streams.
      SingleTS_TS, ///< A group that can contain only one transport stream (no limit on the number of programs).
      SingleTS_Service ///< A group that can contain parts (programs) from multiple transport streams. 
    }; ///< Transrater group type.
       
    enum enTR_Function_t
    { 
      eTR_Function_Normal,    ///< Support MPEG-2 TR and DPI, Pid Sync, Slate insertion, ...
      eTR_Function_AVC_DPI,   ///< Support AVC DPI
      eTR_Function_Reserved1, ///< not supported yet
      eTR_Function_Reserved2, ///< not supported yet
      eTR_Function_Reserved3  ///< not supported yet
    };

    enum eTR_Algorithm
    {
      eTR_Performance, ///< Use a faster algorithm but with lesser quality
      eTR_Quality, ///< Use a slower algorithm but with better quality (less streams)
      eTR_ExtendedGop ///< Specific quality algorithm for removing breathing effects in streams with long GOPs
    };

    /**
     * 
     * @deprecated This enum should not be used anymore since R5.01. The enum is replaced by the structure TR_DelayMode_t.
     */
    enum eTR_Delay {
      eTR_NormalDelay, ///< Normal delay of 1.4 seconds
      eTR_HighDelay   ///< Higher delay of 1.8 seconds, results in more accurate splices
    };

    enum eTR_CoarseDelay{
      eTR_NormalCoarseDelay, ///< Normal delay of 1.4 seconds
      eTR_HighCoarseDelay,   ///< Higher delay of 1.8 seconds, results in more accurate splices
      eTR_PredefinedDelay,   ///< Predefined delay based on the frame rate, input board and finer delay setting of the streams, needed for statmux application (sync delay of MPEG2 & AVC encoders)
      eTR_CustomDelay,	     ///< Customized delay, the user can define the total delay of the transrater board together with a specific delay of the output buffer (without preanalysis)
      eTR_LowDelay           ///< Low delay configuration of the transrater board application (total delay of 440ms of which 140ms are used for preanalysis)
    };

    enum eTR_CoarseDelay_V2{
      eTR_NormalCoarseDelay_V2,///< Normal delay of 1.4 seconds
      eTR_HighCoarseDelay_V2,  ///< Higher delay of 1.8 seconds, results in more accurate splices
      eTR_PredefinedDelay_V2,  ///< Predefined delay based on the frame rate, input board and finer 
                               ///  delay setting of the streams, needed for statmux application 
                               ///  (sync delay of MPEG2 & AVC encoders)
      eTR_CustomDelay_V2,      ///< Customized delay, the user can define the total delay of the
                               ///  transrater board together with a specific delay of the output buffer
                               ///  (without preanalysis)
      eTR_LowDelay_V2,         ///< Low delay configuration of the transrater board application (total
                               ///  delay of 440ms of which 140ms are used for preanalysis).
      eTR_TS_Delay_V2          ///< TS delay mode in which the user can specify a custom delay but the
                               ///  co-processor cannot be used for anything else than pure delay.
    };

    enum eTR_FrameRateDelay {
      eTR_25Hz,        ///< Delay for a frame rate of 25 Hz
      eTR_30Hz         ///< Delay for a frame rate of 30 Hz
    };

    enum eTR_BoardTypeDelay {
      eTR_ASI,         ///< Delay for an input stream on an ASI board     
      eTR_GbE          ///< Delay for an input stream on an GbE board     
    };

    enum eTR_FineDelay {
      eTR_LowFineDelay,       ///< Finer predefined delay setting: low delay
      eTR_NormalFineDelay,    ///< Finer predefined delay setting: normal delay
      eTR_HighFineDelay       ///< Finer predefined delay setting: high delay
    };

    struct TR_DelayMode_t
    {
      eTR_CoarseDelay         CoarseDelay;        ///< Coarse setting of the delay of the transrater board. Based on this value, the other values of the structure has to be interpreted
      eTR_FrameRateDelay      FrameRateDelay;     ///< One of the possible predefined frame rate delay settings
      eTR_BoardTypeDelay      BoardTypeDelay;     ///< One of the possible predefined board delay settings of the input stream
      eTR_FineDelay           FineDelay;          ///< One of the possible predefined finer delay settings
      unsigned long           TotalDelay;         ///< Customized setting of the total delay of the transrater board
      unsigned long           OutputDelay;        ///< Customized setting of the delay reserved for the output buffer embedded in the transrater board (modifying this setting can result in worst video quality)
    }; 

    struct TR_DelayMode_V2_t
    {
      eTR_CoarseDelay_V2      CoarseDelay;        ///< Coarse setting of the delay of the transrater board. Based on this value, the other values of the structure has to be interpreted
      eTR_FrameRateDelay      FrameRateDelay;     ///< One of the possible predefined frame rate delay settings
      eTR_BoardTypeDelay      BoardTypeDelay;     ///< One of the possible predefined board delay settings of the input stream
      eTR_FineDelay           FineDelay;          ///< One of the possible predefined finer delay settings
      unsigned long           TotalDelay;         ///< Customized setting of the total delay of the transrater board
      unsigned long           OutputDelay;        ///< Customized setting of the delay reserved for the output buffer embedded in the transrater board (modifying this setting can result in worst video quality)
      unsigned long           TsDelay;            ///< Customized setting of the TS delay (CoarseDelay = eTR_TS_Delay) can be set between 5ms and 100ms
    };

    struct TR_BitrateLimits_t
    {
      unsigned long MinBitrate; ///< Minimum bitrate in bps
      unsigned long MaxBitrate; ///< Maximum bitrate in bps
    }; ///< Min - max bitrate boundaries used for service.

    struct TR_GroupSettings_t
    {
      TR_GroupID_t    GroupID; ///< The group reference, it should be a valid reference. It cannot be changed anymore after creation.
      string          GroupName; ///< The group name, the same name may be used multiple times.
      eTR_GroupType   GroupType; ///< The type of group. It cannot be changed anymore after creation.
      IPS_RefTS_t     TSRef; ///< The output transport stream this group contains (parts of).  It should be set to 0xFFFFFFFF in case of a MultiTS group.
      unsigned long   BitRate; ///< The maximum bitrate that should be applied to the statmux group. This should be lower or equal to the output transport stream bandwidth in case of SingleTS_xxx group types.
    }; ///< Used to create and change transrater staging groups.
    
    typedef sequence<TR_GroupSettings_t> TR_GroupSettings_List_t; ///< A sequence of TR_GroupSettings_t.
    
    struct TR_TSSettings_t
    {
      IPS_RefTS_t TSRef; ///< The output transport stream reference.
      long Status; ///< Status field (for future use).
    }; ///< Represents an output transport stream in a transrater staging context.

    typedef sequence<TR_TSSettings_t> TR_TSSettings_List_t; ///< A sequence of TR_TSSettings_t.

    struct TR_TSAdd_t
    {
      TR_GroupID_t GroupID; ///< The group reference. The group should already exist.
      TR_TSSettings_List_t TSList; ///< A sequence of output transport streams.
    }; ///< Used to couple output transport stream(s) to a transrater group.
    
    typedef sequence<TR_TSAdd_t> TR_TSAdd_List_t; ///< A sequence of TR_TSAdd_t.
    
    struct TR_Service_t
    { 
      IPS_Service_t Service; ///< The output service reference.
      unsigned long PCR_Pid; ///< The PCR PID in the service.
    }; ///< Identifies an output service in a transrater staging context.
    
    struct TR_ServiceSettings_t
    {
      TR_Service_t Service; ///< The service reference.
      eTR_ServiceMode Mode; ///< The transrater mode for the service.
      octet Priority; ///< The transrater priority.
      TR_BitrateLimits_t Bitrates; ///< The bitrates that apply to the service. Only relevant if the service mode is not passthrough.
      boolean BitratesOnVideo; ///< Read only flag that indicates if the bitrate limits apply on the whole service or only on the video part.
      long Status; ///< Status field. For future use.
    }; ///< Transrater specific service settings.
    
    /// A sequence of TR_ServiceSettings_t.
    typedef sequence<TR_ServiceSettings_t> TR_ServiceSettings_List_t;

    struct TR_GroupServiceSettings_t
    {
      TR_GroupID_t GroupID;
      TR_ServiceSettings_List_t ServiceSettingsList;
    };
    
    /// A sequence of TR_GroupServiceSettings_t.
    typedef sequence<TR_GroupServiceSettings_t> TR_GroupServiceSettings_List_t;
    
    /** Set the transrater board function.
     *
     * The transrater board can switch between multiple functions:
     *  - Normal: Supports transrating, DPI, PID Sync, Slate insertion,...
     *  - AVC-DPI: Supports AVC splicing but nothing else.
     *
     * @param[in] RefPhys The slot(board) and port to apply the call on
     * @param[in] enTR_Function the board function
     *
     * @exception OpNotSucceeded is thrown when any of the supplied paramaters is out of range
     * and when no transraterboard is available
     * @exception TimeOut is thrown when it takes too long to handle the call
     * @exception OpNotAllowed is thrown when no transraterboard is available
     *
     * @version Release 8.0
     */    
     void TR_SetBoardFunction(in IPS_Ref_t RefPhys, in enTR_Function_t enTR_Function) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the transrater board function
     *
     * @param[in] RefPhys The slot(board) and port to apply the call on
     * @param[out] enTR_Function The current transrater board function
     *
     * @exception OpNotSucceeded is thrown when no transraterboard is available
     * @exception TimeOut is thrown when it takes too long to handle the call
     * @exception OpNotAllowed is thrown when no transraterboard is available
     *
     * @version Release 8.0
     */    
     void TR_GetBoardFunction(in IPS_Ref_t RefPhys, out enTR_Function_t enTR_Function)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the transrating algorithm
     *
     * @param[in] RefPhys The slot(board) and port to apply the call on
     * @param[in] TR_Algorithm The new board algorithm to apply
     *
     * @exception OpNotSucceeded is thrown when any of the supplied paramaters is out of range
     * and when no transraterboard is available
     * @exception TimeOut is thrown when it takes too long to handle the call
     * @exception OpNotAllowed is thrown when no transraterboard is available
     */    
     void TR_SetBoardAlgorithm(in IPS_Ref_t RefPhys, in eTR_Algorithm TR_Algorithm) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the transrating algorithm
     *
     * @param[in] RefPhys The slot(board) and port to apply the call on
     * @param[out] TR_Algorithm The current board algorithm
     *
     * @exception OpNotSucceeded is thrown when no transraterboard is available
     * @exception TimeOut is thrown when it takes too long to handle the call
     * @exception OpNotAllowed is thrown when no transraterboard is available
     */    
     void TR_GetBoardAlgorithm(in IPS_Ref_t RefPhys, out eTR_Algorithm TR_Algorithm) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the transrating board delay
     *
     * @param[in] RefPhys The slot(board) and port to apply the call on
     * @param[in] TR_Delay
     *
     * @exception OpNotSucceeded is thrown when any of the supplied paramaters is out of range
     * and when no transraterboard is available
     * @exception TimeOut is thrown when it takes too long to handle the call
     * @exception OpNotAllowed is thrown when no transraterboard is available
     * @deprecated This call should not be used anymore since R5.01 (replaced by call TR_SetBoardDelayExtend)
     */    
     void TR_SetBoardDelay(in IPS_Ref_t RefPhys, in eTR_Delay TR_Delay) 
       raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


     /** Get the transrating board delay
      *
      * @param[in] RefPhys The slot(board) and port to apply the call on
      * @param[out] TR_Delay
      *
      * @exception OpNotSucceeded is thrown when no transraterboard is available
      * @exception TimeOut is thrown when it takes too long to handle the call
      * @exception OpNotAllowed is thrown when no transraterboard is available
      * @exception OpNotSupported is thrown when the delay is set with the IDL call TR_SetBoardDelayExtend and Get with this IDL call (this call is depracated since R5.01)
      * @deprecated This call should not be used anymore since R5.01 (replaced by call TR_GetBoardDelayExtend)
      */    
     void TR_GetBoardDelay(in IPS_Ref_t RefPhys, out eTR_Delay TR_Delay) 
       raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

     /** Set the transrating board delay
      *
      * @param[in] RefPhys The slot(board) and port to apply the call on
      * @param[in] TR_Delay
      *
      * @exception OpNotSucceeded is thrown when any of the supplied paramaters is out of range
      * and when no transraterboard is available
      * @exception TimeOut is thrown when it takes too long to handle the call
      * @deprecated This call should not be used anymore since R08.09 (replaced by call TR_GetBoardDelayExtend_V2)
      */    
     void TR_SetBoardDelayExtend(in IPS_Ref_t RefPhys, in TR_DelayMode_t TR_Delay) 
       raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

     /** Set the transrating board delay
      *
      * @param[in] RefPhys The slot(board) and port to apply the call on
      * @param[in] TR_Delay
      *
      * @exception OperationFailed is thrown
      * - when any of the supplied paramaters is out of range
      * - when a feature of the co-processor board is configured on a service or TS
      * @exception TimeOut is thrown when it takes too long to handle the call
      *
      * @version Release 8.9
      */    
     void TR_SetBoardDelayExtend_V2(in IPS_Ref_t RefPhys, in TR_DelayMode_V2_t TR_Delay) 
       raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

     /** Get the transrating board delay
      *
      * @param[in] RefPhys The slot(board) and port to apply the call on
      * @param[out] TR_Delay
      *
      * @exception OpNotSucceeded is thrown when no transraterboard is available
      * @exception TimeOut is thrown when it takes too long to handle the call
      * @deprecated This call should not be used anymore since R08.09 (replaced by call TR_SetBoardDelayExtend_V2)
      */    
     void TR_GetBoardDelayExtend(in IPS_Ref_t RefPhys, out TR_DelayMode_t TR_Delay) 
       raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

     /** Get the transrating board delay
      *
      * @param[in] RefPhys The slot(board) and port to apply the call on
      * @param[out] TR_Delay
      *
      * @exception TimeOut is thrown when it takes too long to handle the call
      *
      * @version Release 8.9
      */    
     void TR_GetBoardDelayExtend_V2(in IPS_Ref_t RefPhys, out TR_DelayMode_V2_t TR_Delay) 
       raises(TimeOut, OpNotAllowed, OpNotSupported);

    /** Request to add a list of new transrater groups.
     * Group IDs are assigned and managed by the IO Board if zero is passed in.
     * Group IDs can be assigned by the caller if non-zero is passed in.  The ID should be in the range [2-501] and not yet taken by another group.
     * The call can fail with an exception (see below).  This does not mean that the whole call failed, correct groups are added and returned in the group ID list.
     *
     * @param[in] RefPhys The slot(board) and port to apply the call on.
     * @param[in] GroupList A sequence of TR_GroupSettings_t objects - ID is ignored
     *
     * @return TR_GroupID_List_t A list of group IDs.
     *
     * @exception OpNotSucceeded Is thrown when a general failure occurs.
     * This can be the case when : 
     * - trying to add a MultiTS group to an ASI board, this is not allowed;
     * - trying to add a group with invalid bitrate setting, bitrate should be higher then 1Mbps and lower then 2Gbps;
     * - trying to add a group with an invalid group type;
     * - trying to add a group with a TS reference for an output TS that is already a complete part of a transrater group
     * (this can be the only part of a SingeTS_TS group or one of many SPTS in a MultiTS group);
     * - trying to add a group with a malformed TS reference (only the port number is checked for validity);
     * - trying to add a SingleTS_TS or SingleTS_Service group with a bitrate lower than the output TS bitrate;
     * - trying to add a group if there are no more group IDs available;
     * - trying to add a group with an ID that has already been taken;
     * @exception TimeOut Is thrown when it takes too long to handle the call.
     */
    TR_GroupID_List_t TR_GroupAddL(in IPS_Ref_t RefPhys, in TR_GroupSettings_List_t GroupList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Gets the list of transrater group IDs. It is possible to get the whole list if an empty list is passed in.
     *
     * @param[in] RefPhys The slot(board) and port to apply the call on.
     * @param[in] GroupIDList A TR_GroupID_List_t list of group IDs. This can be an empty list.
     *
     * @return The sequence of TR_GroupSettings_t objects for the requested list of groups.
     *
     * @exception OpNotSucceeded Is thrown when a general failure occurs. This is currently only so if an invalid group ID is used.
     * @exception TimeOut Is thrown when it takes too long to handle the call.
     */
    TR_GroupSettings_List_t TR_GroupGetL(in IPS_Ref_t RefPhys, in TR_GroupID_List_t GroupIDList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Change the settings of (multiple) transrater group(s).
     *
     * @param[in] RefPhys The slot(board) and port to apply the call on.
     * @param[in] GroupList A sequence of TR_GroupSettings_t objects - ID is ignored.
     *
     * @return TR_GroupID_List_t A list of group IDs.
     *
     * @exception OpNotSucceeded Is thrown when a general failure occurs. 
     * This can be the case when trying to change the group type or the TS reference or if the group does not exist.
     * It is thrown also if you pass in an empty list.
     * @exception TimeOut Is thrown when it takes too long to handle the call.
     */
    TR_GroupID_List_t TR_GroupChangeL(in IPS_Ref_t RefPhys, in TR_GroupSettings_List_t GroupList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Delete transrater group(s).  Deleting a group means what it says : everything in the group is also removed, both from the settings and from the transrater board.
     *
     * @param[in] RefPhys The slot(board) and port to apply the call on.
     * @param[in] GroupList A sequence of group IDs for the groups that have to be deleted.
     *
     * @return TR_GroupID_List_t An (obviously obsolete) list of group IDs.
     *
     * @exception OpNotSucceeded Is thrown when a general failure occurs.  This is the case if (one of the) group ID(s) do(es) not exist.
     * @exception TimeOut Is thrown when it takes too long to handle the call.
     */
    TR_GroupID_List_t TR_GroupDeleteL(in IPS_Ref_t RefPhys, in TR_GroupID_List_t GroupList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Add complete mux output transport stream(s) to transrater group(s).   
     * When a change occurs on the muxed output transport stream this is updated in the group automatically also because of the transport stream - transrater group relation.
     * So there is NO NEED to add newly muxed output services explicitly to the transrater group (type single TS or multi TS) if that group already contains the transport stream.
     * Transport streams as a whole or not put in transrater groups of type selective services. For those types of transrater groups the services should be added manually to a SingleTS_Service group by
     * calling the TS_ServiceAddL call.
     *
     * @param[in] RefPhys The slot(board) and port to apply the call on.
     * @param[in] GroupTSList A sequence of tranrater group - transport stream(s) relations that should be added.
     *
     * @return The sequence of transrater group - transport stream(s) relations that were actually created.
     *
     * @exception OpNotSucceeded Is thrown when a general failure occurs. 
     *
     * This is the case : 
     * - if group ID(s) and/or transport stream ID(s) do not exist;
     * - if the transport stream is already part of a group;
     * - if trying to add more than one TS to a SingleTS_TS group;
     * - if trying to add a TS to a SingleTS_Service group;
     * - if trying to add a MPTS to a MultiTS group;
     * - if not enough licenses are available (the TS will be added but some or all services will be put in passthrough);
     * - if there are not enough internal resources anymore to add the TS to a group;
     * @exception TimeOut Is thrown when it takes too long to handle the call.
     */
    TR_TSAdd_List_t TR_TS_AddL(in IPS_Ref_t RefPhys, in TR_TSAdd_List_t GroupTSList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Gets a list of TSs that are completely part of the transrater group(s). 
     *
     * @param[in] RefPhys The slot(board) and port to apply the call on.
     * @param[in] GroupIDList The sequence of group IDs the transport streams are requested for.
     *
     * @return The sequence of transrater group - transport stream(s) relations. Only the valid groups are returned in the list.
     *
     * @exception OpNotSucceeded Is thrown when a general failure occurs. This is for the moment only the case if (a) group ID(s) do(es) not exist.
     * @exception TimeOut Is thrown when it takes too long to handle the call.
     */
    TR_TSAdd_List_t TR_TS_GetL(in IPS_Ref_t RefPhys, in TR_GroupID_List_t GroupIDList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Delete TS(s) from transrater group(s). This means that every single pid from every TS specified is removed from the transrater group.
     * 
     * @param[in] RefPhys The slot(board) and port to apply the call on.
     * @param[in] GroupTSList The sequence of group ID(s) - transport stream(s) relations that should be deleted.
     *
     * @return The sequence of (just becoming obsolete) group ID(s) = transport stream(s) relations.
     *
     * @exception OpNotSucceeded Is thrown when a general failure occurs. Thrown also if group ID(s) do(es) not exist.
     * @exception TimeOut Is thrown when it takes too long to handle the call.
     */
    TR_TSAdd_List_t TR_TS_DeleteL(in IPS_Ref_t RefPhys, in TR_TSAdd_List_t GroupTSList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

        
    /** Add a sequence of service(s) to transrater group(s).  This will only be allowed for selective services type of groups.
     * 
     * @param[in] RefPhys The slot(board) and port to apply the call on.
     * @param[in] GroupServiceSettingsList The sequence of group ID(s) - service relations that should be added.  The settings also contain transrater specific
     * settings like the minimum and maximum bitrate that should be applied on the service(s).
     *
     * @return The actual sequence of group ID(s) - service relations that were added.
     * 
     * @exception OpNotSucceeded Is thrown when a general failure occurs. 
     * Thrown also 
     * - if group ID(s) and/or service ID(s) do(es) not exist, 
     * - if the transrater group is not of the correct type, 
     * - if the service is already part of the group or 
     * - if out of licenses.
     * In case there are not enough licenses available, the service(s) will be added anyway and set in passthrough mode.
     * @exception TimeOut Is thrown when it takes too long to handle the call.
     */
    TR_GroupServiceSettings_List_t TR_ServiceAddL(in IPS_Ref_t RefPhys, in TR_GroupServiceSettings_List_t GroupServiceSettingsList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);

    /** Gets a sequence of service(s) that are added to transrater group(s).  This will only be relevant for selective services type of groups.
     * 
     * @param[in] RefPhys The slot(board) and port to apply the call on.
     * @param[in] GroupIDList The sequence of transrater groups to request the services for.
     *
     * @return GroupServiceSettingsList The sequence of group ID(s) - service relations.
     * 
     * @exception OpNotSucceeded Is thrown when a general failure occurs. 
     * Thrown also if group ID(s) do(es) not exist.
     * @exception TimeOut Is thrown when it takes too long to handle the call.
     */
    TR_GroupServiceSettings_List_t TR_ServiceGetL(in IPS_Ref_t RefPhys, in TR_GroupID_List_t GroupIDList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
     
    /** Change a sequence of service setting(s) that were previously added to transrater group(s).  
     * This will only be allowed for selective services type of groups, i.e. services that were added explicitly.
     * 
     * @param[in] RefPhys The slot(board) and port to apply the call on.
     * @param[in] GroupServiceSettingsList The sequence of group ID(s) - service relations that should be changed.  The settings contain transrater specific
     * settings like the minimum and maximum bitrate that should be applied on the service(s).
     *
     * @return The actual sequence of group ID(s) - service relations that were changed.
     * 
     * @exception OpNotSucceeded Is thrown when a general failure occurs. 
     * Thrown also if group ID(s) and/or service ID(s) do(es) not exist or if the transrater group is not of the correct type.
     * @exception LicenseError Is throw if there are insufficient licenses.
     * @exception TimeOut Is thrown when it takes too long to handle the call.
     */
    TR_GroupServiceSettings_List_t TR_ServiceChangeL(in IPS_Ref_t RefPhys, in TR_GroupServiceSettings_List_t GroupServiceSettingsList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);
     
    /** Delete a sequence of service setting(s) that were previously added to transrater group(s).  
     * This will only be allowed for selective services type of groups, i.e. services that were added explicitly.
     * 
     * @param[in] RefPhys The slot(board) and port to apply the call on.
     * @param[in] GroupServiceSettingsList The sequence of group ID(s) - service relations that should be deleted.  
     *
     * @return The actual sequence of group ID(s) - service relations that were deleted and are now become obsolete.
     * 
     * @exception OpNotSucceeded Is thrown when a general failure occurs. 
     * Thrown also if group ID(s) and/or service ID(s) do(es) not exist, if the transrater group is not of the correct type, if a service is not part of the group or if there are not enough licenses anymore.
     * In case there are not enough licenses, the action is done anyway but the service will be set in passthrough mode.
     * @exception TimeOut Is thrown when it takes too long to handle the call.
     * 
     */
    TR_GroupServiceSettings_List_t TR_ServiceDeleteL(in IPS_Ref_t RefPhys, in TR_GroupServiceSettings_List_t GroupServiceSettingsList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Get the bitrate information of transrater groups.
     * @param[in] PhysRef Specifies BoardNr, PortNr to get the bitrates of.
     * @param[in] GroupIDList Specifies to which the group the PIDs belong.
     * 
     * @return TR_BitRateMeasurementList_t Requested output Transrater group bitrate information.
     * 
     * @exception OpNotSupported When BoardNr = 0 = Main Board.
     * @exception OpNotSucceeded In case invalid references (PhysRef, GroupID) are used.
     * 
     * @note This belongs to the bitrate group as well but TR_GroupID_List_t is not defined there.
     */
    TR_BitRateMeasurementList_t MM_GetTR_BitRate(in IPS_Ref_t PhysRef, in TR_GroupID_List_t GroupIDList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

     /** Get the PCR continuity setting.
      *
      * @param[in]  RefPhys The slot(board) and port to apply the call on
      * @param[out] PcrContinuity
      *
      * @exception OpNotSucceeded is thrown when no transraterboard is available
      * @exception TimeOut is thrown when it takes too long to handle the call
      * @exception OpNotSupported When BoardNr = 0 = Main Board
      */    
     void TR_GetBoardPcrContinuity(in IPS_Ref_t RefPhys, out boolean PcrContinuity) 
       raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the PCR continuity setting.
     *
     * @param[in] RefPhys The slot(board) and port to apply the call on
     * @param[in] PcrContinuity
     *
     * @exception OpNotSucceeded is thrown when no transraterboard is available
     * @exception TimeOut is thrown when it takes too long to handle the call
     * @exception OpNotSupported When BoardNr = 0 = Main Board
     */    
    void TR_SetBoardPcrContinuity(in IPS_Ref_t RefPhys, in boolean PcrContinuity) 
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);        
       
       
    enum enTR_SpliceWindowAccuracy {
      eTR_SpliceWindowAccuracy_BestEffort,
      eTR_SpliceWindowAccuracy_Scte30,
      eTR_SpliceWindowAccuracy_Reserved1,
      eTR_SpliceWindowAccuracy_Reserved2,
      eTR_SpliceWindowAccuracy_Reserved3,
      eTR_SpliceWindowAccuracy_Reserved4,
      eTR_SpliceWindowAccuracy_Reserved5
    }; 

    /** Get the splice window accuracy setting.
     *
     * @param[in]  RefPhys The slot(board) and port to apply the call on
     * @param[out] Accuracy
     *
     * @exception OpNotSucceeded is thrown when no transrater board is available
     * @exception TimeOut is thrown when it takes too long to handle the call
     * @exception OpNotSupported When BoardNr = 0 = Main Board
     *
     * @version   Supported since Release 8.5 
     */    
    void TR_GetSpliceWindowAccuracy(in IPS_Ref_t RefPhys, out enTR_SpliceWindowAccuracy Accuracy)
       raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the splice window accuracy setting.
     *
     * @param[in] RefPhys The slot(board) and port to apply the call on
     * @param[in] Accuracy
     *
     * @exception OpNotSucceeded is thrown when no transrater board is available
     * @exception TimeOut is thrown when it takes too long to handle the call
     * @exception OpNotSupported When BoardNr = 0 = Main Board
     *
     * @version   Supported since Release 8.5
     */    
    void TR_SetSpliceWindowAccuracy(in IPS_Ref_t RefPhys, in enTR_SpliceWindowAccuracy Accuracy) 
          raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);    

    /** Defines the closed caption update mode for SCTE20-SCTE21 conversion.
     * @version Release 8.2
     */
    enum eTRB_CC_UpdateMode {
      eTRB_CC_UpdateMode_Off,        ///< (default) No update == behaviour pre-Release 8.2
      eTRB_CC_UpdateMode_Scte20_21,  ///< Output always contains SCTE20 *and* SCTE21 user data (in that order).
      eTRB_CC_UpdateMode_Reserved1,  ///< reserved for future use.
      eTRB_CC_UpdateMode_Reserved2,  ///< reserved for future use.
      eTRB_CC_UpdateMode_Reserved3,  ///< reserved for future use.
      eTRB_CC_UpdateMode_Reserved4,  ///< reserved for future use.
      eTRB_CC_UpdateMode_Reserved5,  ///< reserved for future use.
      eTRB_CC_UpdateMode_Reserved6,  ///< reserved for future use.
      eTRB_CC_UpdateMode_Reserved7,  ///< reserved for future use.
      eTRB_CC_UpdateMode_Reserved8   ///< reserved for future use.
    };

    /** Transrater specific service settings V2.
     * @version Release 8.2
     */
    struct TR_ServiceSettings_V2_t
    {
      TR_Service_t       Service; ///< The service reference.
      eTR_ServiceMode    Mode; ///< The transrater mode for the service.
      octet              Priority; ///< The transrater priority.
      TR_BitrateLimits_t Bitrates; ///< The bitrates that apply to the service. Only relevant 
                                   ///  if the service mode is not passthrough.
      boolean            BitratesOnVideo; ///< Read only flag that indicates if the bitrate limits  
                                          ///  apply on the whole service or only on the video part.
      long               Status; ///< Status field. For future use.
      eTRB_CC_UpdateMode eUpdateMode; ///< Closed caption update mode.
    }; 

    /// A sequence of TR_ServiceSettings_V2_t.
    typedef sequence<TR_ServiceSettings_V2_t> TR_ServiceSettings_V2_List_t;

    struct TR_GroupServiceSettings_V2_t
    {
      TR_GroupID_t GroupID;
      TR_ServiceSettings_V2_List_t ServiceSettingsList;
    };

    /// A sequence of TR_GroupServiceSettings_V2_t.
    typedef sequence<TR_GroupServiceSettings_V2_t> TR_GroupServiceSettings_V2_List_t;

    /** Add a sequence of service(s) to transrater group(s).  This will only be allowed for 
     *  selective services type of groups.
     * 
     * @param[in] RefPhys                   The slot(board) and port to apply the call on.
     * @param[in] GroupServiceSettingsList  The sequence of group ID(s) - service relations that 
     *                                      should be added.  The settings also contain transrater 
     *                                      specific settings like the minimum and maximum bitrate 
     *                                      that should be applied on the service(s).
     *
     * @return The actual sequence of group ID(s) - service relations that were added.
     * 
     * @exception OpNotSucceeded - when a general failure occurs. 
     *                           - if group ID(s) and/or service ID(s) do(es) not exist, 
     *                           - if the transrater group is not of the correct type, 
     *                           - if the service is already part of the group or 
     *                           - if out of licenses. In case there are not enough licenses available,
     *                             the service(s) will be added anyway and set in passthrough mode.
     * @exception TimeOut Is thrown when it takes too long to handle the call.
     * 
     * @version Release 8.2
     */
    TR_GroupServiceSettings_V2_List_t TR_ServiceAddL_V2(
                        in IPS_Ref_t RefPhys, 
                        in TR_GroupServiceSettings_V2_List_t GroupServiceSettingsList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);

    /** Gets a sequence of service(s) that are added to transrater group(s).  
     * This will only be relevant for selective services type of groups.
     * 
     * @param[in] RefPhys The slot(board) and port to apply the call on.
     * @param[in] GroupIDList The sequence of transrater groups to request the services for.
     *
     * @return GroupServiceSettingsList The sequence of group ID(s) - service relations.
     * 
     * @exception OpNotSucceeded Is thrown when a general failure occurs. 
     *                           Thrown also if group ID(s) do(es) not exist.
     * @exception TimeOut        Is thrown when it takes too long to handle the call.
     *
     * @version Release 8.2
     */
    TR_GroupServiceSettings_V2_List_t TR_ServiceGetL_V2(in IPS_Ref_t RefPhys, 
                                                        in TR_GroupID_List_t GroupIDList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported); 

    /** Change a sequence of service setting(s) that were previously added to transrater group(s).  
     * This will only be allowed for selective services type of groups, i.e. services that were added
     * explicitly.
     * 
     * @param[in] RefPhys                  The slot(board) and port to apply the call on.
     * @param[in] GroupServiceSettingsList The sequence of group ID(s) - service relations that should 
     *                                     be changed.  The settings contain transrater specific
     *                                     settings like the minimum and maximum bitrate that should be
     *                                     applied on the service(s).
     *
     * @return The actual sequence of group ID(s) - service relations that were changed.
     * 
     * @exception OpNotSucceeded Is thrown when a general failure occurs. 
     *                           Thrown also if group ID(s) and/or service ID(s) do(es) not exist or if
     *                           the transrater group is not of the correct type.
     * @exception LicenseError   Is throw if there are insufficient licenses.
     * @exception TimeOut        Is thrown when it takes too long to handle the call.
     *
     * @version Release 8.2
     */
    TR_GroupServiceSettings_V2_List_t TR_ServiceChangeL_V2(
                            in IPS_Ref_t RefPhys, 
                            in TR_GroupServiceSettings_V2_List_t GroupServiceSettingsList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);
        
    /** Delete a sequence of service setting(s) that were previously added to transrater group(s).  
     * This will only be allowed for selective services type of groups, i.e. services that were 
     * added explicitly.
     * 
     * @param[in] RefPhys                   The slot(board) and port to apply the call on.
     * @param[in] GroupServiceSettingsList  The sequence of group ID(s) - service relations that 
     *                                      should be deleted.  
     *
     * @return The actual sequence of group ID(s) - service relations that were deleted and are 
     *         now become obsolete.
     * 
     * @exception OpNotSucceeded  - When a general failure occurs. 
     *                            - if group ID(s) and/or service ID(s) do(es) not exist, 
     *                            - if the transrater group is not of the correct type, 
     *                            - if a service is not part of the group or 
     *                            - if there are not enough licenses anymore. In case there are not 
     *                              enough licenses, the action is done anyway but the service will 
     *                              be set in passthrough mode.
     * @exception TimeOut Is thrown when it takes too long to handle the call.
     * 
     * @version Release 8.2
     */
    TR_GroupServiceSettings_V2_List_t TR_ServiceDeleteL_V2(
                            in IPS_Ref_t RefPhys, 
                            in TR_GroupServiceSettings_V2_List_t GroupServiceSettingsList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** The transrater board will be restarted. All services that are processed by the transrater,
    * including spliced services, will be interrupted during the reset of the board.
    *
    * @param[in] BoardNr          The board to apply the call on.
    *
    * @exception OpNotSucceeded   - When a general failure occurs.
    *                             - When there is no transrater board on the specified location
    *
    * @exception TimeOut Is thrown when it takes too long to handle the call.
    *
    * @version Release 10.10
    */
    void TR_RestartBoard(in unsigned short BoardNr)
        raises(TimeOut, OpNotSucceeded);
        
    /// @} end of transrater    

    // REALIGNMENT MUXING
    /////////////////////////////////////////////////////////////////////////////////////// 

    /** @defgroup RMX Re-alignment Mux Staging
     * This contains specific types, enums and methods for controlling the Re-alignment
     * Mux Staging (performed on the co-processor board known as Transrater Board)
     * @{
     */



    /** Realignment Mux group ID.
     */
    typedef unsigned long RMX_GroupID_t;

    /** A list of Realignment Mux group IDs.
     */
    typedef sequence<RMX_GroupID_t> RMX_GroupID_List_t;



    /** Realignment group type.
     * Behaviour depends on the type of the Realignment Mux group.  Currently only
     * selected services of a single TS is supported.
     */
    enum eRMX_GroupType_t
    {
        eRMX_SingleTS_SelectedSvc,
        eRMX_GT_Reserved_1,        /// e.g. eRMX_SingleTS_AllSvc
        eRMX_GT_Reserved_2,        /// e.g. eRMX_MultiTS

        // for future use.
        eRMX_GT_Reserved_3,
        eRMX_GT_Reserved_4,
        eRMX_GT_Reserved_5,
        eRMX_GT_Reserved_6,
        eRMX_GT_Reserved_7,
        eRMX_GT_Reserved_8
    };

    /** Realignment Mux group settings.
     */
    struct RMX_GroupSettings_t
    {
      RMX_GroupID_t      GroupID;  ///< ID of the group: read-only, ignored during creation.
      string                Name;  ///< Name: writable, the same name may be used multiple times,
                                   ///  it exists only for user ref.
                                   ///  Not used internally by the DCM.
                                   ///  Name length limited to 32 characters.
      eRMX_GroupType_t      Type;  ///< Type of group: write-once on creation, read-only after creation.
      IPS_RefTS_t       Location;  ///< Location of group (depends on Type: can be TS or Port only):
                                   ///  write-once on creation, read-only after creation.
                                   ///  REQUIREMENT: Should be a port for group type MultiTS 
                                   ///               and be a TS for the other group types.
      unsigned long EndToEndDelay; ///< The actual end-to-end delay that the remote statmux service
                                   ///  using realignment muxing will have.
                                   ///  This is the maximal network delay that can be compensated for
                                   ///  between any of the encoders of the realignment group and
                                   ///  the remux device across the network.
                                   ///  In milliseconds.  Range: from 150ms to 1000ms.
    }; 

    /** A list of Realignment Mux group settings.
     */
    typedef sequence<RMX_GroupSettings_t> RMX_GroupSettings_List_t;



    /** Realignment Mux service status.
     *
     * Passed_Delayed:
     *   Realignment mux delay mode is being applied on the service.
     *
     * Blocked_NoMarkers:
     *   The service is blocked on the realignment mux because
     *   no s-tick markers are present.
     *
     * Blocked_NegativeDelay:
     *   The service is blocked on the realignment mux because
     *   the delay for the service is higher than the configured end-to-end delay.
     *
     * NotPresent:
     *   No realignment mux is not applied on the service because
     *   the service is not present at the output.
     *
     * Passed_Undelayed:
     *   Realignment mux is not applied on the service because
     *   delay mode has been disabled or temporarily not working.
     */
    enum eRMX_ServiceStatus_t
    {
        eRMX_SvcStatus_Passed_Delayed,               ///< OK.
        eRMX_ScvStatus_Blocked_NoMarkers,            ///< NOK: S-tick markers are missing.
        eRMX_SvcStatus_Blocked_NegativeDelay,        ///< NOK: The delay exceeds the configured end-to-end delay.
                                                     ///       The applied delay is negative due to the
                                                     ///       actual delay that is too high.
        eRMX_SvcStatus_NotPresent,                   ///< NOK: No service present at output.
        eRMX_SvcStatus_Passed_Undelayed,             ///< NOK: Delay mode is disabled or not working.
        eRMX_SvcStatus_Passed_Delayed_NoMarkers,     ///< Still OK, but warning. Shifts after 5 secs to blocked.
        eRMX_SvcStatus_Passed_Delayed_InvalidTime,   ///< Still OK, but warning. Shifts after 60 secs to blocked.
        eRMX_SvcStatus_Blocked_InvalidTime,          ///< NOK: invalid time being received from the encoder 
                                                     ///       for more than 60 secs.
        eRMX_SvcStatus_Blocked_IncompatibleRealignmentInfo, ///< Transitory phenomenon:
                                                     ///         recovery of encoder from error state (<1sec).
        eRMX_SvcStatus_Blocked_DejitterBufferReset,  ///< Transitory phenomenon: network jitter triggered
                                                     ///  a reset of the dejitter buffer.
        eRMX_SvsStatus_Blocked_DtsStcCompOutOfLimits,///< Transitory phenomenon:
                                                     ///  DTS-STC compensation out-of-limits.
                                                     

        // for future use.
        eRMX_SvcStatus_Reserved1,             ///< Eg. Blocked_InvalidClock (to be decided)
        eRMX_SvcStatus_Reserved2,
        eRMX_SvcStatus_Reserved3,
        eRMX_SvcStatus_Reserved4,
        eRMX_SvcStatus_Reserved5,
        eRMX_SvcStatus_Reserved6
    };

    /** A service that is part of a Realignment Mux group.
     */
    struct RMX_GroupSvc_t
    {
        IPS_Service_t        SvcRef;          ///< The reference of the service.
        eRMX_ServiceStatus_t SvcStatus;       ///< The status of the RMX'ed service.
                                              ///< Read-only.  Filled in when service is retrieved.
        long                 SvcAppliedDelay; ///< The applied delay of the RMX'ed service in millisecs.
                                              ///  Read-only.  Filled in when service is retrieved.
                                              ///  To be ignored if service has status Blocked_NoMarkers.
                                              ///  Takes on a negative value if the service has status
                                              ///  Blocked_NegativeDelay, and a non-negative one if 
                                              ///  service has status Passed_Delayed.
                                              ///  The magnitude of negative Applied Delay indicates
                                              ///  how much the end-to-end delay should be increased.
    };

    /* A list of services that are part of a Realignment Mux group.
     */
    typedef sequence<RMX_GroupSvc_t> RMX_GroupSvc_List_t;

    /** A set of services belonging to the same Realignment Mux group.
     */
    struct RMX_GroupSvcs_t
    {
      RMX_GroupID_t       GroupID; ///< The group reference.  The group should already exist. 
      RMX_GroupSvc_List_t SvcList; ///< sequence of services
    };

    /** A list where each node is a set of Realignment Mux services belonging to the same group.
     */
    typedef sequence<RMX_GroupSvcs_t> RMX_GroupSvcs_List_t;



    /** Enable/disable Realignment Mode on a specific board.
     *
     * @param[in] BoardNr  The slot (board) to enable/disable realignment mode on.
     * @param[in] Enable   Enable realignment mode if true, disable otherwise.
     * 
     * @exception Timeout          Is thrown when it takes too long to handle the call.
     * @exception OperationFailed  Is thrown when:
     *  - supplying an invalid board nr;
     *  - trying to enable realignment mode while another feature requiring the
     *    co-processor is active on at least one service of the board;
     *  - trying to disable realignment mode while there are still realignment mux
     *    groups configured on the IO-board;
     *
     * @version  Release 11.0
     */
    void RMX_SetRealignmentBoardMode(in unsigned short BoardNr, in boolean Enable)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Query the Realignment Mode of a specific board.
     *
     * @param[in]  BoardNr    The slot (board) to query whether realignment mode is enabled.
     * @param[out] IsEnabled  True indicates it is enabled, false otherwise.
     * 
     * @exception Timeout          Is thrown when it takes too long to handle the call.
     * @exception OperationFailed  Is thrown when:
     *  - supplying an invalid board nr;
     *
     * @version  Release 11.0
     */
    void RMX_GetRealignmentBoardMode(in unsigned short BoardNr, out boolean IsEnabled)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);



    /** Create a set of Realignment Mux groups.
     *
     * @remarks  Group IDs are assigned and managed by the IO board.  After this
     *           assignment they are considered read-only.  Group IDs that had
     *           initially been set by the caller were ignored.
     *
     * @param[in]  BoardNr            The slot (board) to apply the call on.
     * @param[in]  GroupSettingsList  A list of RMX group settings. (ID is ignored)
     * @param[out] CreatedGroupIDs    The group IDs of the groups that were created.
     *                                The IDs are returned in the same order as how
     *                                the group settings were supplied.
     *
     * @exception Timeout          Is thrown when it takes too long to handle the call.
     * @exception OperationFailed  Is thrown when:
     *  - making call while realignment board mode is not enabled;
     *  - supplying an invalid or non-existing board nbr;
     *  - supplying an empty list of group settings;
     *  - trying to create a group when there are no more groups available (out of
     *    resources);
     *  - supplying a group name that is too short or too long;
     *  - supplying an invalid group type;
     *  - supplying an unsupported group type (currently no single-ts-all-services
     *    nor multi-ts are supported; due to this some other exceptional cases
     *    could not yet occur);
     *  - supplying a multi-ts group type if the board nbr refers to an ASI board (by
     *    definition ASI has only one TS available!)  [NOT YET APPLICABLE];
     *  - supplying a location that gives a conflict with the board nr parameter;
     *  - supplying a location that is invalid (ie port nbr should not be missing and
     *    neither should the TS index in case of single-ts-selected-services);
     *  - supplying a TS reference that is not an existing output TS reference;
     *  - supplying a TS reference for an output TS that is already completely part
     *    of another RMX group. (as the only member of a single-ts-all-services if it
     *    is an MPTS, or as one of the members of a multi-ts if it is an SPTS)
     *    [NOT YET APPLICABLE];
     *  - supplying an end-to-end delay that is out of range;
     *                             
     * @version  Release 11.0
     */
    void RMX_GroupCreate(in  unsigned short BoardNr, 
                         in  RMX_GroupSettings_List_t GroupSettingsList, 
                         out RMX_GroupID_List_t CreatedGroupIDs) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Get a list of Realignment Mux group settings.
     *
     * @remarks  Both the IPS_RefTS_t and RMX_GroupID_List_t are used as filter.
     *           A) If the RMX_GroupID_List_t is empty, then the IPS_RefTS_t is 
     *              used as filter when retrieving the RMX group settings:
     *              - if only the board is set (ie port is REF_ALL):
     *                all RMX groups of the board are returned;
     *              - if only the board and port are set:
     *                all RMX groups located on the port are returned;
     *              - if board, port and TS are set:
     *                all RMX groups located on the TS are returned.
     *           B) If the RMX_GroupID_List_t is non-empty, the group IDs are
     *              used to check against the IPS_RefTS_t and retrieve the groups.
     *               
     * @param[in]  Location     The board, port and/or TS to retrieve the groups from.
     * @param[in]  GroupIDList  The group IDs of the groups to be retrieved.
     * @param[out] GroupSettingsList
     *                          The group settings corresponding to the group IDs
     *                          that were supplied. The settings are returned in the
     *                          order as how the group IDs were supplied.
     *
     * @exception Timeout          Is thrown when it takes too long to handle the call.
     * @exception OperationFailed  Is thrown when:
     *  - making call while realignment board mode is not enabled;
     *  - supplying an invalid or non-existing board nbr;
     *  - supplying a non-existing group ID;
     *  - supplying an inconsistent port/TS reference (ie if the port number is invalid,
     *    the TS index also should);
     *  - supplying a TS reference (ie IPS_RefTS_t) referring to a non-existing location;
     *  - supplying a TS reference with a valid TS index that does not refer to an *output* TS;
     *  - supplying an inconsistent port/TS reference and group ID (ie the location
     *    of the group does not fit with one of the supplied group IDs);
     *
     * @version  Release 11.0
     */
    void RMX_GroupGet(in  IPS_RefTS_t Location,
                      in  RMX_GroupID_List_t GroupIDList,
                      out RMX_GroupSettings_List_t GroupSettingsList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Change the settings of one or more Realignment Mux groups
     *
     * @param[in] BoardNr    The slot (board) to apply the call on.
     * @param[in] GroupList  The list of new RMX group settings.  The group IDs are
     *                       used as references.
     *
     * @exception Timeout          Is thrown when it takes too long to handle the call.
     * @exception OperationFailed  Is thrown when:
     *  - making call while realignment board mode is not enabled;
     *  - supplying an invalid or non-existing board nbr;
     *  - supplying an empty list of group settings;
     *  - supplying a non-existing group ID;
     *  - supplying a group name that is too long.
     *  - supplying a different group type than the one used when creating the group;
     *  - supplying a different location than the one used when creating the group;
     *  - supplying an end-to-end delay that is out of range;
     *
     * @version  Release 11.0
     */
    void RMX_GroupChange(in unsigned short BoardNr,
                         in RMX_GroupSettings_List_t GroupList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Delete one or more Realignment Mux groups.
     * 
     * @remarks  Not only the group itself, but also each member of the group will be
     *           deleted.
     *
     * @param[in] BoardNr      The slot (board) to apply the call on.
     * @param[in] GroupIDList  The group IDs of the groups to be retrieved.
     *
     * @exception Timeout          Is thrown when it takes too long to handle the call.
     * @exception OperationFailed  Is thrown when:
     *  - making call while realignment board mode is not enabled;
     *  - supplying an invalid or non-existing board nbr;
     *  - supplying an empty list of group IDs;
     *  - supplying a list of groups IDs where some of the IDs do not exist;
     *
     * @version  Release 11.0
     */
    void RMX_GroupDelete(in unsigned short BoardNr,
                         in RMX_GroupID_List_t GroupIDList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);



    /** Add services to a Realignment Mux group.
     *
     * @remarks  This is only allowed for groups of type SingleTS_SelectedSvc
     *
     * @param[in] BoardNr            The slot (board) to apply the call on.
     * @param[in] GroupServicesList  A list of sets of service references where each set
     *                               contains all services to be added to the same group.
     *
     * @exception Timeout          Is thrown when it takes too long to handle the call.
     * @exception OpNotSucceeded   Is thrown when:
     *  - supplying an invalid or non-existing board nbr;
     * @exception OperationFailed  Is thrown when:
     *  - making call while realignment board mode is not enabled;
     *  - supplying an empty list of service sets;
     *  - supplying a list that tries to add services to a non-existing group;
     *  - supplying a list that tries to add services to a group of the wrong type (ie
     *    services can only be added to groups of type single-ts-selected-services);
     *  - supplying a list that contains references to non-existing services;
     *  - supplying a list that tries to add a service to a group when it is already
     *    part of another group;
     *  - supplying a list that tries to add a service to the group where it already
     *    belongs to;
     *  - supplying a list where the MPTS of the services does not match the Location (MPTS)
     *    of the group where the services are to be added to;
     *  - trying to add services such that the upper limit on the number of services is
     *    exceeded;
     *
     * @version  Release 11.0
     */
    void RMX_ServiceAdd(in unsigned short BoardNr,
                        in RMX_GroupSvcs_List_t GroupServicesList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Get a list of services that were added explicitly.
     * 
     * @remarks  This is only allowed for groups of type SingleTS_SelectedSvc
     *
     * @param[in]  BoardNr            The slot (board) to apply the call on.
     * @param[in]  GroupIDList        The group IDs of the groups of which the service
     *                                references are to be retrieved.
     * @param[out] GroupServicesList  A list of sets of service references where each
     *                                set consists of the references that belong to a
     *                                certain group.  The sets are returned in the order
     *                                as how the group IDs were supplied.
     *
     * @exception Timeout          Is thrown when it takes too long to handle the call.
     * @exception OperationFailed  Is thrown when:
     *  - making call while realignment board mode is not enabled;
     *  - supplying an invalid or non-existing board nbr;
     *  - supplying an empty list of group IDs;
     *  - supplying a list of group IDs where some of the IDs do not exist;
     *  - supplying a list of group IDs where some of the IDs are of the wrong type (ie
     *    services can only be retrieved from groups of type single-ts-selected-services)
     *
     * @version  Release 11.0
     */
    void RMX_ServiceGet(in  unsigned short BoardNr,
                        in  RMX_GroupID_List_t GroupIDList,
                        out RMX_GroupSvcs_List_t GroupServicesList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Delete a subset of the services that were previously added explicitly to
     * one or more Realignment Mux groups.
     *
     * @remarks  This is only allowed for groups of type SingleTS_SelectedSvc
     *
     * @param[in] BoardNr            The slot (board) to apply the call on.
     * @param[in] GroupServicesList  The list of service references 
     *
     * @exception Timeout          Is thrown when it takes too long to handle the call.
     * @exception OperationFailed  Is thrown when:
     *  - making call while realignment board mode is not enabled;
     *  - supplying an invalid or non-existing board nbr;
     *  - supplying an empty list of service references;
     *  - supplying a list of service references where some of the references do no exist
     *  - supplying a list of service references where some of the references are not
     *    part of a realignment mux group
     *  - supplying a list of service references where some of the references were
     *    not previously added explicitly to the group (and not yet deleted from the group)
     *
     * @version  Release 11.0
     */
    void RMX_ServiceDelete(in unsigned short BoardNr,
                           in RMX_GroupSvcs_List_t GroupServicesList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /// @} end of RMX

// MFP STATMUX STAGING 
/////////////////////////////////////////////////////////////////////////////////////// 


/** @defgroup SMX MFP Statmux staging
 * This contains specific types, enums and methods for controlling the MFP Statmuxing.
 *
 *  @remark This follows pretty close the transrater statmux group management. 
 *  The SMX_MFP prefix is used in all related calls.
 *
 * @{
 */


/** Statmux group type.
 * Depending on the type of the statmux group, behavior will be different;
 * - MultiTS : such a SMXGroup will be located at output port level. Thus 
 *             of SMX_MFP_GroupSettings_t.Location.Ref will be 0xFFFFFFF (only PhysRef
 *             of the Location will be used).
 *             In such group multiple TS can be added as long these output TS are
 *             located at the same port  (aka their IPS_Ref_t is the same as the 
 *             IPS_Ref_t in the SMX_MFP_GroupSettings_t.Location).
 * - SingleTS_AllSvc : such a group will be located at TS level. Thus the 
 *             SMX_MFP_GroupSettings_t.Location will be a TS.
 *             In such group all services of the TS are automatically member
 *             of the statmux group.
 * - SingleTS_SelectedSvc :  such a group will be located at TS level. Thus the 
 *             SMX_MFP_GroupSettings_t.Location will be a TS.
 *             In such group services of the TS are NOT automatically member
 *             of the statmux group, so they have to be added manually.
 */
enum eSMX_MFP_GroupType_t
{
  eSMX_MFP_MultiTS,              ///< SMX group that can contain multiple TS from a Port.
  eSMX_MFP_SingleTS_AllSvc,      ///< SMX group that can contain only one TS, for which all Services are statmuxed.
  eSMX_MFP_SingleTS_SelectedSvc, ///< SMX group that can contain selective services from one TS. 

  // for future use.
  eSMX_MFP_GT_Reserved_3,
  eSMX_MFP_GT_Reserved_4,
  eSMX_MFP_GT_Reserved_5,
  eSMX_MFP_GT_Reserved_6,
  eSMX_MFP_GT_Reserved_7,
  eSMX_MFP_GT_Reserved_8,
  eSMX_MFP_GT_Reserved_9,
  eSMX_MFP_GT_Reserved_10,
  eSMX_MFP_GT_Reserved_11,
  eSMX_MFP_GT_Reserved_12,
  eSMX_MFP_GT_Reserved_13,
  eSMX_MFP_GT_Reserved_14,
  eSMX_MFP_GT_Reserved_15
}; 
   

/** The mode of a service.
*
* This is a status, which is read-only. It cannot be adapted by MFP Statmux
* related calls. It is a property of an MFP encoder and can only be changed by 
* MFP IIOP calls.
*/
enum eSMX_MFP_SvcState
{
  eSMX_MFP_SvcState_StatMux,      ///< The encoder is running in Statmux mode.
  eSMX_MFP_SvcState_PassThrough,  ///< The encoder is running in pass-through mode, not measured.
  eSMX_MFP_SvcState_CBR,          ///< The encoder is running in CBR mode.
  eSMX_MFP_SvcState_CappedVBR,    ///< The encoder is running in C-VBR mode.
  eSMX_MFP_SvcState_PassThroughMeasurable, ///< The encoder is running in pass-through mode and 
                                           /// can be measured (bitrate taken into acount if 
                                           /// PassThroughMode is eSMX_MFP_PassThroughMode_Measured).

  // for future use
  eSMX_MFP_SvcState_Reserved_5,
  eSMX_MFP_SvcState_Reserved_6,
  eSMX_MFP_SvcState_Reserved_7,
  eSMX_MFP_SvcState_Reserved_8,
  eSMX_MFP_SvcState_Reserved_9,
  eSMX_MFP_SvcState_Reserved_10,
  eSMX_MFP_SvcState_Reserved_11,
  eSMX_MFP_SvcState_Reserved_12,
  eSMX_MFP_SvcState_Reserved_13,
  eSMX_MFP_SvcState_Reserved_14,
  eSMX_MFP_SvcState_Reserved_15
}; 

    
/** The Statmux mode of a service.
*
* This is a setting, which is only configurable for encoders being in the
* eSMX_MFP_SvcState_StatMux state (aka they are not in CBR/Cap-VBR/.. states)
* Only the one service belonging to a SPTS can be put in rate limit mode.
*/
enum eSMX_MFP_SvcMode
{
  eSMX_MFP_SvcMode_StatMux,    ///< The service is Statmuxed by the SMX group.
  eSMX_MFP_SvcMode_RateLimit,  ///< The service is used in rate limited mode.

  // for future use
  eSMX_MFP_SvcMode_Reserved_2,
  eSMX_MFP_SvcMode_Reserved_3,
  eSMX_MFP_SvcMode_Reserved_4,
  eSMX_MFP_SvcMode_Reserved_5,
  eSMX_MFP_SvcMode_Reserved_6,
  eSMX_MFP_SvcMode_Reserved_7,
  eSMX_MFP_SvcMode_Reserved_8,
  eSMX_MFP_SvcMode_Reserved_9,
  eSMX_MFP_SvcMode_Reserved_10,
  eSMX_MFP_SvcMode_Reserved_11,
  eSMX_MFP_SvcMode_Reserved_12,
  eSMX_MFP_SvcMode_Reserved_13,
  eSMX_MFP_SvcMode_Reserved_14,
  eSMX_MFP_SvcMode_Reserved_15
}; 


/** The PassThrough mode of a service.
 *
 * If a service is in PassThrough, it is possible to enable Measuring of its 
 * bitrate (taking it automatically into acount in the statmux group rate).
 * If not enabled, the bitrate should manually be set using reserved bitrate
 * of the statmux group.
 */
enum eSMX_MFP_PassThroughMode
{
  eSMX_MFP_PassThroughMode_Measured,      ///< Measure the bitrate and take it automatically
                                          ///  into acount in the group rate.
  eSMX_MFP_PassThroughMode_UnMeasured,    ///< Not measured: manually set reserved bitrate.

  // for future use
  eSMX_MFP_PassThroughMode_Reserved_2,
  eSMX_MFP_PassThroughMode_Reserved_3,
  eSMX_MFP_PassThroughMode_Reserved_4,
  eSMX_MFP_PassThroughMode_Reserved_5,
  eSMX_MFP_PassThroughMode_Reserved_6,
  eSMX_MFP_PassThroughMode_Reserved_7,
  eSMX_MFP_PassThroughMode_Reserved_8,
  eSMX_MFP_PassThroughMode_Reserved_9,
  eSMX_MFP_PassThroughMode_Reserved_10,
  eSMX_MFP_PassThroughMode_Reserved_11,
  eSMX_MFP_PassThroughMode_Reserved_12,
  eSMX_MFP_PassThroughMode_Reserved_13,
  eSMX_MFP_PassThroughMode_Reserved_14,
  eSMX_MFP_PassThroughMode_Reserved_15
};

/** GroupIDs for MFP Statmuxing uses between 10000 and 19999.
 *  Statmux groups made on Transrater stay with their ID below 10000. 
 */
const unsigned long SMX_MFP_MIN_GROUP_ID = 10000;
const unsigned long SMX_MFP_MAX_GROUP_ID = 19999;

/** Statmux group settings
 * The Type of the SMXGroup is important concerning further behavior and meanings of the different fields.
 * see the eSMX_MFP_GroupType_t for more details about the type.
 */
struct SMX_MFP_GroupSettings_t
{
  unsigned long         ID;         ///< ID of the group: read-only, ignored during creation. Only used in Set/Get/Delete 
                                    ///  commands.
  string                Name;       ///< Name: writable, the same name may be used multiple times, it exists only for user ref.
                                    ///  not used internally by the DCM. Name length limited to 32 characters.
  eSMX_MFP_GroupType_t  Type;       ///< Type of group: write-once on creation, read only after creation.
  IPS_RefTS_t           Location;   ///< Location of group (depends on Type: can be TS or Port only): write-once on 
                                    ///  creation, read only in the other cases.
                                    ///  REQUIREMENT: Should be a port for group type MultiTS 
                                    ///               and be a TS for the other group types.
  unsigned long         Bitrate;    ///< The maximum bitrate that should be applied to the statmux group. 
                                    ///  This should be lower or equal to the output transport stream bandwidth in case 
                                    ///  of SingleTS_xxx group types.
                                    ///  In bits per second. Range: from 1Mbps to 950Mbps.
                                    ///  REQUIREMENT: should be less than the bitrate associated with the location.
}; 

typedef sequence<SMX_MFP_GroupSettings_t> SMX_MFP_GroupSettings_List_t;///< A sequence of Statmux group settings
typedef sequence<unsigned long> SMX_MFP_GroupID_List_t;  ///< list of group ids.



/** Data linked with a TS in statmux context.
 */
struct SMX_MFP_TsSettings_t
{
  IPS_RefTS_t   TsRef;          ///< Ref of the TS
  unsigned long ReservedBitrate;///< reserved bitrate for this TS (for instance reserved for TS PIDs)
                                ///  In bits per second. Range: from 0 to 1 Gbps.
};

typedef sequence<SMX_MFP_TsSettings_t> SMX_MFP_TsSettings_List_t; ///< A sequence of Statmux Transport Stream settings


/** List of TS settings on Statmux group
 * Can be used to add/get TS to/from a group.
 * This can only be done for MultiTS and SingleTS_AllSvc group types.
 * It is not possible to add/get/delete TS for a SingleTS_SelectedSvc group.
 */
struct SMX_MFP_Group_TSSettings_t
{
  unsigned long             GroupID;///< The group reference. The group should already exist.
  SMX_MFP_TsSettings_List_t TSList; ///< A sequence of output transport stream settings.
}; 

typedef sequence<SMX_MFP_Group_TSSettings_t> SMX_MFP_Group_TSSettings_List_t; ///< A sequence of SMX_MFP_Group_TSSettings_t.

/** List of TS on a Statmux group, used for deleting TS from gorup  */
struct SMX_MFP_Group_TSs_t
{
  unsigned long    GroupID;   ///< The group reference. The group should already exist.
  IPS_RefTS_List_t TSList;    ///< A sequence of output transport streamS.
}; 

typedef sequence<SMX_MFP_Group_TSs_t> SMX_MFP_Group_TS_List_t; ///< A sequence of SMX_MFP_Group_TSs_t.


/** Statmux setting of a service.
 * These can be retrieved and changed by the SMX_MFP_SvcSettingsGet and SMX_MFP_SvcSettingsChange 
 * calls. They can be retrieved/changed for all video services being statmuxed in a group.
 */
struct SMX_MFP_SvcSettings_t 
{
  IPS_Service_t     SvcRef;     ///< Ref of the service
  eSMX_MFP_SvcState State;      ///< Read-Only: the  encoder rate control state.
  eSMX_MFP_SvcMode  Mode;       ///< to be statmuxed or used in rate limited mode.
                                ///  Rate Limited mode can only be set on a SPTS service in a MultiTS group.
                                ///  DEFAULT when service is added into a group:
                                ///  RateLimit mode for a MulitTS group.
                                ///  Statmux mode for all other group types.
  unsigned long     MaxBitrate; ///< maximum allowed bitrate for this service 
                                ///  In bits per second. Range: 3Mbps to 30Mbps
                                ///  REQUIREMENT: MaxBitrate has to be larger or equal MinBitrate
                                ///  REMARK: in RateLimit mode, the MaxBitrate indicates the rate limit.
                                ///  DEFAULT when service is added into a group: The Statmux Group bitrate
                                ///  or 12500000, whatever is the smallest.
  unsigned long     MinBitrate; ///< minimum allowed bitrate for this service
                                ///  In bits per second. Range: 500Kbps to 8Mbps
                                ///  REQUIREMENT: MinBitrate has to be lower or equal MaxBitrate
                                ///  Ignored in RateLimit mode
                                ///  DEFAULT when service is added into a group: 1000000
  long              Priority;   ///< relative priority (quality) in the statmux group. Range: from 0 to 6. 
                                ///< DEFAULT when service is added into a group: 3
  unsigned long     ReservedBitrate;  ///< reserved for future use: has to be filled in with 0.
};

typedef sequence<SMX_MFP_SvcSettings_t> SMX_MFP_SvcSettings_List_t; ///< A sequence of Statmux services


/** Statmux setting of a service, Version 2
 * 
 * @version  Release 11.10
 * 
 * Added automatic measuring of passthrough services.
 * When upgrading from pre 11.10: measuring is disabled, has to manually enabled
 * (which is keeping the pre 11.10 behaviour).
 * New services will automatically be put in measured pass-through mode.
 * Remark that measuring pass-through services only works for services passing
 * the MFP board.
 */
struct SMX_MFP_SvcSettings_V2_t 
{
  IPS_Service_t             SvcRef;     ///< Ref of the service
  eSMX_MFP_SvcState         State;      ///< Read-Only: the  encoder rate control state.
  eSMX_MFP_SvcMode          Mode;       ///< see SMX_MFP_SvcSettings_t
  eSMX_MFP_PassThroughMode  PassThroughMode;  ///< How pass-through services should be handeld.
  unsigned long             MaxBitrate; ///< see SMX_MFP_SvcSettings_t
  unsigned long             MinBitrate; ///< see SMX_MFP_SvcSettings_t
  long                      Priority;   ///< see SMX_MFP_SvcSettings_t
  unsigned long             ReservedBitrate;  ///< reserved for future use: has to be filled in with 0.
};

typedef sequence<SMX_MFP_SvcSettings_V2_t> SMX_MFP_SvcSettings_V2_List_t; ///< A sequence of Statmux services




/** Service settings within a group
 */
struct SMX_MFP_Group_SvcSettings_t 
{
  unsigned long               GroupID; ///< The group reference. The group should already exist. 
  SMX_MFP_SvcSettings_List_t  SvcList; ///< sequence of services with their settings
};

typedef sequence<SMX_MFP_Group_SvcSettings_t> SMX_MFP_Group_SvcSettings_List_t; ///< A sequence of SMX_MFP_Group_SvcSettings_t.


/** Service settings within a group
 */
struct SMX_MFP_Group_SvcSettings_V2_t 
{
  unsigned long                  GroupID; ///< The group reference. The group should already exist. 
  SMX_MFP_SvcSettings_V2_List_t  SvcList; ///< sequence of services with their settings
};

typedef sequence<SMX_MFP_Group_SvcSettings_V2_t> SMX_MFP_Group_SvcSettings_V2_List_t; ///< A sequence of SMX_MFP_Group_SvcSettings_V2_t.


/** Services in a group
 */
struct SMX_MFP_Group_Svc_t
{
  unsigned long        GroupID; ///< The group reference. The group should already exist. 
  IPS_Service_List_t   SvcList; ///< sequence of services
};

typedef sequence<SMX_MFP_Group_Svc_t> SMX_MFP_Group_Svc_List_t; ///< A sequence of SMX_MFP_Group_Svc_t.



/** Request to create a list of statmux groups.
 *
 * Group IDs are assigned and managed by the IO Board, they are read-only and content set 
 * by the caller is ignored.
 * 
 * @param[in] BoardNr The slot (board) to apply the call on.
 * @param[in] GroupSettingsList A sequence of SMX_MFP_GroupSettings_t objects - ID is ignored
 * @param[out] CreatedGroupIDs the assigned group IDs (same order as the GroupSettingsList input)
 *
 * @exception OperationFailed Is thrown when: 
 * - if BoardNr is not valid 
 * - trying to create a MultiTS group on an ASI board, this is not allowed;
 *   By definition ASI has only one TS available, so there is no need for a multiTS
 * - trying to create a group with an invalid group type;
 * - trying to create a group with a TS reference for an output TS that is already a part of a SMX group
 *   (TS can be only part of a SingeTS_AllSvc group or if it is a SPTS 
 *   it can also be part of a MultiTS group);
 * - trying to create a group with a bitrate higher than the output bitrate of the location;
 * - trying to create a group if there are no more groups available (out-of-resources);
 * - if group bitrate is out of range.
 * - if name is too long.
 * - if Group_Settings.location does not match BoardNr parameter of call.
 * @exception TimeOut Is thrown when it takes too long to handle the call.
 *
 * @version  Release 10.0.5
 */
void SMX_MFP_GroupCreate(in  unsigned short BoardNr, 
                         in  SMX_MFP_GroupSettings_List_t GroupSettingsList, 
                         out SMX_MFP_GroupID_List_t CreatedGroupIDs) 
    raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);


/** Gets the list of statmux group settings. It is possible to get the whole list if an 
 *  empty RefTS list is passed Refs parameter.
 *
 * @remarks Both the RefTs as the GroupIDList are used as filter.
 *          If the GroupIDList is empty, then the RefPhys is used as filter 
 *          for the SMX groups to retrieve:
 *          - if only board set (thus port is REF_ALL): all Groups on board
 *          - if only board/port set: all Groups located on this port
 *          - if board/port/TS is set: all Groups located on this TS
 *          If the GroupIDList is not empty, these groups are retrieved and checked
 *          against the RefTs (which should fit the location as defined in the
 *          three cases above).
 *
 * @param[in]  RefTs The slot(board)/port/TS to retrieve the groups from (filter criterium)
 * @param[in]  GroupIDList A SMX_MFP_GroupID_List_t list of group IDs. This can be an empty list (in which case all are returned)
 * @param[out] GroupSettingsList list of retrieved settings
 *
 * @exception OperationFailed Is thrown when:
 * - if RefTs is not valid.
 * - if an invalid group ID is used.
 * - if the group ID requested its location does not fit with the RefTS filter.
 * @exception TimeOut Is thrown when it takes too long to handle the call.
 *
 * @version Release 10.0.5
 */
void SMX_MFP_GroupGet(in IPS_RefTS_t RefTs, in SMX_MFP_GroupID_List_t GroupIDList, out SMX_MFP_GroupSettings_List_t GroupSettingsList) 
    raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);


/** Change the settings of statmux group(s).
 *
 * @param[in] BoardNr The slot (board) to apply the call on.
 * @param[in] GroupList A sequence of SMX_MFP_GroupSettings_t objects 
 *             - Group ID is used as reference.
 *
 * @exception OperationFailed Is thrown: 
 * - if BoardNr is not valid 
 * - if the group ID is invalid
 * - if trying to change the group type (read-only parameter)
 * - if trying to change the location (write once on creation)
 * - if group bitrate is out of range
 * - if name is too long.
 * @exception TimeOut Is thrown when it takes too long to handle the call.
 *
 * @version Release 10.0.5
 */
void SMX_MFP_GroupChange(in unsigned short BoardNr, in SMX_MFP_GroupSettings_List_t GroupList) 
    raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);


/** Delete statmux group(s).  Deleting a group means what it says: 
 *   every member (TS or Svc) of the group is also removed.
 *
 * @param[in] BoardNr The slot(board) to apply the call on.
 * @param[in] GroupIDList A sequence of group IDs for the groups that have to be deleted.
 *
 * @exception OperationFailed Is thrown: 
 * - if BoardNr is not valid 
 * - if group ID is invalid.
 * @exception TimeOut Is thrown when it takes too long to handle the call.
 *
 * @version Release 10.0.5
 */
void SMX_MFP_GroupDelete(in unsigned short BoardNr, in SMX_MFP_GroupID_List_t GroupIDList) 
    raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);




/** Add complete mux output transport stream(s) to statmux group(s).   
 * This can only be done for statmux groups of type MultiTS or SingleTS_AllSvc.
 * For groups of type SingleTS_SelectedSvc it is not possible to add TS (in this
 * case services have to be added instead).
 *
 * TS added to the group by this call will automatically add all their services 
 * to the group. When services are added/removed while a TS is member of a group
 * then these services will automatically be added/removed to/from the group.
 *
 * @param[in] BoardNr The slot(board) to apply the call on.
 * @param[in] GroupTSList A sequence of statmux group ids / transport stream(s) that should be added.
 *
 * @exception OperationFailed Is thrown when: 
 * - if BoardNr is not valid 
 * - if group ID does not exists
 * - if transport stream does not exist
 * - if the transport stream is already part of a group or this group
 * - if trying to add more than one TS to a SingleTS_AllSvc group
 * - if trying to add a TS to a SingleTS_SelectedSvc group
 * - if trying to add a MPTS to a MultiTS group (in this case only SPTS are allowed)
 * - if there are not enough internal resources anymore to add the TS to a group
 * - if the reserved bitrate of the TS is set out of range
 * @exception TimeOut Is thrown when it takes too long to handle the call.
 *
 * @version Release 10.0.5
 */
void  SMX_MFP_TSAdd(in unsigned short BoardNr, in SMX_MFP_Group_TSSettings_List_t GroupTSList) 
    raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);


/** Gets a list of TSs settings that are part of the statmux group(s). 
 *
 * As no TS can be added on SingleTS_SelectedSvc groups, this call cannot 
 * be issued on such groups.
 *
 * @param[in]  BoardNr The slot(board) to apply the call on.
 * @param[in]  GroupIDList The sequence of group IDs the transport streams are requested for.
 * @param[out] GroupTSList TS members and settings of the(se) group(s)
 *
 * @exception OperationFailed Is thrown: 
 * - if BoardNr is not valid 
 * - if a group ID does not exist
 * - if this is requested for a group which is of type SingleTS_SelectedSvc.
 * @exception TimeOut Is thrown when it takes too long to handle the call.
 *
 * @version Release 10.0.5
 */
void SMX_MFP_TSGet(in unsigned short BoardNr, in  SMX_MFP_GroupID_List_t GroupIDList, out SMX_MFP_Group_TSSettings_List_t GroupTSList) 
    raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);


/** Change a list of TSs settings that are part of the statmux group(s). 
 *
 * As no TS can be added on SingleTS_SelectedSvc groups, this call cannot 
 * be issued on such groups.
 *
 * @param[in]  BoardNr The slot(board) to apply the call on.
 * @param[out] GroupTSList TS members of the(se) group(s) to update
 *
 * @exception OperationFailed Is thrown when: 
 * - if BoardNr is not valid 
 * - if a group ID does not exist.
 * - if a TS ref is not member of the group.
 * - if a group is of Type eSMX_SingleTS_SelectedSvc
 * - if reserved bitrate is set out of range
 * @exception TimeOut Is thrown when it takes too long to handle the call.
 *
 * @version Release 10.0.5
 */
void SMX_MFP_TSChange(in unsigned short BoardNr, in SMX_MFP_Group_TSSettings_List_t GroupTSList) 
    raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);


/** Delete TS(s) from statmux group(s). This means that every single pid from every TS specified is removed from the group.
 *
 * This can not be done on groups of type eSMX_SingleTS_SelectedSvc.
 * Remark that only the TS ref are used in the list to identify which TS to remove.
 *  ==> TBC: maybe it is better to pass only sequence of TSRef?
 * 
 * @param[in] BoardNr The slot(board) to apply the call on.
 * @param[in] GroupTSList The sequence of group ID(s) - transport stream(s) relations that should be deleted.
 *
 * @exception OperationFailed Is thrown: 
 * - if BoardNr is not valid 
 * - if a group ID does not exist.
 * - if a TS Ref does not belong to the group where it should be deleted from
 * - if a group if of type eSMX_SingleTS_SelectedSvc
 * @exception TimeOut Is thrown when it takes too long to handle the call.
 *
 * @version Release 10.0.5
 */
void SMX_MFP_TSDelete(in unsigned short BoardNr, in SMX_MFP_Group_TS_List_t GroupTSList) 
    raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);




/** Retrieve the Service settings from a group
 *
 * This will return settings from all services belonging to a group, also the implicit
 * ones in the case of MultTs and SingleTS_AllSvc groups (where you cannot add
 * services explicitely). For SingleTs_SelectedSvc groups the settings of 
 * the explicitly added services will be retrieved.
 * Remark that the SvcAdd (as supported on SingleTS_Selected Svc) does not set Svc settings
 * (min/max bitrate, priorities, ...). These can only be retrieved and set by using the
 * SMX_MFP_SvcSettingsGet/Change calls.
 *
 * @param[in]  BoardNr The slot(board) to apply the call on.
 * @param[in]  GroupIDList The sequence of group IDs the service settings are requested for.
 * @param[out] GroupSvcList SVc members and settings from these groups
 *
 * @exception OperationFailed Is thrown: 
 * - if BoardNr is not valid 
 * - if a group ID does not exist
 * @exception TimeOut Is thrown when it takes too long to handle the call.
 *
 * @version Release 10.0.5
 */
void SMX_MFP_SvcSettingGet(in unsigned short BoardNr, in  SMX_MFP_GroupID_List_t GroupIDList, out SMX_MFP_Group_SvcSettings_List_t GroupSvcList) 
    raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);


/** Retrieve the Service settings from a group
 *
 * @see SMX_MFP_SvcSettingGet().
 *
 * This version add the possibility to enable measuring of PassThrough services.
 *
 * @param[in]  BoardNr The slot(board) to apply the call on.
 * @param[in]  GroupIDList The sequence of group IDs the service settings are requested for.
 * @param[out] GroupSvcList SVc members and settings from these groups
 *
 * @exception OperationFailed Is thrown: 
 * - if BoardNr is not valid 
 * - if a group ID does not exist
 * @exception TimeOut Is thrown when it takes too long to handle the call.
 *
 * @version Release 11.10
 */
void SMX_MFP_SvcSettingGet_V2(in unsigned short BoardNr, in  SMX_MFP_GroupID_List_t GroupIDList, out SMX_MFP_Group_SvcSettings_V2_List_t GroupSvcList) 
    raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);


/** Update the Service settings from a group
 *
 * Remark that the SvcAdd (as supported on SingleTS_Selected Svc) does not set Svc settings
 * (min/max bitrate, prioritys, ...). These can only be retrieved and set by using the
 * SMX_MFP_SvcSettingsGet/Set calls.
 *
 * @remarks In case the sSMX_MFP_SvcState is not Statmux, then the sSMX_MFP_SvcMode
 *          set is ignored.
 *
 * @param[in]  BoardNr The slot(board) to apply the call on.
 * @param[in]  GroupSvcList SVc members and settings to be changed.
 *
 * @exception OperationFailed Is thrown: 
 * - if BoardNr is not valid 
 * - if a group ID does not exist
 * - if MinBitrate out of range
 * - if MaxBitrate out of range
 * - if priority out of range 
 * @exception TimeOut Is thrown when it takes too long to handle the call.
 *
 * @version Release 10.0.5
 */
void SMX_MFP_SvcSettingChange(in unsigned short BoardNr, in SMX_MFP_Group_SvcSettings_List_t GroupSvcList) 
    raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);



/** Update the Service settings from a group
 *
 * @see  SMX_MFP_SvcSettingChange().
 *
 * This version adds the measured pass-through services feature.
 *
 * @param[in]  BoardNr The slot(board) to apply the call on.
 * @param[in]  GroupSvcList SVc members and settings to be changed.
 *
 * @exception OperationFailed Is thrown: 
 * - if BoardNr is not valid 
 * - if a group ID does not exist
 * - if MinBitrate out of range
 * - if MaxBitrate out of range
 * - if priority out of range 
 * @exception TimeOut Is thrown when it takes too long to handle the call.
 *
 * @version Release 11.10
 */
void SMX_MFP_SvcSettingChange_V2(in unsigned short BoardNr, in SMX_MFP_Group_SvcSettings_V2_List_t GroupSvcList) 
    raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);





/** Add services to a SingleTS_SelectedSvc statmux group.
 * This is only allowed for SingleTS_SelectedSvc groups.
 *
 * @remarks To retrieve the services use the SMX_MFP_SvcSettingGet() call 
 *          To change service settings use the SMX_MFP_SvcSettingChange() call
 * 
 * @param[in] BoardNr The slot(board) to apply the call on.
 * @param[in] GroupServiceList The sequence of GroupID/services that should be added.  
 *
 * @exception OperationFailed Is thrown: 
 * - if BoardNr is not valid 
 * - if group ID does not exists
 * - if group is not of type eSMX_MFP_SingleTS_SelectedSvc
 * - id service ref does not exist
 * - if the statmux group is not of the correct type, 
 * - if the service is already part of the group
 * @exception TimeOut Is thrown when it takes too long to handle the call.
 *
 * @version Release 10.0.5
 */
void SMX_MFP_ServiceAdd(in unsigned short BoardNr, in SMX_MFP_Group_Svc_List_t GroupServiceList) 
    raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);


/** Gets the list of services added explicitly (eSMX_MFP_SingleTS_SelectedSvc group)
 *
 * This will return  all services explicitly added to a group
 *
 * @param[in]  BoardNr The slot(board) to apply the call on.
 * @param[in]  GroupIDList The sequence of group IDs the services are requested for.
 * @param[out] GroupServiceList SVc members from these groups
 *
 * @exception OperationFailed Is thrown when:
 * - if BoardNr is not valid 
 * - if an invalid group ID is used.
 * - if group is not of type eSMX_MFP_SingleTS_SelectedSvc
 * @exception TimeOut Is thrown when it takes too long to handle the call.
 *
 * @version Release 10.0.5
 */
void SMX_MFP_ServiceGet(in unsigned short BoardNr, in  SMX_MFP_GroupID_List_t GroupIDList, out SMX_MFP_Group_Svc_List_t GroupServiceList) 
    raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);


/** Delete a sequence of service that were previously added to statmux group(s).  
 * This will only be allowed for eSMX_MFP_SingleTS_SelectedSvc groups, 
 * i.e. for services that were added explicitly.
 * 
 * @param[in] BoardNr The slot(board) to apply the call on.
 * @param[in] GroupServiceList The sequence of group ID(s) - service relations that need to be removed
 *
 * @exception OperationFailed Is thrown: 
 * - if BoardNr is not valid 
 * - if group ID does not exists
 * - if the statmux group is not of the eSMX_MFP_SingleTS_SelectedSvc type
 * - if a service is not part of the group
 * @exception TimeOut Is thrown when it takes too long to handle the call.
 * 
 * @version Release 10.0.5
 */
void SMX_MFP_ServiceDelete(in unsigned short BoardNr, in SMX_MFP_Group_Svc_List_t GroupServiceList) 
    raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);



/// @} end of MFP Statmux staging





    /** @defgroup pidsync PID Sync
     * This contains types, enums and methods to control PID Sync.
     * @{
     */

    struct IPS_OutPID_Sync_t 
    {
      PID_List_t OutputPIDs;        ///< The pids to be synchronized
      unsigned long  Delay;         ///< The time (in ms) the PIDs should be delayed
    };

    typedef sequence<IPS_OutPID_Sync_t> IPS_OutPID_SyncList_t;

    struct IPS_OutServiceSync_t
    {
      IPS_Service_t OutService;
      IPS_OutPID_SyncList_t PID_SyncList;
    };
    
    typedef sequence<IPS_OutServiceSync_t> IPS_OutServiceSyncList_t;

    struct IPS_OutPID_Sync_V2_t 
    {
      PID_List_t OutputPIDs;        ///< The pids to be synchronized
      long  Delay;                  ///< The time (in ms) the PIDs should be delayed
    };

    typedef sequence<IPS_OutPID_Sync_V2_t> IPS_OutPID_SyncList_V2_t;

    struct IPS_OutServiceSync_V2_t
    {
      IPS_Service_t OutService;
      IPS_OutPID_SyncList_V2_t PID_SyncList;
    };
    
    typedef sequence<IPS_OutServiceSync_V2_t> IPS_OutServiceSyncList_V2_t;

    // PID Sync IDLs
    //////////////////////////////////////////////

    /** Get the PID sync settings.
     *
     * @param[in]  RefTS The TS for which to get the sync settings.
     * @param[in]  OutSidList The SIDs of the services for which to retrieve the settings.
     * @param[out] SyncList A list of PID sync settings.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main.
     * @exception OpNotSucceeded In case:
     * - invalid input references are used (RefTS, OutService).
     * - a negative delay value was set using the newer version of the set call and this call is used to readout the value.
     *
     * @version Supported since release 6.0
     */
    void IPS_OutServiceGetSyncL(in IPS_RefTS_t RefTS, in ServiceIdList_t OutSidList, out IPS_OutServiceSyncList_t SyncList) 
       raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the PID sync settings.
     *
     * @param[in]  RefTS The TS for which to get the sync settings.
     * @param[in]  OutSidList The SIDs of the services for which to retrieve the settings.
     * @param[out] SyncList A list of PID sync settings.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main.
     * @exception OpNotSucceeded In case:
     * - invalid input references are used (RefTS, OutService).
     *
     * @version Supported since release 8.1
     */
    void IPS_OutServiceGetSyncL_V2(in IPS_RefTS_t RefTS, in ServiceIdList_t OutSidList, out IPS_OutServiceSyncList_V2_t SyncList) 
       raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the PID sync settings.
     *
     * @param[in] RefTS The TS for which to set the PID sync settings.
     * @param[in] SyncList The PID sync settings
     *
     * @exception OpNotSupported When BoardNr = 0 = Main.
     * @exception OpNotSucceeded In case:
     * - invalid input references are used (RefTS, OutService).
     * - the delay value is too large (> 10s).
     * - the service is part of a transrating group
     * - the service has DPI settings
     * @exception LicenseError if there are insufficient PID Sync licenses to
     * complete the request.
     *
     * @version Supported since release 6.0
     *
     * @note: If a service is not listed in the SyncList it will not be changed.
     * @note: Existing IPS_OutPID_Sync_t entries are removed if a new IPS_OutServiceSync_t is set.
     */
    void IPS_OutServiceSetSyncL(in IPS_RefTS_t RefTS, in IPS_OutServiceSyncList_t SyncList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);

    /** Set the PID sync settings.
     *
     * @param[in] RefTS The TS for which to set the PID sync settings.
     * @param[in] SyncList The PID sync settings
     *
     * @exception OpNotSupported When BoardNr = 0 = Main.
     * @exception OpNotSucceeded In case:
     * - invalid input references are used (RefTS, OutService).
     * - the delay value is not within the valid range (-1200ms ... 10s).
     * - the service is part of a transrating group
     * - the service has DPI settings
     * @exception LicenseError if there are insufficient PID Sync licenses to
     * complete the request.
     *
     * @version Supported since release 8.1
     *
     * @note: If a service is not listed in the SyncList it will not be changed.
     * @note: Existing IPS_OutPID_Sync_t entries are removed if a new IPS_OutServiceSync_t is set.
     */
    void IPS_OutServiceSetSyncL_V2(in IPS_RefTS_t RefTS, in IPS_OutServiceSyncList_V2_t SyncList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);

    /// @} end of PID Sync
    
    // Slate Insertion
    ///////////////////////////////////////////////////////////////////////////////////////

    /** @defgroup slateinsertion Slate Insertion
     * This contains specific types, enums and methods for controlling the slate insertion part of the device.
     * @{
     */
    struct SlateService_t
    {
      IPS_RefSvc_t RefSvc;
      ClipID_t     ClipID;
    };
    typedef sequence<SlateService_t> SlateServiceList_t;

    /** Enable slate insertion.
     *
     * @param[in]  RefTS The TS on which to enable the slate generation.
     * @param[in]  SlateServiceList The list of services to set the slate generation.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main
     * @exception OpNotSucceeded In case :
     * - the ClipID doesn't exist
     * - the service doesn't exist.
     * - The service is in a transrating group / configured for DPI / PID synced
     * @exception LicenseError if there are insufficient Slate generation licenses to
     * complete the request.
     *
     * @version Release 7.5
     **/
    void TR_SlateServiceSetL(in IPS_RefTS_t RefTS, in SlateServiceList_t SlateServiceList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);

    /** Get a list of all slate services.
     *
     * @param[in]  RefTS  The TS of which to get the slate services.
     * @param[in]  OutputSidList  A list of Service ID's to get info about. All services if empty.
     * @param[out] SlateServiceList  The list of services that have Slate generation enabled with their corresponding ClipID
     *
     * @exception OpNotSupported When BoardNr = 0 = Main
     * @exception OpNotSucceeded When one if the services listed in OutputSidList is not in slate generation mode.
     *
     * @version Release 7.5
     **/
    void TR_SlateServiceGetL(in IPS_RefTS_t RefTS, in ServiceIdList_t OutputSidList, out SlateServiceList_t SlateServiceList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Disable slate insertion.
     *
     * @param[in]  RefTS  The TS on which to disable slate generation.
     * @param[in]  OutputSidList  The list of services to disable Slate generation.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main
     *
     * @version Release 7.5
     **/
    void TR_SlateServiceDeleteL(in IPS_RefTS_t RefTS, in ServiceIdList_t OutputSidList)
        raises(TimeOut, OpNotAllowed, OpNotSupported);

    /// @} end of slate insertion
    
    // Audio leveling
    ///////////////////////////////////////////////////////////////////////////////////////

    /** @defgroup audiolevel Audio Leveling
     * This contains specific types, enums and methods for controlling the audio leveling part of the device.
     * @{
     */

    struct TR_AudioLevel_t
    {
      unsigned short Pid; ///< The PID value (0..8190)
      long Level;         ///< Audio level change, in db. Between -31 and +31
                          ///< Positive values indicate amplification, negative ones attenuation
    };

    typedef sequence<TR_AudioLevel_t> TR_AudioLevelList_t;

    struct TR_ServiceAudioLevel_t
    {
      IPS_RefSvc_t RefSvc;
      TR_AudioLevelList_t AudioLevelList;
    };
    typedef sequence<TR_ServiceAudioLevel_t> TR_ServiceAudioLevelList_t;

    /** Get a list of all audio leveling settings
     * 
     * @param[in]  RefTS          The TS of which to get the audio leveling settings
     * @param[in]  OutputSidList  A list of Service ID's to get info about. All services if empty.
     * @param[out] AudioLevels    The list of audio leveling settings
     *
     * @exception OpNotSupported When BoardNr = 0 = Main
     *
     * @version Release 8.5
     **/ 
    void TR_AudioLevelGetL(in IPS_RefTS_t RefTS, in ServiceIdList_t OutputSidList, out TR_ServiceAudioLevelList_t AudioLevels)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Set audio leveling settings.
     * Set an empty list to remove all existing audio leveling settings.
     *
     * @param[in] RefTS       The TS of which to get the audio leveling settings
     * @param[in] AudioLevels The list of new audio leveling settings
     *
     * @exception OpNotSupported When BoardNr = 0 = Main
     *
     * @version Release 8.5
     **/ 
    void TR_AudioLevelSetL(in IPS_RefTS_t RefTS, in TR_ServiceAudioLevelList_t AudioLevels)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);

    /// @} end of audio leveling

    // Pure TS delay
    ///////////////////////////////////////////////////////////////////////////////////////

    /** @defgroup PureTsDelay Pure TS Delay
     * This contains specific types, enums and methods for controlling the pure TS delay mode of the device.
     * @{
     */


    /// TS Delay settings.
    struct TR_TsDelay_t
    {
      IPS_RefTS_t TsRef;    ///< The TS.
      boolean     DelayTs;  ///< true = delay the TS / false = don't delay TS
    }; 
    typedef sequence< TR_TsDelay_t > TR_TsDelay_List_t;


    /** Enable/Disable the TS delay mode of Loopthrough TS's
     *
     * @param[in] RefPhys The slot(board) and port to apply the call on
     * @param[in] TsDelayList A sequence of TR_TsDelay_t
     *
     * @exception TimeOut is thrown when it takes too long to handle the call
     * @exception OperationFailed is thrown
     *          - when the delay mode of the board is not set to TsDelay
     *          - when invalid references are passed
     * @exception OpNotSupported When BoardNr = 0 = Main
     *
     * @version Release 8.9
     */
    void TR_TsDelaySetL(in IPS_Ref_t RefPhys, in TR_TsDelay_List_t TsDelayList)
      raises(TimeOut, OpNotAllowed, OpNotSupported, OpNotSucceeded, OperationFailed);

    /** Gets the TS delay mode of Loopthrough TS's
     *
     * @param[in] RefPhys The slot(board) and port to apply the call on.
     *     Port can be 0xFFFF (all ports) or a specific port.
     * @param[in] TS_List List of all Loopthrough TS's we want info upon. Empty list means every Loopthrough TS on the port.
     * @param[out] TsDelayList A sequence of TR_TsDelay_t
     *
     * @exception TimeOut is thrown when it takes too long to handle the call
     * @exception OperationFailed is thrown when invalid references are passed
     * @exception OpNotSupported When BoardNr = 0 = Main
     *
     * @version Release 8.9
     */
    void TR_TsDelayGetL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t TS_List, out TR_TsDelay_List_t TsDelayList)
      raises(TimeOut, OpNotAllowed, OpNotSupported, OpNotSucceeded, OperationFailed);

    /// @} end of Pure TS delay



    /** @defgroup dpi DPI
     * This contains types, enums and methods to control DPI.
     * @{
     */
    
    /// Defines how to splice a channel.
    enum eDPI_Mode
    {
      Off,              ///< --> Splice temporally disabled                   
      Scte30,           ///< --> Splice triggered via Scte30 from AdServer 
      Scte35,           ///< --> Splice triggered via Scte35 from primary stream with automatic PID matching
      Manual,           ///< --> Splice triggered via Command from GUI or script with automatic PID matching
      Scte35_Custom,    ///< --> Splice triggered via Scte35 from primary stream using Custom PID couples
      Manual_Custom,    ///< --> Splice triggered via Command from GUI or script using Custom PID couples
      Scte35_Inserter   ///< --> Splice will result in a Scte35 message inserted in the primary feed.
    };
    
    /// DPI mode bitfield, allowing combined DPI modes
    /**
    * bit0 : Off
    * bit1 : Scte30
    * bit2 : Scte35
    * bit3 : Manual
    * bit4 : GPI
    * bit5 : Custom             // must be used in combination with an other mode or combined mode
    * bit6 : Scte35Inserter
    * bit7 : OnVideoLoss		// set: act on video loss, not set: ignore video loss
	* bit8 : Seamless alternates
    *
    */
    
    typedef unsigned long DPI_ModeBitmap_t;
     
    /// A spliceable channel name.
    struct DPI_ChannelName_t
    {
      string ChannelName;       ///< max 32 characters, must be 0 terminated    
    };
    
    /// A sequence of DPI_ChannelName_t.
    typedef sequence<DPI_ChannelName_t> DPI_ChannelName_List_t;
        
    // Channel settings status enumeration
    // ------------------------------------------------------------------------------------
    enum eChannelLicenseStatus
    {
      ChannelLicenseStatusOk,
      ChannelLicenseStatusNoDPILicense       ///< --> Unable to reserve the required DPI licenses for this channel
    };

    enum eChannelViewingStatus
    {
      ChannelViewingStatusPrimary,  ///< Currently playing MAIN feed
      ChannelViewingStatusAd        ///< Currently playing some ad
    };

    struct DPI_ShortChannelStatus_t
    {
      eChannelLicenseStatus License;
      eChannelViewingStatus Viewing;
      unsigned long NextSplice;
      unsigned long LastError;
    };

    struct DPI_ChannelSettings_t
    {
      DPI_ChannelName_t OutputSpliceName;
      eDPI_Mode Mode;
      IPS_RefTS_t PrimaryTs;      
      unsigned long PrimaryChannel;       ///< SID
      IPS_RefTS_t InsertionTs;
      unsigned long InsertionChannel;     ///< SID 
    };
    
    /// A sequence of DPI_ChannelSettings_t.
    typedef sequence<DPI_ChannelSettings_t> DPI_ChannelSettings_List_t;

    // This new structure add status information for DPI channels
    struct DPI_ChannelSettings2_t
    {
      DPI_ChannelName_t OutputSpliceName;
      eDPI_Mode Mode;
      IPS_RefTS_t PrimaryTs;      
      unsigned long PrimaryChannel;       ///< SID
      IPS_RefTS_t InsertionTs;
      unsigned long InsertionChannel;     ///< SID 
      DPI_ShortChannelStatus_t Status;        ///< The status information shown in the GUI on the overview page
    };

    /// A sequence of DPI_ChannelSettings2_t.
    typedef sequence<DPI_ChannelSettings2_t> DPI_ChannelSettings2_List_t;

    // This new structure add status information for DPI channels 
    struct DPI_ChannelSettings3_t
    {
      DPI_ChannelName_t OutputSpliceName;
      IPS_RefTS_t PrimaryTs;      
      unsigned long PrimaryChannel;       ///< SID
      IPS_RefTS_t InsertionTs;
      unsigned long InsertionChannel;     ///< SID 
      DPI_ShortChannelStatus_t Status;    ///< The status information shown in the GUI on the overview page
      DPI_ModeBitmap_t Modes;             ///< Modes bitmap allowing combined DPI modes
      unsigned long ToInsertGpiNr;        ///< Gpi pin used to switch to insertion
      unsigned long ToMainGpiNr;          ///< Gpi pin used to switch to main
      unsigned long DpiGpiNr;             ///< Gpi pin used for both, to insertion and to main            
      unsigned long SpliceDelay;          ///< Splice delay in msec for both, to insertion and to main (0 means asap, max = 3600000 msec) 
    };

    /// A sequence of DPI_ChannelSettings3_t.
    typedef sequence<DPI_ChannelSettings3_t> DPI_ChannelSettings3_List_t;

    struct DPI_ChannelStatus_t
    {
      IPS_RefTS_t PrimaryTs;      
      unsigned long PrimaryChannel;       ///< SID
      DPI_ShortChannelStatus_t shortStatus;
      sequence<string> Servers;           ///< Each string contains an IP address plus insertion channel information
    };

    /// A sequence of DPI_ChannelStatus_t.
    typedef sequence<DPI_ChannelStatus_t> DPI_ChannelStatus_List_t;

    /// UTC since jan 1 1970.
    struct DPI_Time_t
    {
      unsigned long sec;
      unsigned long usec;
    };
    
    struct DPI_CueRequest_t
    {
      DPI_ChannelName_t OutputSpliceName;
      DPI_Time_t SpliceTime;
    };
    
    /**
     * A splice request is supposed to arrive a few seconds in advance of the actual splice time.
     * If the request is not received at least "SpliceRequestScheduleTime" seconds in advance, the request will be refused.
     * If the request is not received at least "SpliceRequestWarningTime" seconds in advance, a warning will be logged
     * but the request will be accepted.
     * @deprecated Obsoleted in release 11.0
     **/ 
    struct DPI_SpliceRequestTime_t
    {
      unsigned short SpliceRequestScheduleTime;   ///< in seconds
      unsigned short SpliceRequestWarningTime;    ///< in seconds
    };
    
    struct DPI_SpliceRequest_t
    {
      DPI_ChannelName_t OutputSpliceName;    ///< Identifies the spliceable output channel
      boolean SpliceIn;                      ///< SpliceIn == true/false means switch to ad/main 
      DPI_Time_t SpliceTime;                 ///< SpliceTime == 0 means ASAP
      unsigned long Duration;                ///< Duration == 0 means FOREVER or until aborted
    };

    enum eSpliceMatchRule
    {                         /// If Main PID not specified default is to block
      Match,                  ///< Match with Ad PID
      PassMain                ///< Pass Main PID
    };

    struct DPI_PidCouple_t
    {
      unsigned short MainPid;           ///< Main Input PID value
      unsigned short AdPid;             ///< Ad Input PID value - INVALID_PID_VALUE if rule ==  PassMain
      eSpliceMatchRule MatchingRule;    ///< Matching rule
    };

    typedef sequence<DPI_PidCouple_t> DPI_PidCoupleList_t;
    
    /// Enum indicating whether PMT should follow main or must be generated during splice.
    enum ePmtSpliceMode
    {
      FollowPrimary, ///< The PMT is taken from the main stream.
      Generated      ///< The PMT is recreated based on the components found in the inserted stream.
    };

    /// Struct to set/get ePMT_SpliceMode per channel.
    struct DPI_PmtSpliceModeSetting_t
    {
      DPI_ChannelName_t OutputSpliceName;
      ePmtSpliceMode PmtSpliceMode;
    };
    
    /// A sequence of DPI_PmtSpliceModeSetting_t.
    typedef sequence<DPI_PmtSpliceModeSetting_t> DPI_PmtSpliceModeSettingList_t;
	
  enum eETV_PrimaryChannel_Mode_t
  {
    eMainSvcBlockETV_Pids, ///< No ETV pids at output at all times
    eMainSvcUsePrimaryServiceETV_Pids, ///< Default mode : pass ETV pid from primary service
    eMainSvcUseOtherServiceETV_Pids, ///<  Only if other service is in service loss, ETV pids from  primary will be taken
    eMainSvcUseDummyETV_Pids ///< Create placeholders in PMT for EISS and EBIF pids
  };
    
  struct ETV_Primary_Settings_t
  {
    eETV_PrimaryChannel_Mode_t  ETV_Primary_Mode;
    IPS_RefSvc_t                ETV_OtherSvc;  ///< Only applicable if primary mode is eUseOtherServiceETV_Pids
    unsigned short              EISS_Pid;  ///< Only applicable if primary mode is eUseDummyETV_Pids
    unsigned short              EBIF_Pid;  ///< Only applicable if primary mode is eUseDummyETV_Pids
  };
  
  enum eETV_InsertionChannel_Mode_t
	{
    eAdSvcUseInsertionServiceETV_Pids, ///< Default mode : pass ETV pid from insertion service  during splice
    eAdSvcUsePrimaryServiceETV_Pids, ///< During splice, keep passing ETV pid from primary service
    eAdSvcUseOtherServiceETV_Pids, ///< If other service is in service loss, ETV pids from  Insertion will be taken
    eAdSvcUseDummyETV_Pids ///< Create placeholders in PMT for EISS and EBIF pids
  };
   
  struct ETV_Insertion_Settings_t
  {
    eETV_InsertionChannel_Mode_t  ETV_Insertion_Mode;
    IPS_RefSvc_t                  ETV_OtherSvc;  ///< Only applicable if primary mode is eUseOtherServiceETV_Pids
  };   
  
  struct ETV_ManipulationSettings_t
  {
    IPS_RefSvc_t              OutputSvc;  ///< Reference to the output service
    ETV_Primary_Settings_t    ETV_Primary_Settings;
    ETV_Insertion_Settings_t  ETV_Insertion_Settings;
  };
    
  /// A sequence of ETV_ManipulationSettings_t.
  typedef sequence<ETV_ManipulationSettings_t> ETV_ManipulationSettings_List_t;
    
    // ETV IDLs
    ////////////////////////////////////////////// 
    
    /** Apply ETV Manipulation settings to a number of output services.
     *
     * ETV Manipulation can only be enabled if DPI mode is SCTE30.
     * 
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the TS.
     * @param[in] ETV_ManipulationSettings_List A list of ETV_ManipulationSettings_t with the option to enable on each service
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @exception OperationFailed 
     * - invalid board/port.
     * - when trying to enable on an output service where DPI mode is not set to SCTE30.
     *
     * @version Release 9.0 
     **/
    void ETV_ManipulationSettings_SetL(in IPS_RefTS_t RefTS, in ETV_ManipulationSettings_List_t ETV_ManipulationSettings_List)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Get the current settings for ETV Manipulation.
     *
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the TS.
     * @param[in] OutputSidList A list of Service ID's to get info about. If empty, info about all services is returned.
     * 
     * @return List of ETV_ManipulationSettings_t entries
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @exception OperationFailed invalid board/port.
     *
     * @version Release 9.0 
     **/
    ETV_ManipulationSettings_List_t ETV_ManipulationSettings_GetL(in IPS_RefTS_t RefTS, in ServiceIdList_t OutputSidList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);      

    /** Get the default settings for ETV Manipulation.
     *
     * @param[in]  BoardNbr  Board number where the default will be retrieved from.
     * @param[out] ETV_PidsBlocked Indicates whether ETV pids are blocked by default (true) or not (false).
     * 
     * @return 
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     *
     * @version Release 9.0 
     **/
    void ETV_GetDefaultSettings(in unsigned short BoardNbr, out boolean ETV_PidsBlocked)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);
      
    /** Set the default settings for ETV Manipulation.
     *
     * @param[in] BoardNbr  Board number where the default shall be set.
     * @param[in] ETV_PidsBlocked Indicates whether ETV pids should be blocked by default (true) or not (false).
     * 
     * @return 
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     *
     * @version Release 9.0 
     **/
    void ETV_SetDefaultSettings(in unsigned short BoardNbr, in boolean ETV_PidsBlocked)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    // ETV IDLs supporting EISS merging
    ////////////////////////////////////////////// 
   
    enum eETV_PrimaryChannel_Mode_V2_t
    {
      eMainSvc_V2_BlockETV_Pids, ///< No ETV pids at output at all times
      eMainSvc_V2_UsePrimaryServiceETV_Pids, ///< Default mode : pass ETV pid from primary service
      eMainSvc_V2_UseOtherServiceETV_Pids, ///< Only if other service is in service loss, ETV pids from primary will be taken
      eMainSvc_V2_UseDummyETV_Pids, ///< Create placeholders in PMT for EISS and EBIF pids
      eMainSvc_V2_MergeEISS_Pids, ///< Merge the content of the EISS of another service into the EISS of the primary service.
      eMainSvc_V2_Reserved1, ///< For future use
      eMainSvc_V2_Reserved2, ///< For future use
      eMainSvc_V2_Reserved3, ///< For future use
      eMainSvc_V2_Reserved4, ///< For future use
      eMainSvc_V2_Reserved5  ///< For future use
    };
     
    struct ETV_Primary_Settings_V2_t
    {
      eETV_PrimaryChannel_Mode_V2_t ETV_Primary_Mode;
      IPS_RefSvc_t     ETV_OtherSvc;  ///< Only applicable if primary mode is eMainSvc_V2_UseOtherServiceETV_Pids
                                      ///  or eMainSvc_V2_MergeEISS_Pids
      unsigned short   EISS_Pid;  ///< Only applicable if primary mode is eUseDummyETV_Pids
      unsigned short   EBIF_Pid;  ///< Only applicable if primary mode is eUseDummyETV_Pids
    };
    
    enum eETV_InsertionChannel_Mode_V2_t
    {
      eAdSvc_V2_UseInsertionServiceETV_Pids, ///< Default mode : pass ETV pid from insertion service  during splice
      eAdSvc_V2_UsePrimaryServiceETV_Pids, ///< During splice, keep passing ETV pid from primary service
      eAdSvc_V2_UseOtherServiceETV_Pids, ///< If other service is in service loss, ETV pids from Insertion will be taken
      eAdSvc_V2_UseDummyETV_Pids, ///< Create placeholders in PMT for EISS and EBIF pids
      eAdSvc_V2_MergeEISS_Pids, ///< For future use. Merge the content of the EISS of another service into the EISS of the insertion.
      eAdSvc_V2_Reserved1, ///< For future use
      eAdSvc_V2_Reserved2, ///< For future use
      eAdSvc_V2_Reserved3, ///< For future use
      eAdSvc_V2_Reserved4, ///< For future use
      eAdSvc_V2_Reserved5  ///< For future use
    };
      
    struct ETV_Insertion_Settings_V2_t
    {
      eETV_InsertionChannel_Mode_V2_t  ETV_Insertion_Mode;
      IPS_RefSvc_t     ETV_OtherSvc;  ///< Only applicable if primary mode is eAdSvc_V2_UseOtherServiceETV_Pids
                                      ///  or eAdSvc_V2_MergeEISS_Pids.
    };   
      
    struct ETV_ManipulationSettings_V2_t
    {
      IPS_RefSvc_t                OutputSvc;  ///< Reference to the output service
      ETV_Primary_Settings_V2_t   ETV_Primary_Settings;
      ETV_Insertion_Settings_V2_t ETV_Insertion_Settings;
    };
    
    /// A sequence of ETV_ManipulationSettings_V2_t.
    typedef sequence<ETV_ManipulationSettings_V2_t> ETV_ManipulationSettings_List_V2_t;
        
    /** Apply ETV Manipulation settings to a number of output services.
     *
     * ETV Manipulation can only be enabled if DPI mode is SCTE30.
     * 
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the TS.
     * @param[in] ETV_ManipulationSettings_List A list of ETV_ManipulationSettings_V2_t with the option to enable 
     *                                          on each service
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @exception OperationFailed 
     * - invalid board/port.
     * - when trying to enable on an output service where DPI mode is not set to SCTE30.
     * - when invalid combination of parameters are used.
     *
     * @version Release 10.0 
     **/
    void ETV_ManipulationSettings_SetL_V2(in IPS_RefTS_t RefTS, 
                                          in ETV_ManipulationSettings_List_V2_t ETV_ManipulationSettings_List)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);
    
    /** Get the current settings for ETV Manipulation.
     *
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the TS.
     * @param[in] OutputSidList A list of Service ID's to get info about. If empty, info about all services is returned.
     * 
     * @return List of ETV_ManipulationSettings_V2_t entries
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @exception OperationFailed invalid board/port.
     *
     * @version Release 10.0 
     **/
    ETV_ManipulationSettings_List_V2_t ETV_ManipulationSettings_GetL_V2(in IPS_RefTS_t RefTS, 
                                                                        in ServiceIdList_t OutputSidList)
    raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);
    
    
    typedef sequence<octet> AppInstanceId_t;
    struct ETV_ApplicationIdent_t
    {
      unsigned long OrgId;
      unsigned short AppId; // valid range: 0-0xFFFD. 0xFFFF for all applications within an OrgId
      AppInstanceId_t AppInstanceId; ///< Reseved for future use. Must be empty sequence
      unsigned long StartTime; ///< Reseved for future use. Must be 0.
      unsigned long EndTime;///< Reseved for future use. Must be 0xFFFFFFFF.
      
    };
    typedef sequence<ETV_ApplicationIdent_t> ETV_ApplicationIdent_List_t;

    struct ETV_EissFilter_t
    {
      IPS_RefSvc_t OutputSvc;  ///< Reference to the output service
      boolean EnableFilter;    ///< if true, the filter is enabled
      boolean WhiteList;       ///< if true, the filter list is a white list and others are blocked
      ETV_ApplicationIdent_List_t Filter;
    };
    typedef sequence<ETV_EissFilter_t> ETV_EissFilter_List_t;


    /** Apply ETV EISS filter settings to a number of output services.
     *
     * 
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the TS.
     * @param[in] ETV_EissFilter_List A list of ETV_EissFilter_t with fiter options per service
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @exception OperationFailed 
     * - invalid board/port.
     * - when invalid combination of parameters are used.
     *
     * @version Release 10.10 
     **/
    void ETV_EissFilter_SetL(in IPS_RefTS_t RefTS, in ETV_EissFilter_List_t ETV_EissFilter_List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);
    
    /** Get the current settings for ETV EISS filters.
     *
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the TS.
     * @param[in] OutputSidList A list of Service ID's to get info about. If empty, info about all services is returned.
     * 
     * @return List of ETV_EissFilter_List_t entries
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @exception OperationFailed invalid board/port.
     *
     * @version Release 10.0 
     **/
    ETV_EissFilter_List_t ETV_EissFilter_GetL(in IPS_RefTS_t RefTS, 
                                              in ServiceIdList_t OutputSidList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

 
       
    // DPI IDLs
    //////////////////////////////////////////////
    
    /** Defines the minimum time required between the reception of a splicerequest and the actual splice moment.
     * 
     * @param[in] RefPhys The Slot (and Port) to apply the call on.
     * @param[in] SpliceRequestTime Defines the minimum time.
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @deprecated Obsoleted in release 11.0
     */
    void DPI_SRT_Set(in IPS_Ref_t RefPhys, in DPI_SpliceRequestTime_t SpliceRequestTime) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get the currently set minimum time required between the reception of a splicerequest and the actual splice moment.
     * 
     * @param[in] RefPhys The Slot (and Port) to apply the call on.
     * 
     * @return SpliceRequestTime: Contains the minimum time.
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @deprecated Obsoleted in release 11.0
     */
    DPI_SpliceRequestTime_t DPI_SRT_Get(in IPS_Ref_t RefPhys) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Trigger a splice request in manual mode for a spliceable channel.
     * 
     * @param[in] RefPhys The Slot (and Port) to apply the call on.
     * @param[in] SpliceRequest Defines which channel should be spliced, when and for how long.
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @exception OpNotSucceeded In case of
     * - Invalid references (Channelname does not exist on this board).
     * - Channel not in manual mode.
     * @exception LicenseError In case of
     * - No licenses available (for a splice-in request, splice-out is accepted even when no license available)
     */
    void DPI_SpliceRequest(in IPS_Ref_t RefPhys, in DPI_SpliceRequest_t SpliceRequest) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);
    
    /** Reset the DPI Scheduler statistics.
     *
     * 
     * @param[in] SlotNbr  The slot number on which the statitics should be reset.
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @exception OpNotSucceeded When particular slot does not support splicing. 
     * - invalid board.
     *
     * @version Release 11.10 
     **/        
    void DPI_ResetStatistics(in unsigned short SlotNbr) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
   
    /** Add new splice-able channels or change the settings of existing channels.
     * 
     * @param[in] RefPhys The Slot (and Port) to apply the call on.
     * @param[in] ChannelSettingsList Defines a list of splice-able channels with their settings.
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @exception OpNotSucceeded In case of
     * - Invalid references (PrimaryTS refers to a stream not available on the output, non-existing mode,...).
     */
    void DPI_ChannelSetL(in IPS_Ref_t RefPhys, in DPI_ChannelSettings_List_t ChannelSettingsList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Add new splice-able channels or change the settings of existing channels.
     *
     * This call includes channel status fields.
     *
     * @param[in] RefPhys The Slot (and Port) to apply the call on.
     * @param[in] ChannelSettingsList Defines a list of splice-able channels with their settings.
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @exception OpNotSucceeded In case of
     * - Invalid references (PrimaryTS refers to a stream not available on the output, non-existing mode,...).
     */
    void DPI_ChannelSetL2(in IPS_Ref_t RefPhys, in DPI_ChannelSettings2_List_t ChannelSettingsList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Add new splice-able channels or change the settings of existing channels.
     *
     * This call includes channel status fields.
     *
     * @param[in] RefPhys The Slot (and Port) to apply the call on.
     * @param[in] ChannelSettingsList Defines a list of splice-able channels with their settings.
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @exception OpNotSucceeded In case of
     * - Invalid references (PrimaryTS refers to a stream not available on the output, non-existing mode,...).
     * @exception OutOfRange     In case of
     * - Invalid SpliceDelay
     */
    void DPI_ChannelSetL3(in IPS_Ref_t RefPhys, in DPI_ChannelSettings3_List_t ChannelSettingsList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OutOfRange);

    /** Get a list of all splice-able channels which are part of a specific output TS.
     * 
     * @param[in] RefPhys The Slot (and Port) to apply the call on.
     * @param[in] RefTS The Slot, Port and Index of the output TS.
     * 
     * @return DPI_ChannelSettings_List_t: List of settings of splice-able channels.
     * 
     * @exception OpNotSupported 
     * - When BoardNumber = 0 = Main board.
     * @exception OpNotSucceeded
     * - When the TS contains a seamless alternates output service.
     * 
     * @note An incorrect RefTS will lead to an empty list being returned.
     */
    DPI_ChannelSettings_List_t DPI_ChannelGetL(in IPS_Ref_t RefPhys, in IPS_RefTS_t RefTS) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get a list of all splice-able channels which are part of a specific output TS.
     * 
     * This call includes channel status fields.
     *
     * @param[in] RefPhys The Slot (and Port) to apply the call on.
     * @param[in] RefTS The Slot, Port and Index of the output TS.
     * 
     * @return DPI_ChannelSettings_List2_t: List of settings of splice-able channels.
     * 
     * @exception OpNotSupported 
     * - When BoardNumber = 0 = Main board.
     * @exception OpNotSucceeded
     * - When the TS contains a seamless alternates output service.
     * 
     * @note An incorrect RefTS will lead to an empty list being returned.
     * @note RefTS == 0xFFFFFFFF will return ALL splice-able channels on the board (R2.5 and higher only).
     */
    DPI_ChannelSettings2_List_t DPI_ChannelGetL2(in IPS_Ref_t RefPhys, in IPS_RefTS_t RefTS) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get a list of all splice-able channels which are part of a specific output TS.
     * 
     * This call includes channel status fields.
     *
     * @param[in] RefPhys The Slot (and Port) to apply the call on.
     * @param[in] RefTS The Slot, Port and Index of the output TS.
     * 
     * @return DPI_ChannelSettings_List3_t: List of settings of splice-able channels.
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * 
     * @note An incorrect RefTS will lead to an empty list being returned.
     * @note RefTS == 0xFFFFFFFF will return ALL splice-able channels on the board (R2.5 and higher only).
     */
    DPI_ChannelSettings3_List_t DPI_ChannelGetL3(in IPS_Ref_t RefPhys, in IPS_RefTS_t RefTS) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get current status information of all specified splice-able channels.
     * 
     * @param[in] RefPhys The Slot (and Port) to apply the call on.
     * @param[in] ChannelStatusList Defines a list of splice-able channels.
     * 
     * @return DPI_ChannelStatus_List_t: Status info of splice-able channels.
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * 
     * @note An incorrect RefTS will lead to an empty list being returned.
     * @note RefTS == 0xFFFFFFFF will return ALL splice-able channels on the board (R2.5 and higher only).
     */
    DPI_ChannelStatus_List_t DPI_ChannelStatusL(in IPS_Ref_t RefPhys, in DPI_ChannelStatus_List_t ChannelStatusList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Delete a list of splice-able channels.
     * 
     * @param[in] RefPhys The Slot (and Port) to apply the call on.
     * @param[in] ChannelSettingsList Defines a list of splice-able channels.
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     */
    void DPI_ChannelDeleteL(in IPS_Ref_t RefPhys, in DPI_ChannelSettings_List_t ChannelSettingsList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Delete a list of splice-able channels.
     * 
     * @param[in] RefPhys The Slot (and Port) to apply the call on.
     * @param[in] ChannelSettingsList Defines a list of splice-able channels.
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     */
    void DPI_ChannelDeleteL3(in IPS_Ref_t RefPhys, in DPI_ChannelSettings3_List_t ChannelSettingsList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get the custom splice couples
     * @param[in] RefPhys The board to apply the call on
     * @param[in] channel The channelname to get the couples from
     * @param[out] couples The list of couples
     * 
     * @exception OpNotSucceeded invalid board/port, channelname doesn't exist or has non-custom mode
     */
    void DPI_GetSpliceCouples(in IPS_Ref_t RefPhys, in DPI_ChannelName_t channel, out DPI_PidCoupleList_t couples) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the custom splice couples
     * 
     * @param[in] RefPhys The board to apply the call on.
     * @param[in] channel The channelname to set the couples for.
     * @param[in] couples The couples to set.
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @exception OpNotSucceeded 
     * - invalid board/port 
     * - channelname doesn't exist or has non-custom mode 
     * - couples specify a Main PID twice 
     * - Ad PID entered for PassMain rule
     * - When trying to set on a seamless alternates channel
     */
    void DPI_SetSpliceCouples(in IPS_Ref_t RefPhys, in DPI_ChannelName_t channel, in  DPI_PidCoupleList_t couples) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set Pmt Splice Mode for given channels.
     * 
     * @param[in] RefPhys Indicates the board the channel(s) sit on. (The port is ignored.)
     * @param[in] lst 
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @exception OpNotSucceeded
     * - invalid board.
     * - channelname doesn't exist.
     * - try to set Generated when in 30/35 mode.
	 * - when trying to call on a seamless alternates output service
     *
     * @remark A channel that is switched to 30/35 mode through DPI_ChannelSetL() is set to FollowPrimary automatically.
     **/
    void DPI_PmtSpliceModeSetL(in IPS_Ref_t RefPhys, in DPI_PmtSpliceModeSettingList_t lst) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get Pmt Splice Mode for given TS('s).
     * 
     * @param[in] RefTS Indicates the board, port, TS (the latter two allow wild cards).
     * @param[out] lst 
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @exception OpNotSucceeded invalid board/port.
     **/
    void DPI_PmtSpliceModeGetL(in IPS_RefTS_t RefTS, out DPI_PmtSpliceModeSettingList_t lst) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    struct ClearPidBitrates_t {
      IPS_Service_t SvcOut;
        boolean ClearPidBitrates;
    };

    /// A sequence of ServiceBlockCAInfo_t entries
    typedef sequence<ClearPidBitrates_t> ClearPidBitratesList_t;


    /** Clear pid bitrates from the main Service if the pid is not spliced.
     *
     * It is possible the the main service has more pids then the service it is spliced with.
     * If this feature is enabled, then the bitrate of these extra pids will be set to zero
     * during the splice.
     * 
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the TS.
     * @param[in] ClearPidBitratesList A list of ClearPidBitrates_t with the option to set on each service
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @exception OpNotSucceeded 
     * - invalid board/port.
     * - when trying to set on a seamless alternates output service.
     *
     * @version Release 6.9 
     **/
    void DPI_ClearPidBitratesSetL(in IPS_RefTS_t RefTS, in ClearPidBitratesList_t ClearPidBitratesList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the current setting for Clear Pid Bitrates.
     *
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the TS.
     * @param[in] OutputSidList A list of Service ID's to get info about. If empty, info about all services is returned.
     * 
     * @return List of ClearPidBitrates_t entries
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @exception OpNotSucceeded invalid board/port.
     *
     * @version Release 6.9 
     **/
    ClearPidBitratesList_t DPI_ClearPidBitratesGetL(in IPS_RefTS_t RefTS, in ServiceIdList_t OutputSidList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    struct AddPidsFromSplice_t {
      IPS_Service_t SvcOut;
        boolean AddPidsFromSplice;
    };

    /// A sequence of ServiceBlockCAInfo_t entries
    typedef sequence<AddPidsFromSplice_t> AddPidsFromSpliceList_t;


    /** Add pids from the splice if there are more pids in the splice than in the main service.
     *
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the TS.
     * @param[in] AddPidsFromSpliceList A list of AddPidsFromSplice_t with the option to set on each service
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @exception OpNotSucceeded 
     * - invalid board/port.
     * - When trying to set on a seamless alternates output service.
     *
     * @version Release 6.9 
     **/
    void DPI_AddPidsFromSpliceSetL(in IPS_RefTS_t RefTS, in AddPidsFromSpliceList_t AddPidsFromSpliceList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the current setting for AddPidsFromSplice.
     *
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the TS.
     * @param[in] OutputSidList A list of Service ID's to get info about. If empty, info about all services is returned.
     * 
     * @return List of AddPidsFromSplice_t entries
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @exception OpNotSucceeded invalid board/port.
     *
     * @version Release 6.9 
     **/
    AddPidsFromSpliceList_t DPI_AddPidsFromSpliceGetL(in IPS_RefTS_t RefTS, in ServiceIdList_t OutputSidList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * A definition of an alternate source
     */
    struct AlternateSource_t {
      IPS_Service_t SvcSource;
      AlternateSrcId_t AlternateSrcId;   ///< the ID of this alternate source (read-only)
    };

    /// A sequence of AlternateSource_t entries
    typedef sequence< AlternateSource_t> AlternateSourceList_t;

    /// All the settings concerning alternate sources for one output service
    struct AlternateSourceSettings_t {
      AlternateSourceList_t AlternateSources; ///< A list of all the alternate sources
      AlternateSrcId_t MainSourceId; ///< the ID of the main source (this is initially the original source) (read-only)
      AlternateSrcId_t ActiveSourceId; ///< the ID of the currently active source (read-only)
      AlternateSrcId_t InsertionSourceId; ///< The ID of the insertion source (0xFFFFFFFF if none is present) (read-only)
    };

    /**
     * Add alternate source settings to an output service
     *
     * @param [in] SvcOut The output service on which the settings should be applied
     * @param [in] AlternateSourceList the settings
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case
     * - invalid input references are used (SvcOut).
     *
     * @note Existing alternate sources are untouched
     *
     * @version Release 7.1
     */
    void AlternateSourcesAdd(in IPS_Service_t SvcOut, in AlternateSourceList_t AlternateSourceList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * Get the alternate source settings for a specific output service.
     *
     * All alternate sources will be returned. Also the main source and a possible alternate source
     *
     * @param [in] SvcOut The output service of which settings are requested
     * @param [out] AlternateSourceSettings the settings
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid input references are used (SvcOut).
     *
     * @version Release 7.1
     */
    void  AlternateSourcesGet(in IPS_Service_t SvcOut, out AlternateSourceSettings_t AlternateSourceSettings)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /**
     * Delete alternate source settings for output services.
     *
     * @param [in] SvcOut The SvcOut on which the settings should be applied
     * @param [in] AlternateSrcIdList A list of IDs of alternate sources that should be deleted.
     *             If empty, then all alternate sources for this Output Service will be deleted,
     *             except for the Main, the Active and the Insertion Svc.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case
     * - invalid input references are used (SvcOut)
     * - the main source is requested for deletion
     * - the active source is requested for deletion
     * - the insertion source is requested for deletion
     *
     * @version Release 7.1
     */
    void AlternateSourcesDelete(in IPS_Service_t SvcOut, in AlternateSrcIdList_t AlternateSrcIdList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * Set a specific alternate source as active.
     *
     * @param [in] SvcOut The ouput service where the alternate source is located
     * @param [in] AlternateSrcId The ID of the alternate source that must be activated
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case
     * - The SvcOut is invalid
     * - the alternate source ID is not existing
     * @exception LicenseError for a seamless alternate output service that has no license.
     *
     * @version Release 7.1
     */
    void SwitchToAlternateSource(in IPS_Service_t SvcOut, in AlternateSrcId_t AlternateSrcId)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);


    enum eScte35Source 
    {
      eScte35Source_Active,
      eScte35Source_Insertion,
      eScte35Source_Other
    };

    struct Scte35Source_t {
      IPS_Service_t SvcOut;
      eScte35Source Scte35Source;  ///< The source of which the SCTE35 messages
                                   ///< should be processed
      AlternateSrcId_t OtherSrcId; ///< the ID of this alternate source,
                                   ///< if Scte35Source == other
    };

    /// A sequence of Scte35Source_t entries
    typedef sequence< Scte35Source_t > Scte35SourceList_t;

    /** Set the SCTE35 Source settings
     *
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the TS.
     * @param[in] Scte35SourceList A list of SCTE35 source settings
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @exception OpNotSucceeded invalid board/port.
     *
     * @version Release 7.1
     **/
    void DPI_Scte35SourceSetL(in IPS_RefTS_t RefTS, in Scte35SourceList_t Scte35SourceList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the current SCTE35 Source settings.
     *
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the TS.
     * @param[in] OutputSidList A list of Service ID's to get info about. If empty, info about all services is returned.
     *
     * @return List of Scte35OutOfNetworkList_t entries
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @exception OpNotSucceeded invalid board/port.
     *
     * @version Release 7.1
     **/
    Scte35SourceList_t DPI_Scte35SourceGetL(in IPS_RefTS_t RefTS, in ServiceIdList_t OutputSidList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    struct Scte35ToggleOutOfNetwork_t {
      IPS_Service_t SvcOut;
      boolean ToggleOutOfNetwork;  ///< Set to True if the out_of_network_indicator bit should be toggled
    };

    /// A sequence of Scte35ToggleOutOfNetwork_t entries
    typedef sequence< Scte35ToggleOutOfNetwork_t > Scte35ToggleOutOfNetworkList_t;

    /** Set the SCTE35 Toggle Out Of Network settings
     *
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the TS.
     * @param[in] Scte35ToggleOutOfNetworkList A list of SCTE35 toggle settings
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @exception OpNotSucceeded invalid board/port.
     *
     * @version Release 7.1
     **/
    void DPI_Scte35ToggleOutOfNetworkSetL(in IPS_RefTS_t RefTS, in Scte35ToggleOutOfNetworkList_t Scte35ToggleOutOfNetworkList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the SCTE35 Toggle Out Of Network settings
     *
     * @param[in] RefTS A BoardNr, PortNr and Ref specifying the TS.
     * @param[in] OutputSidList A list of Service ID's to get info about. If empty, info about all services is returned.
     *
     * @return List of Scte35ToggleOutOfNetwork_t entries
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board.
     * @exception OpNotSucceeded invalid board/port.
     *
     * @version Release 7.1
     **/
    Scte35ToggleOutOfNetworkList_t DPI_Scte35ToggleOutOfNetworkGetL(in IPS_RefTS_t RefTS, in ServiceIdList_t OutputSidList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

#endif // DISABLE_TRANSRATER
    /// @} end of dpi
        
#ifndef DISABLE_GBE   
    /** @defgroup gbe GBE
     * This group contains modules specific for GbE boards.
     * @{
     */
    
    /** @defgroup rtp RTP
     * This module contains types, enums and methods related to RTP (Real-Time Protocol).
     * RTP info can help the receiver to maintain QoS. See also @ref fec.
     * RTP is a (Out)TS level feature . 
     * @{
     */
    enum eRTP
    {
      eRTP_OFF, ///< No RTP headers in packets
      eRTP_ON   ///< RTP headers in packets 
    };

    struct IPS_OutTS_RTP_t
    {
      IPS_RefTS_t Ref;
      eRTP RTPOnOff;
    };

    typedef sequence <IPS_OutTS_RTP_t> IPS_OutTS_RTP_List_t;

    /** Set RTP setting for some OutTS
     * 
     * @param[in] RefPhys The port the OutTS are attached to. 
     *            ANY_PORT is NOT allowed
     * @param[in] RTPList List of RefTs/eRTP pairs
     * 
     * 
     * @exception OpNotSupported When called for mainboard.
     * @exception OpNotSucceeded In case of
     * - Called for an non-GbE I/O board (asi)
     * - RefPhys does not exist
     * - RefTs does not match RefPhys
     * - eRTP invalid
     * - Disabling RTP while FEC encoding is enabled
     */
    void OutTS_RTP_SetL(in IPS_Ref_t RefPhys, in IPS_OutTS_RTP_List_t RTPList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get RTP setting for some OutTS
     * 
     * @param[in] RefPhys The port the OutTS are attached to.
     *        ANY_PORT is NOT allowed 
     * @param[in] TSList List of Referenced of OutputTs for which to return the RTP Setting. Empty list=all OutTS attached to RefPhys
     * @param[out] RTPList
     *
     * @return RTPList List of RefTs/eRTP pairs
     * 
     * @exception OpNotSupported When called for mainboard.
     * @exception OpNotSucceeded In case of
     * - Called for an non-GbE I/O board (asi)
     * - RefPhys does not exist
     * - RefTs does not match RefPhys
     */
    void OutTS_RTP_GetL (in IPS_Ref_t RefPhys, in IPS_RefTS_List_t TSList, out IPS_OutTS_RTP_List_t RTPList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set default RTP setting to be used for new OutTS.
     * Default is attached to a board.
     * 
     * @param[in] RefPhys Identifies the bord.
     * @param[in] RTPOnOff The default
     *
     * @exception OpNotSupported When called for mainboard.
     * @exception OpNotSucceeded In case of
     * - Called for an non-GbE I/O board (asi)
     * - RTPOnOff invalid
     * - Default disabling RTP while FEC encoding is default enabled
     */
    void SetDefault_RTP(in IPS_Ref_t RefPhys, in eRTP RTPOnOff)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get default RTP setting used for new OutTS.
     * Default is attached to a board.
     * 
     * @param[in] RefPhys Identifies the bord.
     * @param[out] RTPOnOff
     * 
     * @return RTPOnOff The default
     * 
     * @exception OpNotSupported When called for mainboard.
     * @exception OpNotSucceeded In case of
     * - Called for an non-GbE I/O board (asi)
     */
    void GetDefault_RTP(in IPS_Ref_t  RefPhys, out eRTP RTPOnOff)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** @} end of rtp */
    /** @defgroup vlan VLAN
     * This module contains types, enums and methods related to VLAN (Virtual LAN).
     * VLAN is an ethernet feature to create independent logical networks within a physical network.
     * VLAN is a (Out)TS level feature . 
     * @{
     */
    enum eVLAN
    {
      eVLAN_OFF, ///<no VLAN headers in packets
      eVLAN_ON   ///<VLAN headers present in packets
    };

    struct VLAN_Settings_t
    {
      eVLAN VLANOnOff; 
      /** range: 0-4094 12 bit, 0x0FFF not allowed, 
       *    0=no vlan id, only priority (ieee 802.1Q)) 
       */
      unsigned short VLANID; 
      /** range: 0-7  0=default 1=low 7=high (ieee 802.1D) */
      unsigned short Priority;
    };

    struct OutTS_VLAN_t
    {
      IPS_RefTS_t RefTs;
      VLAN_Settings_t  VLAN;
    };

    typedef sequence<OutTS_VLAN_t> OutTS_VLAN_List_t;

    /** Set VLAN settings for some OutTS.
     * 
     * @param[in] RefPhys The port the OutTS are attached to. 
     *            ANY_PORT allowed
     * @param[in] VLANList List of RefTs/VLAN_Settings pairs
     *
     * @exception OpNotSupported When the board is not a GbE board, IP Video Adapter board or IP Audio Gateway board.
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist (or is a backup port)
     * - VLAN_Settings out of range
     * - RefTs does not match RefPhys
     */
    void OutTS_VLAN_SetL(in IPS_Ref_t RefPhys, in OutTS_VLAN_List_t VLANList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get VLAN settings for some OutTS.
     * 
     * @param[in] RefPhys The port the OutTS are attached to. 
     *            ANY_PORT allowed.
     * @param[in] RefTsList List of Referenced of OutTS for which to return the VLAN Settings. Empty list=all OutTs attached to RefPhys
     * @param[out] VLANList
     * 
     * @return VLANList List of RefTs/VLAN_Settings pairs
     *
     * @exception OpNotSupported When the board is not a GbE board, IP Video Adapter board or IP Audio Gateway board.
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist (or is a backup port)
     * - RefTs does not match RefPhys
     */
    void OutTS_VLAN_GetL (in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList, out OutTS_VLAN_List_t VLANList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Set default VLAN settings to be used for new OutTS.
     * Defaults are attached to a (logical) port.
     * 
     * @param[in] RefPhys Identifies the port. No wildcards allowed.
     * @param[in] VLAN_Settings The defaults
     *
     * @exception OpNotSupported When called for other boards than GbE ones (Main, asi, ..).
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist (or is a backup port)
     * - VLAN_Settings out of range
     */
    void SetDefault_VLAN(in IPS_Ref_t RefPhys, in VLAN_Settings_t VLAN_Settings)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get default VLAN settings that are used for new OutTS.
     * Defaults are attached to a (logical) port.
     *
     * @param[in] RefPhys Identifies the port. No wildcards allowed.
     * @param[out] VLAN_Settings
     *
     * @return VLAN_Settings The defaults
     *
     * @exception OpNotSupported When called for other boards than GbE ones (Main, asi, ..).
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist (or is a backup port)
     */
    void GetDefault_VLAN(in IPS_Ref_t  RefPhys, out VLAN_Settings_t VLAN_Settings)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    
    /** @} end of vlan */
  
    /** @defgroup tos TOS
      * This module contains types, enums and methods related to TOS (Type of Service).
      * TOS is an IP header field to identify the QOS.
      * TOS is a (Out)TS level feature that can be configured. 
      * @{
      */
 
    struct OutTS_TOS_t
    {
      IPS_RefTS_t    RefTs;
      unsigned short TOS_Value;
    };

    typedef sequence<OutTS_TOS_t> OutTS_TOS_List_t;

    /** Set TOS settings for some OutTS.
     * 
     * @param[in] RefPhys    The port the OutTS are attached to. 
     * @param[in] TOS_List   List of RefTs/TOS_Value pairs
     *
     * @exception OpNotSupported When the board is not a GbE board, IP Video Adapter board or IP Audio Gateway board.
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist (or is a backup port)
     * - TOS_Value out of range (accepted range is 0-255)
     * - RefTs does not match RefPhys
     */
    void OutTS_TOS_SetL(in IPS_Ref_t RefPhys, in OutTS_TOS_List_t TOS_List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get TOS settings for some OutTS.
     * 
     * @param[in] RefPhys    The port the OutTS are attached to. 
     * @param[in] RefTsList  List of Referenced of OutTS for which to return the TOS Settings. Empty list=all OutTs attached to RefPhys
     * @param[out] TOS_List
     * 
     * @return TOS_List List of RefTs/TOS_Value pairs
     *
     * @exception OpNotSupported When the board is not a GbE board, IP Video Adapter board or IP Audio Gateway board.
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist (or is a backup port)
     * - RefTs does not match RefPhys
     */
    void OutTS_TOS_GetL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList, out OutTS_TOS_List_t TOS_List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Set default TOS settings to be used for new OutTS.
     * Defaults are attached to a board.
     * 
     * @param[in] Board      Specifies the board
     * @param[in] TOS_Value  The default
     *
     * @exception OpNotSupported When called for other boards than GbE ones (Main, asi, ..).
     * @exception OpNotSucceeded In case of
     * - When the mainboard is supplied 
     * - TOS_Value out of range (accepted range is 0-255)
     */
    void SetDefault_TOS(in unsigned short Board, in unsigned short TOS_Value)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get default TOS settings that are used for new OutTS.
     * Defaults are attached to a board.
     *
     * @param[in]  Board      Specifies the board
     * @param[out] TOS_Value  The default
     *
     * @return TOS_Value The default
     *
     * @exception OpNotSupported When called for other boards than GbE ones (Main, asi, ..).
     * @exception OpNotSucceeded In case of
     * - When the mainboard is supplied
     */
    void GetDefault_TOS(in unsigned short Board, out unsigned short TOS_Value)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** @} end of tos */

    /** @defgroup srcIpUdp Source Ip/Udp
      * This module contains types, enums and methods related to set the source ip and or udp port of an outgoing transport stream
      * @{
      */

    /**
     * Structure to specify some Ip header parameters for outgoing GbE packets. 
     */
    struct SrcAddr_t
    {
      /**
       * If this flag is true, the ip address of the port is used as source ip address. Otherwise, m_Ip applies 
       */
      boolean m_bUsePortIp;
      /** 
       * This field has no effect if m_bUsePortIp is true.
       * If this Ip address is used, it is used for both normal packets and fec packets, both main and backup.
       * Must be a valid unicast address.
       */
      string m_Ip;
      /**
       * The Port Number to use as source udp port. Always applicable, m_bUsePortIp has no effect.
       */
      unsigned short m_UdpPort;
    };

    /**
     * Source Address parameters for an OutTS. Used for all ports in a portset, both mpeg streams and fec streams. 
     */
    struct OutTS_SrcAddr_t
    {
      IPS_RefTS_t m_RefTs;
      SrcAddr_t   m_SrcAddr;
    };

    typedef sequence<OutTS_SrcAddr_t> OutTS_SrcAddr_List_t;

    struct OutTS_SrcAddr_V2_t
    {
      IPS_RefTS_t m_RefTs;
      SrcAddr_t   m_SrcAddr;
      boolean     m_DynamicSrcUdpPort;
    };

    typedef sequence<OutTS_SrcAddr_V2_t> OutTS_SrcAddr_V2_List_t;


    /** Set Source Address settings for some OutTS.
     * 
     * @param[in] RefPhys    The port the OutTS are attached to. 
     * @param[in] SrcAddr_List   List of RefTs/SrcAddr pairs
     *
     * @exception OpNotSupported When the board is not a GbE board, IP Video Adapter board or IP Audio Gateway board.
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist (or is a backup port)
     * - SrcAddr is invalid.
     * - RefTs does not match RefPhys
     */
    void OutTS_SrcAddr_SetL(in IPS_Ref_t RefPhys, in OutTS_SrcAddr_List_t SrcAddr_List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    void OutTS_SrcAddr_V2_SetL(in IPS_Ref_t RefPhys, in OutTS_SrcAddr_V2_List_t SrcAddr_List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get Source Address settings for some OutTS.
     * 
     * @param[in] RefPhys    The port the OutTS are attached to. 
     * @param[in] RefTsList  List of References of OutTs for which to return the SrcAddr Settings. Empty list=all OutTs attached to RefPhys
     * @param[out] SrcAddr_List List of RefTs/SrcAddr pairs
     * 
     * @exception OpNotSupported When the board is not a GbE board, IP Video Adapter board or IP Audio Gateway board.
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist (or is a backup port)
     * - RefTs does not match RefPhys
     */
    void OutTS_SrcAddr_GetL (in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList, out OutTS_SrcAddr_List_t SrcAddr_List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    void OutTS_SrcAddr_V2_GetL (in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList, out OutTS_SrcAddr_V2_List_t SrcAddr_List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** @} end of source udp/ip */


    /** @defgroup ttl TTL
      * This module contains types, enums and methods related to TTL (Time to live).
      * TTL is an IP header field.
      * TTL is a (Out)TS level feature . 
      * @{
      */
 
    struct OutTS_TTL_t
    {
      IPS_RefTS_t    RefTs;
      unsigned short TTL_Value;
    };

    typedef sequence<OutTS_TTL_t> OutTS_TTL_List_t;

    /** Set TTL settings for some OutTS.
     * 
     * @param[in] RefPhys     The port the OutTS are attached to. 
     * @param[in] TTL_List    List of RefTs/TTL_Value pairs
     *
     * @exception OpNotSupported When the board is not a GbE board, IP Video Adapter board or IP Audio Gateway board.
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist (or is a backup port)
     * - TTL_Value out of range (accepted range is [1-255]
     * - RefTs does not match RefPhys
     */
    void OutTS_TTL_SetL(in IPS_Ref_t RefPhys, in OutTS_TTL_List_t TTL_List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get TTL settings for some OutTS.
     * 
     * @param[in] RefPhys     The port the OutTS are attached to. 
     * @param[in] RefTsList   List of Referenced of OutTS for which to return the TTL Settings. Empty list=all OutTs attached to RefPhys
     * @param[out] TTL_List
     * 
     * @return TTL_List List of RefTs/TTL_Value pairs
     *
     * @exception OpNotSupported When the board is not a GbE board, IP Video Adapter board or IP Audio Gateway board.
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist (or is a backup port)
     * - RefTs does not match RefPhys
     */
    void OutTS_TTL_GetL (in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList, out OutTS_TTL_List_t TTL_List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Set default TTL settings to be used for new OutTS.
     * Defaults are attached to a board.
     * 
     * @param[in] Board       Specifies the board
     * @param[in] TTL_Value   The default
     *
     * @exception OpNotSupported When called for other boards than GbE ones (Main, asi, ..).
     * @exception OpNotSucceeded In case of
     * - When the mainboard is supplied
     * - TTL_Value out of range (accepted range is [1-255])
     */
    void SetDefault_TTL(in unsigned short Board , in unsigned short TTL_Value)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get default TTL settings that are used for new OutTS.
     * Defaults are attached to a (logical) port.
     *
     * @param[in]  Board      Specifies the board
     * @param[out] TTL_Value  The default
     *
     * @return TTL_Value The default
     *
     * @exception OpNotSupported When called for other boards than GbE ones (Main, asi, ..).
     * @exception OpNotSucceeded In case of
     * - - When the mainboard is supplied
     */
    void GetDefault_TTL(in unsigned short Board, out unsigned short TTL_Value)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** @} end of ttl */    
    
    /** @defgroup vbr VBR
     * This module contains types, enums and methods related to VBR (Variable Bitrate).
     * An OutTS can have a fixed/constant bitrate (CBR) or a variable one (VBR).
     * VBR is a (Out)TS level feature . 
     * @{
     */
    enum eVBR
    {
      eVBR_OFF, ///< CBR
      eVBR_ON   ///< VBR
    };
    
    struct OutTS_VBR_t
    {
      IPS_RefTS_t RefTs;
      eVBR VBROnOff;
    };
    typedef sequence<OutTS_VBR_t> OutTS_VBR_List_t;

    /** Set VBR setting for some OutTS.
     * 
     * @param[in] RefPhys The port the OutTS are attached to. 
     *            ANY_PORT allowed
     * @param[in] VBRList List of RefTs/eVBR pairs
     * 
     * 
     * @exception OpNotSupported When called for other boards than GbE ones (Main, asi, ..).
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist (or is a backup port)
     * - eVBR out of range
     * - RefTs does not match RefPhys
     * - VBR->CBR: Bitrate for port exceeded (VBR counts as 0)
     * - Enabling VBR while FEC encoding is enabled
     */
    void OutTS_VBR_SetL(in IPS_Ref_t RefPhys, in OutTS_VBR_List_t VBRList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get VBR setting for some OutTS.
     * 
     * @param[in] RefPhys The port the OutTS are attached to
     *        ANY_PORT allowed 
     * @param[in] RefTsList List of Referenced of OutputTs for which to return the VBR Setting. Empty list=all OutTS attached to RefPhys
     * @param[in] VBRList
     *
     * @return VBRList List of RefTs/eVBR pairs
     * 
     * @exception OpNotSupported When called for other boards than GbE ones (Main, asi, ..).
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist (or is a backup port)
     * - RefTs does not match RefPhys
     */
    void OutTS_VBR_GetL (in IPS_Ref_t RefPhys,  in IPS_RefTS_List_t RefTsList,  out OutTS_VBR_List_t VBRList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    /** Set default VBR setting to be used for new OutTS.
     * Default is attached to a board.
     * 
     * @param[in] RefPhys Identifies the bord. Only board member is used.
     * @param[in] VBROnOff The default
     *
     * @exception OpNotSupported When called for other boards than GbE ones (Main, asi, ..).
     * @exception OpNotSucceeded In case of
     * - VBROnOff invalid
     * - Default enabling VBR while FEC encoding is default enabled
     */
    void SetDefault_VBR (in IPS_Ref_t RefPhys, in eVBR VBROnOff)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get default VBR setting used for new OutTS.
     * Default is attached to a board.
     * 
     * @param[in] RefPhys Identifies the bord. Only board member is used.
     * @param[out] VBROnOff
     * 
     * @return VBROnOff The default
     * 
     * @exception OpNotSupported When called for other boards than GbE ones (Main, asi, ..).
     */
    void GetDefault_VBR (in IPS_Ref_t  RefPhys, out eVBR VBROnOff)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** @} end of vbr*/
    
    /** @defgroup udpsize UDP Size
     * This module contains types and methods related to UDP Size.
     * For a GBE OutTS each UDP packet can contain 1 to 7 MPEG packets.
     * These methods are used to change the default or the number per TS.
     * @{
     */
    struct OutTS_UdpSize_t
    {
      IPS_RefTS_t RefTs; //< Ref to TsOut (on Gbe Port)
      unsigned short UdpSize; // #mpeg packets in one Udp packet. Range: 1..7
    };

    typedef sequence<OutTS_UdpSize_t> OutTS_UdpSize_List_t;

    /** Set default UdpSize to be used for new output TSs.
     * Defaults are attached to a board.
     *
     * @param BoardNr Identifies the board.
     * @param UdpSize The default UDP Size. (1 <= size <= 7)
     *
     * @return None
     *
     * @exception OpNotSupported When called for other boards than GbE ones (Main, asi, ..).
     * @exception OpNotSucceeded In case of
     * - UdpSize out of range
     *
     * @version Release 6.5 
     */
    void SetDefault_UdpSize(in unsigned short BoardNr, in unsigned short UdpSize)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get default UdpSize that are used for new output TSs. 
     * Defaults are attached to a board.
     *
     * @param[in]  BoardNr  Identifies the board.
     * @param[out] UdpSize  The default UDP size (1 <= size <= 7)
     *
     * @exception OpNotSupported When called for other boards than GbE ones (Main, asi, ..).
     *
     * @version Release 6.5 
     */
    void GetDefault_UdpSize(in unsigned short BoardNr, out unsigned short UdpSize)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set UdpSize per output TS.
     *
     * @param RefPhys The port the output TSs are attached to.
     * @param UdpSizeList List of RefTs/UdpSize pairs
     *
     * @return None
     *
     * @exception OpNotSupported When called for other boards than GbE ones (Main, asi, ..).
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist (or is a backup port)
     * - UdpSize out of range
     * - RefTs does not match RefPhys
     *
     * @version Release 6.5 
     */
    void OutTS_UdpSize_SetL(in IPS_Ref_t RefPhys, in OutTS_UdpSize_List_t UdpSizeList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get UdpSize per output TS.
     *
     * @param RefPhys The port the output TSs are attached to.
     * @param RefTsList List of output TSs for which to return the UdpSize. 
     *                  Empty list=all output TSs attached to RefPhys.
     *
     * @param UdpList
     * @return UdpList List of RefTs/UdpSize pairs
     *
     * @exception OpNotSupported When called for other boards than GbE ones (Main, asi, ..).
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist (or is a backup port)
     * - RefTs does not match RefPhys
     *
     * @version Release 6.5 
     */
    void OutTS_UdpSize_GetL (in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList, out OutTS_UdpSize_List_t UdpList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

     /** @} end of udpsize*/
      
     /** Specifies the range of UDP ports for which traffic will be sent
     *  to the CPU instead of being processed by the firmware. This setting
     *  applies to all ports of the specified board.
     * 
     * @param[in] RefPhys      Board and port number. Port number is ignored.
     * @param[in] UDP_Boundary All incoming UDP traffic with port number below the
     *   UDP_Boundary threshold will be sent to the CPU. The default is zero,
     *   which means that all UDP traffic is processed by the firmware.
     * 
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded If RefPhys contains an invalid board or port
     *                           number.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for a non-GbE board.
     * @exception OutOfRange     Never thrown.
     */
    void IPS_GBE_UdpBndrySet(in IPS_Ref_t RefPhys,
                             in unsigned short UDP_Boundary) 
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OutOfRange);

    /** Query the board-specific UDP threshold.
     * 
     * @param[in] RefPhys Board and port number.
     * @param[in] UDP_Boundary UDP port number threshold.
     * 
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded If RefPhys contains an invalid board or port
     *                           number.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for another board than a GbE one
     *                           (e.g. mainboard or an ASI board).
     * @exception OutOfRange     Never thrown.
     */
    void IPS_GBE_UdpBndryGet(in IPS_Ref_t RefPhys,
                             out unsigned short UDP_Boundary) 
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    enum ePortFilterType
    {
      ePortFilter_PPC,       ///< PPC protcol stack packet filter
      ePortFilter_MPEG       ///< MPEG packet filter
    };

    enum ePortFilterMode
    {
      ePortFilter_Disabled,  ///< No filtering is done, all received packets will be processed for the selected GBE  port.
      ePortFilter_MacOnly,   ///< Packets are filtered on MAC address only.
      ePortFilter_IpOnly,    ///< Packets are filtered on IP address only.
      ePortFilter_MacIp      ///< Packets are filtered on MAC and IP address.
    };
    
    struct PortFilter_t
    {
      ePortFilterType PortFilterType;
      ePortFilterMode PortFilterMode;
    };

    /** Set the PPC/MPEG filter settings of a GBE port.
     * 
     * @param[in] RefPhys specifies BoardNr and PortNr.
     * @param[in] PortFilter
     * 
     * @exception OpNotSupported When called for other boards than GbE ones (Main, asi, ..).
     * @exception OpNotSucceeded in case of
     * - Invalid references RefPhys (BoardNr, PortNr)
     * - ePortFilterType out of range
     * - ePortFilterMode out of range
     */
    void IPS_GBE_FilterSet(in IPS_Ref_t RefPhys, in PortFilter_t PortFilter)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

   /** Get the PPC/MPEG filter settings of a GBE port.
     * 
     * @param[in] RefPhys specifies BoardNr and PortNr.
     * @param[in] Type specifies the port filter type.
     * @param[out] PortFilter
     * 
     * @exception OpNotSupported When called for other boards than GbE ones (Main, asi, ..).
     * @exception OpNotSucceeded in case of
     * - Invalid references RefPhys (BoardNr, PortNr)
     * - ePortFilterType out of range
     */
    void IPS_GBE_FilterGet(in IPS_Ref_t RefPhys, in ePortFilterType Type, out PortFilter_t PortFilter)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    // ARP
    /////////////////////////////////////////////////////////////////////////////////////// 

    /** @defgroup arp ARP
     * This module contains types, enums and methods related to ARP.
     * @{
     */
     
    // ARP structures & enums
    // ------------------------------------------------------------------------
    enum eArpStatus
    {
      ArpStatic,
      ArpResolved,
      ArpUnResolved
    };

    enum eDestArpStatus
    {
      ArpNotApplicable,
      DestStaticArp,
      Multicast,
      GwStaticArp,
      GwResolved,
      GwUnResolved,
      DestResolved,
      DestUnResolved
    };

    struct ArpEntry_t
    {
      string     IP_Addr;   ///< e.g. "10.11.52.101"
      string     MacAddr;   ///< e.g. "00:00:c4:25:31:12"
      eArpStatus Status;
      IPS_Ref_t  RefPhys;
    };
    
    /// A sequence of ArpEntry_t.
    typedef sequence<ArpEntry_t> ArpEntryList_t;
    
    // ARP IDLs
    // ------------------------------------------------------------------------
    /** Add an ARP entry on the specified board. An ARP entry is an association
     *  between the IP address of an external device (destination, router,...)
     *  and its MAC address.
     *
     * @param[in] RefPhys      Board and port number.
     * @param[in] ArpEntryList List of ARP entries to be added.
     * 
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded In case of
     *   - RefPhys of one of the list elements is invalid.
     *   - When the ArpStatus of one of the list elements differs from Static.
     *   - Inconsistency between RefPhys.BoardNr and
     *     ArpEntryList[x].RefPhys.BoardNr for a list element.
     *   - Inconsistency between RefPhys.PortNr and
     *     ArpEntryList[x].RefPhys.PortNr in case RefPhys.PortNr != 0xFFFF.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for other boards than GbE ones.
     */
    void ArpEntryAddL(in IPS_Ref_t RefPhys, in ArpEntryList_t ArpEntryList) 
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Removes the specified static ARP entries.
     * 
     * @param[in] RefPhys      Board and port number.
     * @param[in] ArpEntryList List of ARP entries to be removed.
     * 
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded In case of
     *   - RefPhys of one of the list elements is invalid.
     *   - When the ArpStatus of one of the list elements differs from Static.
     *   - Inconsistency between RefPhys.BoardNr and
     *     ArpEntryList[x].RefPhys.BoardNr for a list element.
     *   - Inconsistency between RefPhys.PortNr and
     *     ArpEntryList[x].RefPhys.PortNr in case RefPhys.PortNr != 0xFFFF.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for other boards than GbE ones (Main, ASI,...).
     *
     * @note Attempts to remove non-existing ARP entries are silently ignored.
     */
    void ArpEntryDeleteL(in IPS_Ref_t RefPhys, in ArpEntryList_t ArpEntryList) 
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get the ARP entry list with status indication.
     * 
     * @param[in] RefPhys Board and port number. When 0xffff is specified for
     *                PortNr information for all ports is returned.
     * 
     * @return ArpEntryList Requested ARP entry list. 
     * 
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded RefPhys refers to a nonexisting board.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported RefPhys refers to a non-GbE board.
     */
    ArpEntryList_t ArpEntryGetL(in IPS_Ref_t RefPhys) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get a filtered ARP entry list with status indication.
     *
     * @param[in] RefPhys         Board and port number. When 0xffff is specified
     *                        for PortNr information for all ports is returned.
     * @param[in] ArpStatusFilter Filter on this ARP status.
     * 
     * @return ArpEntryList   Requested ARP entry list.
     * 
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded RefPhys refers to a nonexisting board, or
     *                           an invalid filter value was specified.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported RefPhys refers to a non-GbE board.
     */
    ArpEntryList_t ArpEntryGetFilterL(in IPS_Ref_t RefPhys,
                                      in eArpStatus ArpStatusFilter) 
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OutOfRange);

    /// @} end of arp
    
    // Route
    /////////////////////////////////////////////////////////////////////////////////////// 
    
    /** @defgroup route ROUTE
     * This module contains types, enums and methods related to routing.
     * @{
     */
    
    // ROUTE structures & enums
    ///////////////////////////// 

    struct IP_Route_t
    {
      boolean   Static;          ///< Static route or not
      string    IP_Addr;         ///< use "0.0.0.0" to create a default route
      string    SubNetMask;      ///< use "0.0.0.0" to create a default route
      string    Gateway;
      IPS_Ref_t RefPhys;
    };
    
    /// A sequence of IP_Route_t.
    typedef sequence<IP_Route_t> IP_RouteList_t;
    
    struct IP_Route_t_V2
    {
      boolean        Static;          ///< Static route or not
      string         IP_Addr;
      unsigned short PrefixLength;
      string         Gateway;
      IPS_Ref_t      RefPhys;
    };
    
    /// A sequence of IP_Route_t_V2.
    typedef sequence<IP_Route_t_V2> IP_RouteList_t_V2;

    enum eDestRoutingStatus
    {
      RoutingNotApplicable,
      NotRoutable,
      Routable_LAN,
      Routable_GW
    };

    // ROUTE IDLs
    //////////////////// 

    /** Add or replace static routes on the specified board and port.
     * 
     * @param[in] RefPhys   Board and port number.
     * @param[in] RouteList List with routes.
     * 
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded In case of
     *   - Invalid references (RefPhys).
     *   - When subnet_Gateway != subnet_GbE_port for a GbE Board.
     *   - When subnet_Gateway != subnet_mainboart_port for the mainboard. 
     *   - When subnet destination host == subnet_GbE_port.
     *   - When subnet destination host == subnet_mainboard_port of the mainboard.
     *   - Invalid SubNetMask.
     *   - Inconsistency between RefPhys.BoardNr & RouteList[x].RefPhys.BoardNr.
     *   - Inconsistency between RefPhys.PortNr & RouteList[x].RefPhys.PortNr in 
     *     case RefPhys.PortNr != 0xFFFF.
     *   - When adding a default gateway for the mainboard
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for other boards than a GbE-I/O board 
     *                           and the mainboard
     * @version Mainboard support added in release 5.1
     * 
     * @note RouteList[i].Static is ignored - all entries are treated as static
     * @note RouteList[i].RefPhys.BoardNr must match RefPhys.BoardNr
     * @note To add a default gateway a.b.c.d, specify
     *       RouteList[i].IP_Addr = 0.0.0.0, RouteList[i].SubNetMask = 0.0.0.0
     *       and Gateway = a.b.c.d .
     * @note Adding a default gateway is only supported on a GbE-I/O board and not
     *       on the mainboard     
     * @note If RouteList[i].RefPhys.PortNr == 0xffff, then routing entry i
     *       is applied to all ports of the specified board. The route will
     *       only be added if RouteList[i].SubNetMask matches the subnet of
     *       the port exactly !
     */
    void RouteEntryAddL(in IPS_Ref_t RefPhys, in IP_RouteList_t RouteList) 
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Add or replace static routes on the specified board and port.
     *
     * @param[in] RefPhys   Board and port number.
     * @param[in] RouteList List with routes.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded In case of
     *   - Invalid references (RefPhys).
     *   - When subnet_Gateway != subnet_GbE_port for a GbE Board.
     *   - When subnet_Gateway != subnet_mainboart_port for the mainboard.
     *   - When subnet destination host == subnet_GbE_port.
     *   - When subnet destination host == subnet_mainboard_port of the mainboard.
     *   - Invalid SubNetMask.
     *   - Inconsistency between RefPhys.BoardNr & RouteList[x].RefPhys.BoardNr.
     *   - Inconsistency between RefPhys.PortNr & RouteList[x].RefPhys.PortNr in
     *     case RefPhys.PortNr != 0xFFFF.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for other boards than a GbE-I/O board
     *                           and the mainboard
     * @version Mainboard support added in release 5.1
     *
     * @note RouteList[i].Static is ignored - all entries are treated as static
     * @note RouteList[i].RefPhys.BoardNr must match RefPhys.BoardNr
     * @note To add a default gateway x:x:x:x:x:x:x:x, specify
     *       RouteList[i].IP_Addr = ::, RouteList[i].SubNetMask = ::
     *       and Gateway = x:x:x:x:x:x:x:x .
     * @note If RouteList[i].RefPhys.PortNr == 0xffff, then routing entry i
     *       is applied to all ports of the specified board. The route will
     *       only be added if RouteList[i].SubNetMask matches the subnet of
     *       the port exactly !
     * @note !!!! EXPERIMENTAL - DO NOT USE !!!!
     */

    void RouteEntryIPv6AddL(in IPS_Ref_t RefPhys, in IP_RouteList_t RouteList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Delete a list of routes. Only static routes will be deleted.
     * 
     * @param[in] RefPhys   Specifies BoardNr & PortNr to delete the routes from.
     * @param[in] RouteList List with routes.
     * 
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded In case of
     *   - Invalid references (RefPhys).
     *   - Inconsistency between RefPhys.BoardNr and
     *     RouteList[x].RefPhys.BoardNr.
     *   - Inconsistency between RefPhys.PortNr and
     *     RouteList[x].RefPhys.PortNr in case RefPhys.PortNr != 0xFFFF. 
     *   - When deleting a default gateway for the mainboard
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for other boards than a GbE-I/O board 
     *                           and the mainboard
     * @version Mainboard support added in release 5.1     
     * 
     * @note RouteList[i].Static is ignored - all entries are treated as static
     * @note To delete a default gateway a.b.c.d, set IP_Addr to 0.0.0.0,
     *       SubNetMask = 0.0.0.0 and Gateway to a.b.c.d .
     * @note Deleting a default gateway is only supported on a GbE-I/O board and
     *       not on the mainboard
     */
    void RouteEntryDeleteL(in IPS_Ref_t RefPhys, in IP_RouteList_t RouteList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Delete a list of routes. Only static routes will be deleted.
     *
     * @param[in] RefPhys   Specifies BoardNr & PortNr to delete the routes from.
     * @param[in] RouteList List with routes.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded In case of
     *   - Invalid references (RefPhys).
     *   - Inconsistency between RefPhys.BoardNr and
     *     RouteList[x].RefPhys.BoardNr.
     *   - Inconsistency between RefPhys.PortNr and
     *     RouteList[x].RefPhys.PortNr in case RefPhys.PortNr != 0xFFFF.
     *   - When deleting a default gateway for the mainboard
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for other boards than a GbE-I/O board
     *                           and the mainboard
     * @version Mainboard support added in release 5.1
     *
     * @note RouteList[i].Static is ignored - all entries are treated as static
     * @note To delete a default gateway x:x:x:x:x:x:x:x, set IP_Addr to ::,
     *       SubNetMask = :: and Gateway to x:x:x:x:x:x:x:x .
     * @note !!!! EXPERIMENTAL - DO NOT USE !!!!
     */
    void RouteEntryIPv6DeleteL(in IPS_Ref_t RefPhys, in IP_RouteList_t RouteList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the routing entries for the specified board and port.
     * 
     * @param[in] RefPhys Board and port number to get information from. Specify
     *   0xffff for PortNr to retrieve information about all ports.
     * 
     * @return RouteList Requested route list.
     * 
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded RefPhys is not valid.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for a non-GbE board.
     */
    IP_RouteList_t RouteEntryGetL(in IPS_Ref_t RefPhys) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the static route entries.
     * 
     * @param[in] RefPhys Board and port number to get information from. Specify
     *   0xffff for PortNr to retrieve information about all ports.
     * 
     * @return RouteList Requested route list.
     * 
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded RefPhys is not valid.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for other boards than a GbE-I/O board 
     *                           and the mainboard
     *
     * @version Mainboard support added in release 5.1     
     */
    IP_RouteList_t RouteEntryGetFilterL(in IPS_Ref_t RefPhys) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the static route entries.
     *
     * @param[in] RefPhys Board and port number to get information from. Specify
     *   0xffff for PortNr to retrieve information about all ports.
     *
     * @return RouteList Requested route list.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded RefPhys is not valid.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for other boards than a GbE-I/O board
     *                           and the mainboard
     *
     * @version Mainboard support added in release 5.1
     * @note !!!! EXPERIMENTAL - DO NOT USE !!!!
     */
    IP_RouteList_t RouteEntryIPv6GetFilterL(in IPS_Ref_t RefPhys)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Add or replace the specified static routes. Deletes all existing
     *  static route entries.
     * 
     * @param[in] RefPhys   Board and port number to apply the routes to.
     * @param[in] RouteList List with routes.
     * 
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded In case of
     *   - Invalid references (RefPhys or RouteList[i].RefPhys).
     *   - Inconsistency between RefPhys.BoardNr
     *     and RouteList[i].RefPhys.BoardNr.
     *   - Inconsistency between RefPhys.PortNr
     *     and RouteList[i].RefPhys.PortNr in case RefPhys.PortNr != 0xFFFF. 
     *   - When subnet destination host == subnet_GbE_port.
     *   - When subnet_Gateway != subnet_GbE_port.
     *   - Invalid SubNetMask.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for a non-GbE board.
     *
     * @note RouteList[i].Static is ignored - all entries are treated as static
     */
    void RouteEntrySetL(in IPS_Ref_t RefPhys, in IP_RouteList_t RouteList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Add or replace static routes on the specified board and port.
     * 
     * @param[in] RefPhys   Board and port number.
     * @param[in] RouteList List with routes.
     * 
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded In case of
     *   - Invalid references (RefPhys).
     *   - When subnet_Gateway != subnet_mainboart_port for the mainboard. 
     *   - When subnet destination host == subnet_mainboard_port of the mainboard.
     *   - Invalid PrefixLength.
     *   - Inconsistency between RefPhys.BoardNr & RouteList[x].RefPhys.BoardNr.
     *   - Inconsistency between RefPhys.PortNr & RouteList[x].RefPhys.PortNr in 
     *     case RefPhys.PortNr != 0xFFFF.
     *   - When adding a default gateway for the mainboard
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for other boards than the mainboard
     * @exception OperationFailed
     * @version Mainboard support added in release 10.10
     * 
     * @note RouteList[i].Static is ignored - all entries are treated as static
     * @note RouteList[i].RefPhys.BoardNr must match RefPhys.BoardNr
     * @note For IPv4, to add a default gateway a.b.c.d, specify
     *       RouteList[i].IP_Addr = 0.0.0.0, RouteList[i].PrefixLength = 0
     *       and Gateway = a.b.c.d .
     * @note For IPv6, to add a default gateway a:b:c:d:e:f:g:h, specify
     *       RouteList[i].IP_Addr = ::, RouteList[i].PrefixLength = 0
     *       and Gateway = a:b:c:d:e:f:g:h .
     * @note Adding a default gateway via this call is not supported on
     *       the mainboard, use the IPS_IP_ParamsMBSet_V2 IDL call for this.
     * @note If RouteList[i].RefPhys.PortNr == 0xffff, then routing entry i
     *       is applied to all ports of the specified board. The route will
     *       only be added if the prefix of the gateway in RouteList[i] matches 
     *       oen of the prefixes on the port exactly!
     */
    void RouteEntryAddL_V2(in IPS_Ref_t RefPhys, in IP_RouteList_t_V2 RouteList) 
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Delete a list of routes. Only static routes will be deleted.
     * 
     * @param[in] RefPhys   Specifies BoardNr & PortNr to delete the routes from.
     * @param[in] RouteList List with routes.
     * 
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded In case of
     *   - Invalid references (RefPhys).
     *   - Inconsistency between RefPhys.BoardNr and
     *     RouteList[x].RefPhys.BoardNr.
     *   - Inconsistency between RefPhys.PortNr and
     *     RouteList[x].RefPhys.PortNr in case RefPhys.PortNr != 0xFFFF. 
     *   - When deleting a default gateway for the mainboard
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for other boards than the mainboard
     * @exception OperationFailed
     * @version Mainboard support added in release 10.10
     * 
     * @note RouteList[i].Static is ignored - all entries are treated as static
     * @note Deleting a default gateway not supported on the mainboard
     */
    void RouteEntryDeleteL_V2(in IPS_Ref_t RefPhys, in IP_RouteList_t_V2 RouteList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Get the static route entries.
     * 
     * @param[in] RefPhys Board and port number to get information from. Specify
     *   0xffff for PortNr to retrieve information about all ports.
     * 
     * @return RouteList Requested route list.
     * 
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded RefPhys is not valid.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for other boards than the mainboard
     * @exception OperationFailed
     *
     * @version Mainboard support added in release 10.10
     */
    IP_RouteList_t_V2 RouteEntryGetFilterL_V2(in IPS_Ref_t RefPhys) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    
    /// @} end of route

    // End Device
    /////////////////////////////////////////////////////////////////////////////////////// 
    
    /** @defgroup enddevice END_DEVICE
     * This module contains types, enums and methods related to end devices.
     * @{
     */
    
    // END_DEVICE structures & enums
    // ------------------------------------------------------------------------------------

    struct EndDeviceEntry_t
    {
      string IP_Addr;
      eDestRoutingStatus RoutingStatus;         ///< routable or not
      eDestArpStatus ArpStatus;                 ///< 1) if LAN: ArpStatus of end device 2) if GW: ArpStatus of GW
      IPS_Ref_t RefPhys;                        /// Points to a virtual port
    };
    
    /// A sequence of EndDeviceEntry_t.
    typedef sequence <EndDeviceEntry_t> EndDeviceList_t;

    // END_DEVICE IDLs
    // ------------------------------------------------------------------------------------

    /** Get a list of end devices.
     * 
     * @param[in] RefPhys Specifies the Port for which to get the EndDevices. Wildcard is allowed. RefPhys can be a virtual port.
     * 
     * @return EndDeviceList_t List with end devices.
     * 
     * @exception OpNotSupported When called for other boards than GbE ones (Main, ASI,...).
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys).
     * 
     */
    EndDeviceList_t EndDeviceEntryGetL(in IPS_Ref_t RefPhys) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /// @} end of end device
    
    /** Drop or pass IP input packets with CRC error.
     * 
     * @param[in] BoardNr      
     * @param[in] bPass     If true, packets with CRC errors are passed, otherwise dropped.
     * 
     * @exception TimeOut         A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded  When boardnr is invalid.
     * @exception OpNotAllowed    Not logged on.
     * @exception OpNotSupported  When called for a non-GbE board.
     * 
     * @version Release 10.10
     */  
    void PassPacketsWithCRC_Error_Set(in unsigned short BoardNr, in boolean bPass) 
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Query if IP input packets with CRC error are being passed or dropped.
     * 
     * @param[in] BoardNr      
     * @param[out] bPass    If true, packets with CRC errors are passed, otherwise dropped.
     *                      Default is false.
     * 
     * @exception TimeOut         A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded  When boardnr is invalid.
     * @exception OpNotAllowed    Not logged on.
     * @exception OpNotSupported  When called for a non-GbE board.
     * 
     * @version Release 10.10
     */  
    void PassPacketsWithCRC_Error_Get(in unsigned short BoardNr, out boolean bPass) 
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
      
#endif // DISABLE_GBE

#ifndef DISABLE_FEC
    /** @defgroup fec FEC
     * This contains types, enums and methods to configure the FEC streams of the device.
     * @{
     */
    
    /** @defgroup decoder FEC Decoder
     * This contains types, enums and methods to configure the FEC decoder part of the device.
     * @{
     */

    // FEC decoder structures and enums
    // ------------------------------------------------------------------------------------     
    
    /// Input mode for FEC decoder
    enum eFECDecMode
    {
      eFEC_DEC_DISABLED,      ///< no FEC decoding
      eFEC_DEC_1D_MODE,       ///< single FEC decoding mode
      eFEC_DEC_2D_MODE,       ///< dual FEC decoding mode
      eFEC_RTP_REORDER_ONLY   ///< perform only packet reordening
    };

    /// FEC decoder settings
    struct  FEC_Dec_Setting_t
    {
      eFECDecMode       Mode;
      IPS_UDP_Socket_t  ColFEC; 
      IPS_UDP_Socket_t  RowFEC;
      boolean           FollowDefaultRule; ///< readonly flag indicating if FEC Default Rule settings are used
    };
    
    /// FEC encoder settings for specific TS
    struct  InTS_FEC_Dec_Setting_t
    {
      IPS_RefTS_t       RefTSIn;
      FEC_Dec_Setting_t FecDecSet;
    };
    
    /// A sequence of InTS_FEC_Dec_Setting_t entries
    typedef sequence<InTS_FEC_Dec_Setting_t> InTS_FEC_Dec_Setting_List_t;

    /// FEC streamsIicrement scheme for default settings (increase IP or UDP)
    enum eFECIncrScheme
    {
      eUDP_OFFSET,                                  ///< increase UDP port for row/col FEC
      eIP_OFFSET                                    ///< increase IP address for row/col FEC
    };
    
    /// FEC decoder default rule settings
    struct  InTS_FEC_Dec_DefRuleSetting_t
    {
       eFECDecMode            Mode;
       eFECIncrScheme         IncrScheme;
       unsigned short         ColFEC_Offset;
       unsigned short         RowFEC_Offset;
    };
    
    /// FEC decoder statistics
    struct FEC_Dec_Statistics_t 
    {
      unsigned long long ValidPacketCount;
      unsigned long long MissingPacketCount;
      unsigned long long FixedPacketCount;
      unsigned long long DuplicatePacketCount;
      unsigned long long ReorderedPacketCount;
      unsigned long long OutOfRangePacketCount;
    };

    /// FEC decoder statistics for specific TS
    struct InTS_FEC_Dec_Statistics_t 
    {
      IPS_RefTS_t          RefTSIn;
      FEC_Dec_Statistics_t FecDecStat;
    };

    /// A sequence of InTS_FEC_Dec_Statistics_t entries
    typedef sequence< InTS_FEC_Dec_Statistics_t > InTS_FEC_Dec_Statistics_List_t;

    /// FEC decoder status
    struct FEC_Dec_Status_t
    {
      boolean        ColFEC_Present;
      boolean        RowFEC_Present;
      unsigned short D_ColDepth;
      unsigned short L_RowLength;
      unsigned short ColFEC_Overhead;  ///< in percentage fixed point 2 digit (x100)
      unsigned short RowFEC_Overhead;  ///< in percentage fixed point 2 digit (x100)
      unsigned short TotalOverhead;    ///< in percentage fixed point 2 digit (x100)
      unsigned short Latency;          ///< in ms fixed point 1 digit (x10)
    };

    /// FEC decoder status for specific TS
    struct InTS_FEC_Dec_Status_t
    {
      IPS_RefTS_t      RefTSIn;
      FEC_Dec_Status_t FecDecStat;
    };
    
    /// A sequence of InTS_FEC_Dec_Status_t entries
    typedef sequence< InTS_FEC_Dec_Status_t > InTS_FEC_Dec_Status_List_t;

    // FEC Decoder IDL's
    // ------------------------------------------------------------------------------------
    
    /** Set FEC decoder settings for some input TS
     * 
     * @param[in] RefPhys The BoardNr and PortNr of which parameters need to be changed. 
     * @param[in] InTS_FEC_Dec_Setting_List List of RefTsIn/ FecDecSet pairs
     *
     * @exception OpNotSupported When board is not a Gbe board or an IP Video Gateway board, or when no FEC board present on a GbE board.
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist (or is a backup port)
     * - InTS_FEC_Dec_Setting_t out of range
     * @exception LicenseError When FEC is enabled and no more FEC licenses available anymore.
     **/
    void InTS_FEC_Dec_SetL(in IPS_Ref_t RefPhys, in InTS_FEC_Dec_Setting_List_t InTS_FEC_Dec_Setting_List)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);
    
    
    /** Get FEC decoder settings for some input TS
     * 
     * @param[in] RefPhys The BoardNr and PortNr you want information about.
     * @param[in] RefTsList List of Referenced input TS for which to return the FEC Dec Settings. 
     * Empty list=all InTs attached to RefPhys
     * @param[out] InTS_FEC_Dec_Setting_List List of RefTsIn/ FecDecSet pairs
     *
     * @exception OpNotSupported When board is not a Gbe board or an IP Video Gateway board, or when no FEC board present on a GbE board.
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist (or is a backup port)
     * - RefTs does not match RefPhys
     **/
    void InTS_FEC_Dec_GetL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList, 
                           out InTS_FEC_Dec_Setting_List_t InTS_FEC_Dec_Setting_List)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    
    /** Delete the FEC decoder settings for some input TS
     * 
     * @param[in] RefPhys The BoardNr and PortNr of which parameters need to be changed.
     * @param[in] RefTsList List of Referenced input TS for which to delete the FEC settings
     *
     * @exception OpNotSupported When board is not a Gbe board or an IP Video Gateway board, or when no FEC board present on a GbE board.
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist (or is a backup port)
     * - RefTs does not match RefPhys
     * @exception LicenseError When FEC is default enabled and no more FEC licenses available anymore.
     **/
    void InTS_FEC_Dec_DelL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);
    
    
    /** Set FEC Dec default rule settings to be used for all InTS without FEC settings
     * Defaults are attached to a (logical) port.
     * 
     * @param[in] RefPhys The BoardNr and PortNr of which parameters need to be changed.
     * @param[in] FEC_Dec_DefRuleSetting The defaults
     *
     * @exception OpNotSupported When called for other boards than GbE ones or no FEC board present.
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist (or is a backup port)
     * - FEC_Dec_DefRuleSetting out of range
     **/
    void SetDefaultRule_FEC_Dec(in IPS_Ref_t RefPhys, in InTS_FEC_Dec_DefRuleSetting_t FEC_Dec_DefRuleSetting)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Get FEC Dec default rule settings to be used for all InTS without FEC settings
     * Defaults are attached to a (logical) port.
     *
     * @param[in] RefPhys The BoardNr and PortNr you want information about.
     * @param[out] FEC_Dec_DefRuleSetting The defaults
     *
     * @exception OpNotSupported When called for other boards than GbE ones or no FEC board present.       
     * @exception OpNotSucceeded In case of
     * - RefPhys does not exist (or is a backup port)
     **/
    void GetDefaultRule_FEC_Dec(in IPS_Ref_t RefPhys, out InTS_FEC_Dec_DefRuleSetting_t FEC_Dec_DefRuleSetting)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Get FEC Dec statistics for a list of input TS.
     *
     * @param[in] RefPhys   The BoardNr and PortNr you want information about.
     * @param[in] RefTsList Identifies the input TS.
     * @param[in] InTS_FEC_Dec_Statistics_List List of RefTs/ FecDecStat pairs
     *
     * @exception OpNotSupported When board is not a Gbe board or an IP Video Gateway board, or when no FEC board present on a GbE board.
     * @exception OpNotSucceeded In case of
     * - RefTSIn does not exist
     **/
    void InTS_FEC_Dec_Get_Statistics(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList,
                                      out InTS_FEC_Dec_Statistics_List_t InTS_FEC_Dec_Statistics_List)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Reset the FEC Dec statistics for a list of input TS.
     *
     * @param[in] RefPhys   The BoardNr and PortNr you want information about.
     * @param[in] RefTsList Identifies the input TS.
     *
     * @exception OpNotSupported When board is not a Gbe board or an IP Video Gateway board, or when no FEC board present on a GbE board.
     * @exception OpNotSucceeded In case of
     * - RefTSIn does not exist
     **/
    void InTS_FEC_Dec_Reset_Statistics(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Get the FEC Dec status for a list of input TS.
     *
     * @param[in] RefPhys   The BoardNr and PortNr you want information about.
     * @param[in] RefTsList Identifies the input TS.
     * @param[in] InTS_FEC_Dec_Status_List
     *
     * @exception OpNotSupported When board is not a Gbe board or an IP Video Gateway board, or when no FEC board present on a GbE board.
     * @exception OpNotSucceeded In case of
     * - RefTSIn does not exist
     * - RefTs does not match RefPhys
     **/
    void InTS_FEC_Dec_Get_Status(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList, 
                                 out InTS_FEC_Dec_Status_List_t InTS_FEC_Dec_Status_List)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /**
     * Set the RTP reorder buffer size for all input TSs configured in RTP reorder mode.
     * @param[in] Board: The board number
     * @param[in] Size: The new size of the buffers. Size must be between 16 and 256.
     * 
     * @exception OpNotSupported When called for other boards than GbE ones or no FEC board present.
     */
    void RTP_ReorderBufferSize_Set(in unsigned short Board, in unsigned long Size)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * Get the RTP reorder buffer size (of all input TSs configured in RTP reorder mode)
     * @param[in] Board: The board number
     * @param[out] Size: The size of the buffers.
     * 
     * @exception OpNotSupported When called for other boards than GbE ones or no FEC board present.
     */
    void RTP_ReorderBufferSize_Get(in unsigned short Board, out unsigned long Size)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /// @} end of decoder

    /** @defgroup encoder FEC Encoder
     * This contains types, enums and methods to configure the FEC encoder part of the device.
     * @{
     */
    // FEC encoder structures and enums
    // ------------------------------------------------------------------------------------

    /// Output mode for FEC encoder
    enum eFECEncMode
    {
      eFEC_ENC_DISABLED,        ///< no FEC encoding
      eFEC_ENC_1D_MODE,         ///< single FEC stream mode
      eFEC_ENC_2D_MODE          ///< dual FEC stream mode
    };

    /// FEC linearity for encoder
    enum eFECSendingArrangement
    {
      ePRO_MPEG_COP3_ANNEX_B,   ///< offset scheme as in annex B of Pro MPEG COP 3 standard
      ePRO_MPEG_COP3_ANNEX_A    ///< offset scheme as in annex A of Pro MPEG COP 3 standard
    };

    /// FEC encoder settings
    struct FEC_Enc_Setting_t
    {
      eFECEncMode             Mode;                 ///< default value is FEC disabled
      eFECSendingArrangement  SendingArrangement;   ///< for 4.0 release, SendingArrangement must always be ePRO_MPEG_COP3_ANNEX_B
      IPS_UDP_Socket_t        ColFEC;               ///< for 4.0 release, IP = IP TS  and  UDP = UDP TS + 2
      IPS_UDP_Socket_t        RowFEC;               ///< for 4.0 release, IP = IP TS  and  UDP = UDP TS + 4
      unsigned short          D_ColDepth;           ///< default value D = 6
      unsigned short          L_RowLength;           ///< default value L = 10
    };

    /// FEC encoder settings for specific TS
    struct OutTS_FEC_Enc_Setting_t
    {
      IPS_RefTS_t       RefTSOut;
      FEC_Enc_Setting_t FecEncSett;
    };

    /// A sequence of OutTS_FEC_Enc_Setting_t entries
    typedef sequence<OutTS_FEC_Enc_Setting_t> OutTS_FEC_Enc_Setting_List_t;

//--

    /// FEC encoder settings
    struct FEC_Enc_Setting_V2_t
    {
      eFECEncMode             Mode;                 ///< default value is FEC disabled
      eFECSendingArrangement  SendingArrangement;   ///< for 4.0 release, SendingArrangement must always be ePRO_MPEG_COP3_ANNEX_B
      unsigned short          D_ColDepth;           ///< default value D = 6
      unsigned short          L_RowLength;           ///< default value L = 10
    };

    /// FEC encoder settings for specific TS
    struct OutTS_FEC_Enc_Setting_V2_t
    {
      IPS_RefTS_t       RefTS;
      FEC_Enc_Setting_V2_t FecEncSett;
    };

    /// A sequence of OutTS_FEC_Enc_Setting_V2_t entries
    typedef sequence<OutTS_FEC_Enc_Setting_V2_t> OutTS_FEC_Enc_Setting_V2_List_t;

//--

    /// Default FEC encoder settings (to be applied for new TS's)
    struct OutTS_FEC_Enc_DefSetting_t
    {
      eFECEncMode             Mode;                 ///< default value is FEC disabled
      eFECSendingArrangement  SendingArrangement;   ///< for 4.0 release, SendingArrangement must always be ePRO_MPEG_COP3_ANNEX_B
      eFECIncrScheme          IncrScheme;           ///< default value is increment UDP (eUDP_OFFSET) (fixed for 4.0 release)
      unsigned short          ColFecOffset;         ///< default value column offset = 2 (fixed for 4.0 release)
      unsigned short          RowFecOffset;         ///< default value row offset = 4 (fixed for 4.0 release)
      /** note: the name of this member changed from 5.0->5.1
       * The old name was D_RowWidth
       */
      unsigned short          D_ColDepth;
      /** note: the name of this member changed from 5.0->5.1.
       * The old name was L_ColDepth
       */
      unsigned short          L_RowLength;
    };

    /// Mode for FEC error generation
    enum eFECErrorMode
    {
      eFEC_ERROR_GEN_DISABLED,      ///< no error generation
      eFEC_ERROR_GEN_SINGLE_BURST,  ///< generate single burst error
      eFEC_ERROR_GEN_CONTINUOUS     ///< generate continuous error
    };

    /// FEC error generation parameters
    struct  FEC_Enc_ErrorGen_t
    {
      eFECErrorMode          Mode;
      unsigned short         NrGoodPackets;     ///< number of good packets (IPGW: range 1..65535)
      unsigned short         NrErrorPackets;    ///< number of error packets (IPGW: range 1..512)
    };

    /// FEC error generation for specific TS
    struct  OutTS_FEC_Enc_ErrorGen_t
    {
      IPS_RefTS_t        RefTSOut;
      FEC_Enc_ErrorGen_t FecEncErrorSett;
    };

    /// Bitrate overhead, due to FEC encoding
    struct FEC_Enc_Overhead_t
    {
      unsigned short  ColFEC_Overhead;  ///< in percentage fixed point 2 digit (x100), e.g. 10% -> 1000
      unsigned short  RowFEC_Overhead;  ///< in percentage fixed point 2 digit (x100), e.g. 10% -> 1000
      unsigned short  TotalOverhead;    ///< in percentage fixed point 2 digit (x100), e.g. 10% -> 1000
    };

    /// Bitrate overhead for specific TS
    struct OutTS_FEC_Enc_Overhead_t
    {
      IPS_RefTS_t         RefTSOut;
      FEC_Enc_Overhead_t  FecEncOverhead;
    };

    /// A sequence of OutTS_FEC_Enc_Overhead_t entries
    typedef sequence<OutTS_FEC_Enc_Overhead_t> OutTS_FEC_Enc_Overhead_List_t;


    // FEC Encoder IDL's
    // ------------------------------------------------------------------------------------

    /**
     * Set FEC encoder settings for some output TS.
     *
     * @param[in]     RefPhys                     the port the OutTS are attached to
     * @param[in]     OutTS_FEC_Enc_Setting_List  list of RefTSOut/FecEncSett pairs
     * 
     * @exception OpNotSupported When board is not a Gbe board or an IP Video Gateway board, or when no FEC board present on a GbE board.
     * @exception OpNotSucceeded  In case of
     *                                - RefPhys does not exist (or is a backup port)
     *                                - RefTSOut does not match RefPhys
     *                                - FEC_Enc_Settings out of range
     *                                - Enabling FEC encoding while RTP is disabled
     *                                - Enabling FEC encoding while VBR is enabled
     * @exception LicenseError When FEC is enabled and no more FEC licenses available anymore.
     **/
    void OutTS_FEC_Enc_SetL(in IPS_Ref_t RefPhys, 
                            in OutTS_FEC_Enc_Setting_List_t OutTS_FEC_Enc_Setting_List)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);


    /**
     * Get FEC encoder settings for some output TS.
     *
     * @param[in]     RefPhys                     the port the OutTS are attached to
     * @param[in]     RefTsList                   list of references of OutTS for which to return 
     *                                            the FEC ENC Settings
     *                                            (Empty list = all OutTS attached to RefPhys)
     * @param[out]    OutTS_FEC_Enc_Setting_List  list of FefTSOut/FecEncSett pairs
     * 
     * @exception OpNotSupported When board is not a Gbe board or an IP Video Gateway board, or when no FEC board present on a GbE board.
     * @exception OpNotSucceeded  In case of
     *                                - RefPhys does not exist (or is a backup port)
     *                                - RefTSOut does not match RefPhys
     **/
    void OutTS_FEC_Enc_GetL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList,
                            out OutTS_FEC_Enc_Setting_List_t OutTS_FEC_Enc_Setting_List)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /**
     * For IPGW. Similar to the "V1" but without socket parameters.
     * These socket parameters are then configured with OutputFecGBE_ChangeL(). 
     *
     * @version Release 8.9
     **/
    void OutTS_FEC_Enc_V2_SetL(in IPS_Ref_t RefPhys, 
                            in OutTS_FEC_Enc_Setting_V2_List_t OutTS_FEC_Enc_Setting_V2_List)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);


    void OutTS_FEC_Enc_V2_GetL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList,
                            out OutTS_FEC_Enc_Setting_V2_List_t OutTS_FEC_Enc_Setting_V2_List)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /**
     * Set default FEC Enc settings to be used for new OutTS.
     * Defaults are attached to a (logical) port.
     *
     * @param[in]     RefPhys             identifies the port (no wildcards allowed)
     * @param[in]     FEC_Enc_DefSetting  the default settings for FEC encoder
     *
     * @exception OpNotSupported  When called for other boards than GbE ones (Main, ASI, ...)
     * @exception OpNotSucceeded  In case of
     *                                - RefPhys does not exist (or is a backup port)
     *                                - FEC_Enc_DefSetting out of range
     *                                - Default enabling FEC encoding while RTP is default disabled
     *                                - Default enabling FEC encoding while VBR is default enabled
     **/
    void SetDefault_FEC_Enc(in IPS_Ref_t RefPhys, in OutTS_FEC_Enc_DefSetting_t FEC_Enc_DefSetting)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /**
     * Get default FEC Enc settings that are used for new OutTS.
     * Defaults are attached to a (logical) port.
     *
     * @param[in]     RefPhys             identifies the port (no wildcards allowed)
     * @param[out]    FEC_Enc_DefSetting  the default settings for FEC encoder
     *
     * @exception OpNotSupported  When called for other boards than GbE ones (Main, ASI, ...)
     * @exception OpNotSucceeded  In case of
     *                                - RefPhys does not exist (or is a backup port)
     **/
    void GetDefault_FEC_Enc(in IPS_Ref_t RefPhys, out OutTS_FEC_Enc_DefSetting_t FEC_Enc_DefSetting)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /**
     * Set FEC Error generator mode for OutTS.
     *
     * @param[in]     RefTS           the location of the TS (board, port and ref)
     * @param[in]     ErrorMode       the error mode for FEC error generator
     * @param[in]     NrGoodPackets   number of good packets (range 1..65536)
     * @param[in]     NrErrorPackets  number of error packets (range 1..63)
     *
     * @remark  This setting is not saved to flash.
     * @remark  Starting error generation on another TS will automatically 
     *          stop the pending error generation.
     *
     * @exception OpNotSupported  When called for other boards than GbE ones (Main, ASI, ...)
     * @exception OpNotSucceeded  In case of
     *                                - RefPhys does not exist (or is a backup port)
     *                                - FECErrorMode out of range
     *                                - NrGoodPackets out of range
     *                                - NrErrorPackets out of range
     **/
    void SetErrorGen_FEC_Enc(in IPS_RefTS_t RefTS, in eFECErrorMode ErrorMode,
                             in unsigned short NrGoodPackets, in unsigned short NrErrorPackets)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
     
     
    /**
     * Set FEC Error generator mode for OutTS. V2 for DCM Gateway.
     *
     * @param[in]     RefTS           the location of the TS (board, port and ref)
     * @param[in]     OutTS_FEC_Enc_ErrorGen The FEC error generation parameters
     *
     * @remark  This setting is not saved to flash.
     * @remark  Starting error generation on another TS will automatically 
     *          stop the pending error generation.
     *
     * @exception OpNotSupported When board is not a Gbe board or an IP Video Gateway board, or when no FEC board present on a GbE board.
     * @exception OpNotSucceeded  In case of
     *                                - RefPhys does not exist (or is a backup port)
     *                                - FECErrorMode out of range
     *                                - NrGoodPackets out of range
     *                                - NrErrorPackets out of range
     **/
    void SetErrorGen_FEC_Enc_V2(in IPS_RefTS_t RefTS, in OutTS_FEC_Enc_ErrorGen_t OutTS_FEC_Enc_ErrorGen)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
     

    /** Get the active FEC Error generator mode
     * 
     * @param[in] RefPhys Board and port number. Port number is ignored.
     *
     * @param[out] OutTS_FEC_Enc_ErrorGen The FEC error generation parameters
     *
     * @exception OpNotSupported When board is not a Gbe board or an IP Video Gateway board, or when no FEC board present on a GbE board.
     * @exception OpNotSucceeded In case of
     * - No FEC board is present
     **/

    void GetErrorGen_FEC_Enc(in IPS_Ref_t RefPhys, out OutTS_FEC_Enc_ErrorGen_t OutTS_FEC_Enc_ErrorGen)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /**
     * Get FEC encoder Row/Col overhead for some OutTS.
     *
     * @param[in]     RefPhys     the port the OutTS are attached to
     * @param[in]     RefTsList   list of references of OutTS for which to return 
     *                            the FEC ENC overhead.
     *                            (Empty list = all OutTS attached to RefPhys)
     * @param[in]     OutTS_FEC_Enc_Overhead_List   list of RefTSOut/FecEncOverhead pairs
     *
     * @exception OpNotSupported When board is not a Gbe board or an IP Video Gateway board, or when no FEC board present on a GbE board.
     * @exception OpNotSucceeded  In case of
     *                                - RefPhys does not exist (or is a backup port)
     *                                - RefTs does not match RefPhys
     **/
    void OutTS_FEC_Enc_Overhead_GetL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList,
                                     out OutTS_FEC_Enc_Overhead_List_t OutTS_FEC_Enc_Overhead_List)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /// @} end of encoder

    /** @defgroup hitless_merge Hitless merge over separate ports 
     * This contains types, enums and methods to configure Hitless Merge over separate ports.
     * @{
     */
     
    // Structures and enums related to Hitless Merge over separate ports
    // ------------------------------------------------------------------------------------
   
    /// Hitless merge mode for input TS
    enum enHitlessMergeMode_t
    {
      eHitlessMergeMode_FollowBoardDefault,             ///< follow the board default settings
      eHitlessMergeMode_Disabled,                       ///< no hitless merge over separate port pairs
      eHitlessMergeMode_EnabledSameUDP_Socket,          ///< hitless merge over separate port pairs, backup stream has same IP-UDP as main
      eHitlessMergeMode_EnabledOtherUDP_Socket,         ///< hitless merge over separate port pairs, backup stream has other IP-UDP as main
      eHitlessMergeMode_Reserved1,                      ///< Reserved for future use
      eHitlessMergeMode_Reserved2,                      ///< Reserved for future use
      eHitlessMergeMode_Reserved3,                      ///< Reserved for future use
      eHitlessMergeMode_Reserved4                       ///< Reserved for future use
    };

    enum enHitlessMergeDefaultMode_t
    {
      eHitlessMergeDefaultMode_Disabled,                ///< default setting: no hitless merge over separate port pairs
      eHitlessMergeDefaultMode_EnabledSameUDP_Socket,   ///< default setting: hitless merge over separate port pairs, backup stream has same IP-UDP as main
      eHitlessMergeDefaultMode_Reserved1,               ///< Reserved for future use
      eHitlessMergeDefaultMode_Reserved2,               ///< Reserved for future use
      eHitlessMergeDefaultMode_Reserved3,               ///< Reserved for future use
      eHitlessMergeDefaultMode_Reserved4                ///< Reserved for future use
    };

    /// Hitless merge input TS settings
    struct HitlessMergeSetting_t
    {
      enHitlessMergeMode_t  Mode;
      IPS_UDP_Socket_t      OtherUDP_Socket;   ///< this is only valid when Mode is eHitlessMergeMode_EnabledOtherUDP_Socket
      unsigned short        PacketWindow;      ///< For future use, will read 0
      unsigned short        Delay;             ///< in ms fixed point 1 digit (x10), read only
    };
    
    /// Hitless merge settings for specific TS
    struct InTS_HitlessMergeSetting_t
    {
      IPS_RefTS_t             RefTSIn;
      HitlessMergeSetting_t   HitlessMergeSetting;
    };
    
    /// A sequence of InTS_HitlessMergeSetting_t entries
    typedef sequence<InTS_HitlessMergeSetting_t> InTS_HitlessMergeSettingList_t;

    // IDL calls related to Hitless Merge
    // ------------------------------------------------------------------------------------
    
    /** Get the Hitless Merge over Separate Port Pairs Enabled setting of an GbE Board
     *
     * @param[in] BoardNr
     * @param[out] HitlessMergeEnabled Indicates whether Hitless Merge over separate 
     *             ports is enabled or not
     *
     * @exception TimeOut         A timeout occurred during IIOP processing.
     * @exception OpNotAllowed    Not logged on.
     * @exception OpNotSupported  When called for non-GbE boards.
     * @exception OpNotSucceeded  When BoardNr refers to a non-existing board
     *
     * @version Release 11.10
     */
    void GetHitlessMergeModeEnabled(in unsigned short BoardNr, out boolean HitlessMergeEnabled)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the Hitless Merge over Separate Port Pairs Enabled setting of an GbE Board
     *
     * @param[in] BoardNr 
     * @param[in] HitlessMergeEnable Indicates whether Hitless Merge should be enabled or not
     *
     * @exception TimeOut          A timeout occurred during IIOP processing.
     * @exception OpNotAllowed     Not logged on.
     * @exception OpNotSupported   When called for non-GbE boards.
     * @exception OpNotSucceeded   When BoardNr refers to a non-existing board.
     * @exception OperationFailed  When enabling hitless merge while there are input streams
     *                             which are already routed to an output on the second input 
     *                             port pair.
     *
     * @note When hitless merge is being enabled, all FEC configurations will be removed.
     *       When hitless merge is being disabled, all hitless merge configuration will be removed.
     * @note When enabling hitless merge, the second port pair will become output only, when 
     *       disabling hitless merge, the second port pair will become input/output again
     *
     * @version Release 11.10
     */
    void SetHitlessMergeModeEnabled(in unsigned short BoardNr, in boolean HitlessMergeEnable)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);    
   
    /** Set Hitless merge settings for some input TS
     * 
     * @param[in] BoardNr The BoardNr of which parameters need to be changed. 
     * @param[in] InTS_HitlessMergeSettingList List of hitless merge settings for input TSs
     *
     * @exception TimeOut          A timeout occurred during IIOP processing.
     * @exception OpNotAllowed     Not logged on.
     * @exception OpNotSupported   When called for non-GbE boards.
     * @exception OpNotSucceeded   When BoardNr refers to a non-existing board.
     * @exception OperationFailed  In case
     *                             - Hitless merge is disabled
     *                             - RefPhys does not exist (or is a backup port)
     *                             - RefPhys is on the second port pair
     *                             - InTS_HitlessMergeSettingList contains nonexisting RefTSIn 
     *                             - InTs_HitlessMergeSettingList contains invalid hitless merge mode
     *                             - InTs_HitlessMergeSettingList contains invalid UDP socket data when mode is
     *                                     eHitlessMergeMode_EnabledOtherUDP_Socket
     * @exception LicenseError When Hitless merge is enabled and no more FEC licenses available.
     *
     * @note Setting the Mode of a TS to eHitlessMergeMode_FollowBoardDefault will 
     *       effectively remove the TS level hitless merge settings for that stream.
     **/
    void InTS_HitlessMergeSetL(in unsigned short BoardNr, in InTS_HitlessMergeSettingList_t InTS_HitlessMergeSettingList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed, LicenseError);
    
    
    /** Get Hitless merge settings for some input TS
     * 
     * @param[in] RefPhys The BoardNr and PortNr you want information about.
     * @param[in] RefTsList List of Referenced input TS for which to return the Hitless merge 
     *                      settings.  Empty list=all InTs attached to RefPhys.
     * @param[out] InTS_HitlessMergeSettingList List of hitless merge settings for input TSs
     *
     * @exception TimeOut          A timeout occurred during IIOP processing.
     * @exception OpNotAllowed     Not logged on.
     * @exception OpNotSupported   When called for non-GbE boards.
     * @exception OpNotSucceeded   When RefPhys.BoardNr refers to a non-existing board.
     * @exception OperationFailed  In case of
     *                             - Hitless merge is disabled
     *                             - RefPhys does not exist (or is a backup port)
     *                             - RefPhys is on the second port pair
     *                             - RefTs does not match RefPhys
     **/
    void InTS_HitlessMergeGetL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList, 
                               out InTS_HitlessMergeSettingList_t InTS_HitlessMergeSettingList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);
    
    
    /** Get the Hitless Merge default mode for hitless merge input TSs of an GbE Board
     *
     * @param[in] BoardNr
     * @param[out] HitlessMergeDefaultMode Indicates the board level default mode for hitless merge.
     *
     * @exception TimeOut         A timeout occurred during IIOP processing.
     * @exception OpNotAllowed    Not logged on.
     * @exception OpNotSupported  When called for non-GbE boards.
     * @exception OpNotSucceeded  When BoardNr refers to a non-existing board.
     *
     * @version Release 11.10
     */
    void GetDefaultRule_HM_Mode(in unsigned short BoardNr, out enHitlessMergeDefaultMode_t HitlessMergeDefaultMode)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the Hitless Merge default mode for hitless merge input TSs of an GbE Board
     *
     * @param[in] BoardNr 
     * @param[in] HitlessMergeDefaultMode Indicates the board level default mode for hitless merge.
     *
     * @exception TimeOut          A timeout occurred during IIOP processing.
     * @exception OpNotAllowed     Not logged on.
     * @exception OpNotSupported   When called for non-GbE boards.
     * @exception OpNotSucceeded   When BoardNr refers to a non-existing board.
     * @exception OperationFailed  When mode is out of range.
     *
     * @version Release 11.10
     */
    void SetDefaultRule_HM_Mode(in unsigned short BoardNr, in enHitlessMergeDefaultMode_t HitlessMergeDefaultMode)
        raises(TimeOut, OperationFailed, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Get the Hitless Merge default packet window for hitless merge input TSs of an GbE Board
     *
     * @param[in] BoardNr
     * @param[out] HitlessMergeDefaultPacketWindow Indicates the board level default packet window for hitless merge.
     *
     * @exception TimeOut         A timeout occurred during IIOP processing.
     * @exception OpNotAllowed    Not logged on.
     * @exception OpNotSupported  When called for non-GbE boards.
     * @exception OpNotSucceeded  When BoardNr refers to a non-existing board.  
     *
     * @version Release 11.10
     */
    void GetDefaultRule_HM_PacketWindow(in unsigned short BoardNr, out unsigned short HitlessMergeDefaultPacketWindow)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the Hitless Merge default packet window for hitless merge input TSs of an GbE Board
     *
     * @param[in] BoardNr 
     * @param[in] HitlessMergeDefaultPacketWindow Indicates the board level default packet window for hitless merge.
     *
     * @exception TimeOut          A timeout occurred during IIOP processing.
     * @exception OpNotAllowed     Not logged on.
     * @exception OpNotSupported   When called for non-GbE boards.
     * @exception OpNotSucceeded   When BoardNr refers to a non-existing board
     * @exception OperationFailed  When packet window is smaller than 16, or higher than 250.
     *
     * @version Release 11.10
     */
    void SetDefaultRule_HM_PacketWindow(in unsigned short BoardNr, in unsigned short HitlessMergeDefaultPacketWindow)
        raises(TimeOut, OperationFailed, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);
    
    /// @} end of hitless_merge

    /// @} end of fec
#endif // DISABLE_FEC 
    
#ifndef DISABLE_GBE
    /** @defgroup statistics Statistics
     * This module contains types, enums and methods related to statistics gathering
     * @{
     */
    
    // Statistics structures IDLs
    // ------------------------------------------------------------------------------------
    struct GbEFramesRecv_t {           ///< Statistics about received frames
      unsigned long long Total;     ///< Total frames received
      unsigned long long Broadcast; ///< Broadcast frames
      unsigned long long Multicast; ///< Multicast frames
      unsigned long long Size64;    ///< 64 byte frames
      unsigned long long Size127;   ///< 65-127 byte frames
      unsigned long long Size255;   ///< 128-255 byte frames
      unsigned long long Size511;   ///< 256-511 byte frames
      unsigned long long Size1023;  ///< 512-1023 byte frames
      unsigned long long SizeMax;   ///< 1024-max byte frames
      unsigned long long Oversize;  ///< Oversize frames
      unsigned long long Control;   ///< Control frames
      unsigned long long VLAN;      ///< VLAN tagged frames
      unsigned long long Pause;     ///< Pause Frames
      unsigned long long FCS_Bad;   ///< FCS/CRC error
      unsigned long long Length_Type_Bad; ///< Length/Type out of range
      unsigned long long Opcode_Bad; ///< Invalid Opcode
      unsigned long long Undersize; ///< Undersized frames
      unsigned long long Fragment;  ///< Fragments
    };
    struct GbEFramesTrans_t {          ///< Statistics about transmitted frames
      unsigned long long Total;     ///< Total
      unsigned long long Broadcast; ///< Broadcast frames
      unsigned long long Multicast; ///< Multicast frames
      unsigned long long Control;   ///< Control frames
      unsigned long long Size64;    ///< 64 byte frames
      unsigned long long Size127;   ///< 65-127 byte frames
      unsigned long long Size255;   ///< 128-255 byte frames
      unsigned long long Size511;   ///< 256-511 byte frames
      unsigned long long Size1023;  ///< 512-1023 byte frames
      unsigned long long SizeMax;   ///< 1024-max byet frames
      unsigned long long VLAN;      ///< VLAN tagged frames
      unsigned long long Pause;     ///< Pause frames
      unsigned long long Oversize;  ///< Oversized frames
      unsigned long long Underrun;  ///< Buffer underrun
      /// Following items are -- not to be used -- since they are not applicable in
      /// Full-Duplex mode while GbE always runs in Full-Duplex mode
      unsigned long long SingleCollision; ///< Single collision
      unsigned long long MultiCollision;  ///< Multiple collisions
      unsigned long long Deferred;        ///< Deferred frames
      unsigned long long LateCollision;   ///< Late collisions
      unsigned long long CollisionAbort;  ///< Frames aborted by collisions
      unsigned long long CarrierSense;    ///< No carrier sense
      unsigned long long ExcessDeferral;  ///< Excess deferral
      /// end of -- not to be used --
    };
    
    struct GbEStatisticsEntry_t {      //< statisticst about 1 GbE port
      GbEFramesRecv_t Rx;
      GbEFramesTrans_t Tx;
      unsigned long long BytesRx;   ///< Bytes received
      unsigned long long BytesTx;   ///< Bytes transmitted
    } ;
    
    typedef GbEStatisticsEntry_t GbEStatistics_t[4];    ///< Statistics for all 4 ports on a GbE board

    struct GbEPortStatsEntry_t {
      IPS_Ref_t Port;               ///< The port for which the stats apply
      GbEStatisticsEntry_t Stats;   ///< The statistics
    };

    typedef sequence<GbEPortStatsEntry_t> GbEStatisticsEntryList_t; ///< A sequence of Statistics, one for each Gbe port on a board


    
    // Statistics IDLs
    // ------------------------------------------------------------------------------------
    /** Reset statistics.
     * 
     * @param[in] RefPhys specifies the BoardNr. PortNr is ignored
     * 
     * @exception OpNotSupported When called for other boards than GbE ones (Main, ASI,...).
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys).
     */
    void IPS_GBE_StatisticsReSet(in IPS_Ref_t RefPhys)                       
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get statistics
     * 
     * @param[in] RefPhys specifies the BoardNr. PortNr is ignored.
     * @param[out] Stats
     * 
     * @exception OpNotSupported When called for other boards than GbE ones (Main, ASI,...).
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys).
     * @deprecated Use IPS_GBE_StatisticsGetL instead.
     */
    void IPS_GBE_StatisticsGet(in IPS_Ref_t RefPhys, out GbEStatistics_t Stats) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get statistics rates per second.
     * Returned values are either since boot or since last call to this function.
     * 
     * @param[in] RefPhys specifies the BoardNr. PortNr is ignored.
     * @param[out] Stats
     * 
     * @exception OpNotSupported When called for other boards than GbE ones (Main, ASI,...).
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys).
     * @deprecated Use IPS_GBE_RatesGetL instead.
     */
    void IPS_GBE_RatesGet(in IPS_Ref_t RefPhys, out GbEStatistics_t Stats)      
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get statistics as a list of GbEStatisticsEntry_t
     * 
     * @param[in] RefPhys specifies the BoardNr. PortNr is ignored.
     * @param[out] Stats
     * 
     * @exception OpNotSupported When called for other boards than GbE or IP adapter ones (Main, ASI,...).
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys).
     *
     * @version release 6.9
     */
    void IPS_GBE_StatisticsGetL(in IPS_Ref_t RefPhys, out GbEStatisticsEntryList_t Stats) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get statistics rates per second.
     * Returned values are either since boot or since last call to this function.
     * 
     * @param[in] RefPhys specifies the BoardNr. PortNr is ignored.
     * @param[out] Stats
     * 
     * @exception OpNotSupported When called for other boards than GbE or IP adapter ones (Main, ASI,...).
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys).
     *
     * @version release 6.9
     */
    void IPS_GBE_RatesGetL(in IPS_Ref_t RefPhys, out GbEStatisticsEntryList_t Stats)      
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    /// @} end of group statistics
    
    
    /// @} end of gbe

    // IGMPv2
    ///////////////////////////////////////////////////////////////////////////
    
    /** @defgroup IGMPv2 IGMPv2
     * This module contains types, enums and methods related to IGMPv2.
     * @deprecated Use the IGMPv3 calls, they also support IGMP protcol v2
     * (use Exclude filter with no members).
     * These calls are scheduled for removal in v6.00
     * @{
     */
    
    // IGMPv2 structures and enums
    // ------------------------------------------------------------------------

    struct IGMPv2MulticastGroup_t
    {
      string    MulticastGroup; // Ip address of multicast group
      IPS_Ref_t RefPhys;
    };

    /// A sequence of IGMPv2MulticastGroup_t.
    typedef sequence<IGMPv2MulticastGroup_t> IGMPv2MulticastGroupList_t;

    // IGMPv2 IDLs
    // ------------------------------------------------------------------------

    /** Join zero or more multicast groups.
     * 
     * @param[in] RefPhys Board and port number to perform the join operation on.
     * @param[in] Groups List of multicast groups to join.
     * 
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded In case of
     *   - Invalid references (Groups[i].RefPhys).
     *   - Invalid multicast IP address (Groups[i].MulticastGroup).
     *   - Inconsistency between RefPhys.BoardNr and
     *     Groups[i].RefPhys.BoardNr.
     *   - Inconsistency between RefPhys.PortNr and
     *     Groups[i].RefPhys.PortNr in case RefPhys.PortNr != 0xFFFF. 
     *   - IGMP Individual mode is enabled (see below) 
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for a non-GbE board.
     */
    void IGMPv2JoinMulticastGroupL(in IPS_Ref_t RefPhys,
                                   in IGMPv2MulticastGroupList_t Groups) 
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Leave zero or more multicast groups.
     * 
     * @param[in] RefPhys Specifies BoardNr and PortNr.
     * @param[in] Groups List with multicast groups.
     * 
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded In case of
     *   - Invalid references (Groups[i].RefPhys).
     *   - Invalid multicast IP address (Groups[i].MulticastGroup).
     *   - Inconsistency between RefPhys.BoardNr and Groups[i].RefPhys.BoardNr.
     *   - Inconsistency between RefPhys.PortNr and Groups[i].RefPhys.PortNr
     *     in case RefPhys.PortNr != 0xFFFF. 
     *   - IGMP Individual mode is enabled (see below) 
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for a non-GbE board.
     */
    void IGMPv2LeaveMulticastGroupL(in IPS_Ref_t RefPhys,
                                    in IGMPv2MulticastGroupList_t Groups) 
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get the list with currently joined multicast groups. 
     *
     * @param[in] RefPhys Board and portnumber.
     *
     * @return Requested list with multicast groups.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded 
     *   - IGMP Individual mode is enabled (see below) 
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for a non-GbE board.
     *
     * @note If RefPhys.PortNr == 0xFFFF, information for all ports is
     *       returned.
     */
    IGMPv2MulticastGroupList_t IGMPv2GetMulticastGroupL(in IPS_Ref_t RefPhys) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Specify the multicast groups to be joined. No multicast group should exist yet, hence identical to IGMPv2JoinMulticastGroupL
     * Do not use.
     *
     * @param[in] RefPhys Board and portnumber.
     * @param[in] Groups  List with multicast groups.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded In case of
     *   - Invalid references (Groups[i].RefPhys).
     *   - Invalid multicast IP address (Groups[i].MulticastGroup).
     *   - Inconsistency between RefPhys.BoardNr and Groups[i].RefPhys.BoardNr.
     *   - Inconsistency between RefPhys.PortNr and Groups[i].RefPhys.PortNr
     *     in case RefPhys.PortNr != 0xFFFF. 
     *   - IGMP Individual mode is enabled (see below) 
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for a non-GbE board.
     */
    void IGMPv2SetMulticastGroupL(in IPS_Ref_t RefPhys,
                                  in IGMPv2MulticastGroupList_t Groups) 
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /// @} end of IGMPv2


    // IGMPv3
    /////////////////////////////////////////////////////////////////////////
    
    /** @defgroup IGMPv3 IGMPv3
     * This module contains types, enums and methods related to IGMPv3.
     * @{
     */
    
    // IGMPv3 structures and enums
    // ----------------------------------------------------------------------

    enum enumIGMP_Version
    {
      eIGMPv2, eIGMPv3
    };

    enum enumIGMPv3Filtertype
    {
      eIGMPv3IncludeSourceList, eIGMPv3ExcludeSourceList
    };

    // IGMPv3Group_t
    struct IGMPv3Group_t
    {
      IPS_Ref_t            RefPhys;        //< Port or PortSet reference. Can be a virtual port(set).
      string               MulticastGroup; //< IP address of multicast group
      boolean              bLeaveAllowed;  //< True if leave allowed from GUI
      enumIGMPv3Filtertype enFiltertype;
      sequence<string>     Filter;         //< Sequence of unicast IP addresses
    };
    
    typedef sequence<IGMPv3Group_t> IGMPv3GroupList_t;

    // IGMPv3 IDLs
    // ----------------------------------------------------------------------

    /**
     * Get the highest supported IGMP version.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Never thrown.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for a non-GbE board, or when
     *             this call is not supported in the running software version.
     */
    enumIGMP_Version GetIGMP_Version(in IPS_Ref_t RefPhys)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the highest IGMP version to be supported.
     *
     * @param[in] RefPhys   Board to which the setting applies.
     * @param[in] enVersion Either eIGMPv2 or eIGMPv3.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded When called with a non supported enVersion.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for a non-GbE board, or when
     *             this call is not supported in the running software version.
     */
    void SetIGMP_Version(in IPS_Ref_t RefPhys,
                         in enumIGMP_Version enVersion)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the list of multicast groups and filter specifications.
     *  This includes both the groups joined statically from the GUI and 
     *  multicast groups joined dynamically by the %DCM software.
     *
     *  Depending on the individual join mode, the RefPhys's are interpreted
     *  as PortSet or individual ports
     *
     * @param[in] RefPhys Port(Set) to retrieve information from. Wildcard and virtual port(set)s allowed.
     * @param[in] Groups  Groups to retrieve information about. Pass an empty
     *    sequence in order to retrieve all groups. Only m_iPortNr and
     *    m_MulticastAddres are interpreted, other IGMPv3Group_t members are
     *    ignored.
     *
     * @return Requested list with multicast settings.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded RefPhys is not a portset
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for a non-GbE board, or when
     *             this call is not supported in the running software version.
     */
    IGMPv3GroupList_t
    IGMPv3GetMulticastGroupL(in IPS_Ref_t RefPhys,
                             in IGMPv3GroupList_t Groups)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Join and/or leave multiple multicast groups. For an IGMPv2 join,
     *  specify filter mode E (exclusive) and an empty filter list.
     *  For leaving, specify filter mode I (inclusive) and an empty filter
     *  list. This call also allows to change the filter mode or filter list
     *  for a previously joined group.
     *
     *  Depending on the individual join mode, the RefPhys's are interpreted
     *  as PortSet or individual ports
     *
     * @param[in] RefPhys Number of the board to change settings on.
     * @param[in] Groups  Group list. Member m_bLeaveAllowed is ignored.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded The Portset we should join on does not exist,
     *    or if the number of joined multicast groups exceeds a predefined
     *    limit, or if it was attempted to leave a group that was not joined
     *    from the GUI.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for a non-GbE board, or when
     *             this call is not supported in the running software version.
     */
    void IGMPv3JoinLeaveL(in IPS_Ref_t RefPhys,
                          in IGMPv3GroupList_t Groups)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
   
    /** (Un)set individual join mode for this board. When enabled, it is possible
     *  to join a multicast address on a single interface and not on the port pair.
     *
     *  When switching from individual mode to paired mode, all multicast groups will
     *  be removed. When going from paired mode to individual mode, all groups are
     *  kept.
     *
     * @param[in] BoardNumber    The board to apply the call on.  Only DCG boards currently support this.
     * @param[in] bModeOn Enable the individuel mode
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded When boardnumber doesn't specify a DCG card.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When this call is not supported in the runningi
     *                           software version.
     *
     * @version 8.5
     **/
    void SetIGMP_IndividualMode(in unsigned short BoardNumber, in boolean bModeOn)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the individual join mode for this board.
     *
     * @param[in] BoardNumber    The board to apply the call on.  Only DCG boards currently support this.
     * @param[out] bModeOn Enable the individuel mode
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded When boardnumber doesn't specify a DCG card.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When this call is not supported in the runningi
     *                           software version.
     * @version 8.5
     *
     **/
    void GetIGMP_IndividualMode(in unsigned short BoardNumber, out boolean bModeOn)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /// @} end of IGMPv3

#endif // DISABLE_GBE


    // ADVANCED GBE STATISTICS: ERROR DETECTION AND THRESHOLD MONITORING
    /////////////////////////////////////////////////////////////////////////////////////// 

    /** @defgroup PCTM (Packet Counting and Threshold Monitoring)
     *
     * Advanced Statistics for the GbE board: counters and threshold monitoring both for
     * packets types before and after the error correction block for several configurations
     * such as FEC protection, Individual Ports Hitless Merge, Hitless Merge over
     * Separate Ports and also for when no error correction is enabled.
     * @{
     */



    /** Threshold settings. A non-zero threshold value denotes that
     *  threshold monitoring is enabled, otherwise disabled.
     *
     *  Unit: number of packets per 30 sec measurement window.
     */
    struct PCTM_ThresholdValues_t
    {
       unsigned long MissingPackets_BeforeErrorCorrection;
       unsigned long MissingPackets_AfterErrorCorrection;
       unsigned long FixedPackets;
       unsigned long OutOfRangePackets;
    };

    /** Threshold settings for the packet types of one stream.
     */
    struct PCTM_StreamThresholdSettings_t
    {
        IPS_RefTS_t            RefTSIn;
        PCTM_ThresholdValues_t ThresholdValues;
    };

    /** Threshold settings for the packet types of multiple streams.
     */
    typedef sequence<PCTM_StreamThresholdSettings_t> PCTM_StreamThresholdSettings_List_t;



    /** Packet counter values.
     *
     * Unit: number of packets.
     */
    struct PCTM_PacketCounters_t
    {
        unsigned long long MissingPackets_BeforeErrorCorrection_Main;
        unsigned long long MissingPackets_BeforeErrorCorrection_Backup;
        unsigned long long ValidPackets;
        unsigned long long MissingPackets_AfterErrorCorrection;
        unsigned long long FixedPackets;
        unsigned long long DuplicatePackets;
        unsigned long long ReorderedPackets;
        unsigned long long OutOfRangePackets;
    };

    /** Packet counters of one stream.
     */
    struct PCTM_StreamPacketCounters_t
    {
        IPS_RefTS_t           RefTSIn;
        PCTM_PacketCounters_t PacketCounters;
    };

    /** Packet counters of multiple streams.
     */
    typedef sequence<PCTM_StreamPacketCounters_t> PCTM_StreamPacketCounters_List_t;



    /** Set board default threshold settings for each packet type.
     *
     * @note The threshold settings comprise threshold values where a non-zero threshold value
     *       indicates the threshold monitoring is active for all counters of the respective
     *       packet type unless stream specific threshold settings decide otherwise.
     * @note If the threshold value for a stream's packet type is reached an alarm will be raised
     *       for the packet type of that specific stream. An evaluation is made at the end of
     *       each 30 sec measurement window ignoring measurements of previous windows. The alarm
     *       will automatically be cleared due to one of the next measurement window evaluations
     *       as soon as the threshold value was not exceeded during the new window.
     * @note Threshold values of zero imply no threshold monitoring is active so no alarms can be
     *       raised for that packet type. (unless for streams with stream specific settings that
     *       decide otherwise) Changing a non-zero threshold value back to zero will only clear
     *       the alarms for the respective packet type during the next measurement window
     *       evaluation. (unless for streams with stream specific settings that decide otherwise)
     * @note Enabling threshold monitoring for the Missing Packet before Error Correction
     *       packet type is only possible using stream specific threshold settings.
     *
     * @param[in] BoardNr               The slot/board to apply the default settings on.
     * @param[in] BoardDefaultSettings  The board default threshold settings to apply.
     *
     * @exception Timeout          Is thrown when it takes too long to handle the call;
     * @exception OpNotSucceeded   Is thrown when supplying an invalid or non-existing board nbr;
     * @exception OpNotSupported   Is thrown when called for another board than a GbE IO-board;
     * @exception OperationFailed  Is thrown when:
     *  - supplying a non-zero threshold value for the Missing Packet before Error Correction
     *    packet type.
     *
     * @version  Release 11.10
     */
    void PCTM_SetBoardDefThresholds(in unsigned short BoardNr, in PCTM_ThresholdValues_t BoardDefaultSettings)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Get board default threshold settings for each packet type.
     *
     * @param[in] BoardNr               The slot/board to retrieve the default settings from.
     * @param[in] BoardDefaultSettings  The board default threshold settings to retrieve.
     *
     * @exception Timeout         Is thrown when it takes too long to handle the call;
     * @exception OpNotSucceeded  Is thrown when supplying an invalid or non-existing board nbr;
     * @exception OpNotSupported  Is thrown when called for another board than a GbE IO-board;
     *
     * @version  Release 11.10
     */
    void PCTM_GetBoardDefThresholds(in unsigned short BoardNr, out PCTM_ThresholdValues_t BoardDefaultSettings)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Set or unset stream specific packet type thresholds settings that overwrite the board
     *  default settings. 
     *
     * @note The same general behaviour concerning threshold monitoring such as measurement
     *       windows, evaluations, alarm raising and clearing, and configuration as
     *       described for the board level default settings apply;
     * @note For each stream the board default threshold settings are used for each of its
     *       packet types unless stream specific threshold settings are supplied by providing 
     *       a non-zero threshold value for each packet type for which the board default is not
     *       to be used.
     * @note Disabling the stream specific threshold settings is done by providing
     *       a threshold value of zero for each of the stream's packet types where the
     *       board default is to be used again for.
     * @note Providing stream specific non-zero threshold values for the Missing Packet before
     *       Error Correction packet type will in addition enable the packet counter for
     *       the packet type of the stream, limited to 32 main TS per port pair.
     * @note Changing a non-zero stream specific threshold value back to zero while the board
     *       default threshold value for the same packet type is zero will as a side-effect
     *       trigger, if applicable, clearing the alarm of that stream for that packet type.
     *
     * @param[in] BoardNr                 The slot/board to apply the stream specific settings on.
     * @param[in] StreamSpecificSettings  The stream specific threshold settings.
     *
     * @exception Timeout          Is thrown when it takes too long to handle the call;
     * @exception OpNotSucceeded   Is thrown when supplying an invalid or non-existing board nbr;
     * @exception OpNotSupported   Is thrown when called for another board than a GbE IO-board;
     * @exception OperationFailed  Is thrown when:
     *  - supplying an empty list of settings;
     *  - supplying settings such that the total number of streams per board for which the
     *    Missing Packet before Error Correction threshold value is non-zero exceeds
     *    32 main TS per port pair;
     *
     * @version  Release 11.10
     */
    void PCTM_SetStreamThresholds(in unsigned short BoardNr, in PCTM_StreamThresholdSettings_List_t StreamSpecificSettings)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Get stream specific packet type thresholds settings.
     *
     * @remark  Both parameter 'Location' and 'Streams' are used to filter. If 'Streams' is
     *          an empty list, then use 'Location' to filter all streams on the specified
     *          location (board level, port level, etc.). If 'Streams' is not an empty list
     *          then return settings for the streams explicitly specified, but in that case
     *          the location is not allowed to conflict with any of the streams.
     *
     * @param[in] Location  The location to retrieve the stream specific settings from.
     * @param[in] Streams   The streams for which to retrieve the threshold settings.
     * @param[in] StreamSpecificSettings  The stream specific threshold settings.
     *
     * @exception Timeout         Is thrown when it takes too long to handle the call;
     * @exception OpNotSucceeded  Is thrown when supplying an invalid or non-existing board nbr;
     * @exception OpNotSupported  Is thrown when called for another board than a GbE IO-board;
     *
     * @version  Release 11.10
     */
    void PCTM_GetStreamThresholds(in IPS_Ref_t Location,
                                  in IPS_RefTS_List_t Streams,
                                  out PCTM_StreamThresholdSettings_List_t StreamSpecificSettings)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Get packet counters of one, multiple or all streams.
     *
     * @note  Packet counters can be retrieved for all packet types both in case:
     *  - no error correction is configured;
     *  - FEC protection is enabled;
     *  - Single Port Hitless Merge is enabled;
     *  - Hitless Merge over Separate Ports is enabled;
     * @note  In general, the Missing Packets before Error Correction counters are only
     *        increased for those streams for which stream specific settings have a non-zero
     *        threshold value. (limited to maximimally 32 main TS per port pair)
     * @note  If no error correction is configured, only the Valid Packet counters and the
     *        Missing Packets after Error Correction counters are increased.
     * @note  The Fixed Packet counters are only increased if FEC protection is used.
     *
     * @remark  Both parameter 'Location' and 'Streams' are used to filter. If 'Streams' is
     *          an empty list, then use 'Location' to filter all streams on the specified
     *          location (board level, port level, etc.). If 'Streams' is not an empty list
     *          then return packet counters for the streams explicitly specified, but in that
     *          case the location is not allowed to conflict with any of the streams.
     *
     * @param[in] Location        The slot/board to fetch the counters from.
     * @param[in] Streams         The streams for which to retrieve the packet counters.
     * @param[in] PacketCounters  The retrieved packet counters of the specified streams.
     *
     * @exception Timeout         Is thrown when it takes too long to handle the call;
     * @exception OpNotSucceeded  Is thrown when supplying an invalid or non-existing board nbr;
     * @exception OpNotSupported  Is thrown when called for another board than a GbE IO-board;
     *
     * @version  Release 11.10
     */
    void PCTM_GetPacketCounters(in IPS_Ref_t Location, in IPS_RefTS_List_t Streams, out PCTM_StreamPacketCounters_List_t PacketCounters)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Reset all packet counters, clear all threshold alarms and restart all threshold
     *  measurement windows.
     *
     * @note reset will also reset the existing 'FEC Dec statistics'
     *
     * @param[in] BoardNr         The slot/board to reset.
     *
     * @exception Timeout         Is thrown when it takes too long to handle the call;
     * @exception OpNotSucceeded  Is thrown when supplying an invalid or non-existing board nbr;
     * @exception OpNotSupported  Is thrown when called for another board than a GbE IO-board;
     *
     * @version  Release 11.10
     */
    void PCTM_Reset(in unsigned short BoardNr)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /// @} end of PCTM

#ifndef DISABLE_LICENSING
    // Licensing
    /////////////////////////////////////////////////////////////////////////////////////// 
    
    /** @defgroup license License
     * This module contains types, enums and methods related to license.
     * @{
     */
    
    // License structures & enums
    // ------------------------------------------------------------------------------------
    
    /// Feature Status
    enum eFeatureState 
    {
      eFeatureInvalid,      ///< --> Value may not be used !!!
      eFeatureDisabled,
      eFeatureEnabled
    };
    
    /// Feature Type
    enum eFeatureType
    {
      eFeatureUnknown,
      eFeatureInherited, 
      eFeatureNative
    };
    
    /// Install State
    enum eFeatureInstallState
    {
      eFeatureEmpty,          ///< invalid or unused table entry
      eFeatureNotInstalled,   ///< no valid license key has ever been entered
      eFeatureInstalled
    };
    
    /// obsolete: not used for temporary licenses
    /// a temporary license gives access to all feature during a limited time.
    enum eFeatureExpireState
    {
      eFeatureExpired,
      eFeatureNotExpired
    };   
    
    struct Feature_t
    {
      eFeatureState Status;
      eFeatureInstallState Install;
      eFeatureType Type;
      eFeatureExpireState Expired;

      string Name; ///< Max string length 36
      string Version; ///< Max string length 36
      string Date; ///< Max string length 36
      string Key; ///< Max string length 36
      long  Count;
      long  Used;
      long  TimeLeft;
    };
      
    /// Sequence of Features ...
    typedef sequence <Feature_t> FeatureList_t;

    /** UnInstalls the license of a feature.
     * 
     * @param[in] BoardNr
     * @param[in] Name FeatureName to uninstall.
     * 
     * @exception OpNotSucceeded
     * - BoardNr != 0 (mainboard only) 
     * - Feature is not supported     
     * 
     * @note The IDL-call to install the Features is described in the DCM_MB.idl document.
     */
    void UninstallFeature(in unsigned short BoardNr, in string Name) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Sets the state of a feature.
     * 
     * @param[in] BoardNr
     * @param[in] Name FeatureName. 
     * @param[in] State Disable or Enable.
     * 
     * @exception OpNotSucceeded
     * - BoardNr != 0 (mainboard only)
     * - State is not valid
     * - Feature can't be enabled when feature isn't installed
     * - Feature is not supported
     */
    void SetFeatureState(in unsigned short BoardNr, in string Name, in eFeatureState State) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** GetHostId.
     * 
     * @param[in] BoardNr
     * @param[out] HostId
     * 
     * @exception OpNotSucceeded
     * - Boadnr != 0 (mainboard only)
     */
    void GetHostId(in unsigned short BoardNr,out string HostId) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** GetFamilyName.
     * 
     * @param[in] BoardNr
     * @param[out] FamilyName
     * 
     * @exception OpNotSucceeded
     * - Boadnr != 0 (mainboard only)
     */
    void GetFamilyName(in unsigned short BoardNr,out string FamilyName) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Gets the settings of all the registerd features.
     * 
     * @param[in] BoardNr
     * 
     * @return FeatureList
     * 
     * @exception OpNotSucceeded
     * - Boadnr != 0 (mainboard only)
     */
    FeatureList_t GetFeatureSettings(in unsigned short BoardNr) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    struct LicenseValidation_t
    {
      string Version; ///< Version of the licenses
      string ValidationKey; ///< Validation Key 
    };
        
    /** GetVersionAndValidationKey.
     * 
     * @param[in] BoardNr
     * 
     * @return LicenseValidation_t
     * 
     * @exception OpNotSucceeded
     * - Boadnr != 0 (mainboard only)
     */
    LicenseValidation_t GetLicenseValidation(in unsigned short BoardNr)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    enum eDeviceState
    {
      eDeviceStateInvalid,   ///< Device is in an invalid state, meaning no licenses can be taken.
      eDeviceStateMain,      ///< Device is MAIN 
      eDeviceStateBackup,    ///< Device is BACKUP
      eDeviceStateReserved1, ///< reserved for future use
      eDeviceStateReserved2, ///< reserved for future use
      eDeviceStateReserved3, ///< reserved for future use
      eDeviceStateReserved4  ///< reserved for future use
    };

    /** GetDeviceState.
     * 
     * @param[in] BoardNr
     *
     * @return eDeviceState
     * 
     * @exception OpNotSucceeded
     * - Boadnr != 0 (mainboard only)
     */
    eDeviceState GetDeviceState(in unsigned short BoardNr)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    typedef unsigned short TempLicenseState_t;
    const TempLicenseState_t TEMP_LICENSE_NOT_ACTIVE = 0; ///< no temporary licenses active
    const TempLicenseState_t TEMP_LICENSE_ACTIVE = 1;     ///< temporary licenses active
    const TempLicenseState_t TEMP_LICENSE_WAITING = 2;    ///< temporary licenses waiting for the start time to become active

    struct TempLicenseData 
    {
      TempLicenseState_t State;
      Time ExpirationDate; ///< time of expiration of the temporary licenses in the local timezone
      boolean RebootNeeded;
    };

    /** Gets the data of the Temporary Licenses.
     * 
     * @param[in] BoardNr
     *
     * @return TempLicenseData
     * 
     * @exception OpNotSucceeded
     * - Boadnr != 0 (mainboard only)
     */
    TempLicenseData GetTempLicenseData(in unsigned short BoardNr)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Makes sure the temporary licenses are expired at the time the users wants it.
     *  Remark: when this is not used, the temporary licenses will expire on the
     *  given expiration time and the system will reboot in case there are more
     *  licenses used than there are licenses available per feature.
     * 
     * @param[in] BoardNr
     * 
     * @exception OpNotSucceeded
     * - Boadnr != 0 (mainboard only)
     */
    void ExpireTempLicenses(in unsigned short BoardNr)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * Represents the license usage count per feature.
     */
    struct FeatureUsage_t
    {
      string FeatureName; ///< unique name identifying the feature.
      long   UsageCount;  ///< the number of licenses in use for this feature.
    };

    /// A list of FeatureUsage_t elements.
    typedef sequence<FeatureUsage_t> FeatureUsageList_t;

    /**
     * Contains the feature usage per board.
     */
    struct BoardFeatureUsage_t
    {
      unsigned short BoardNr;              ///< the slot number.
      FeatureUsageList_t FeatureUsageList; ///< a list of all the used features.
    };

    /// A list of BoardFeatureUsage_t elements.
    typedef sequence<BoardFeatureUsage_t> BoardFeatureUsageList_t;

    /** Returns the licenses in use per feature and per board. T
     * 
     * @param[in] BoardNr board number. Should be 0.
     * @return BoardFeatureUsageList_t
     * 
     * @exception OpNotSucceeded
     * - Boadnr != 0 (mainboard only)
     *
     * @version Release 8.5
     */
    BoardFeatureUsageList_t GetBoardFeatureUsageL(in unsigned short BoardNr)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /// @} end of license
#endif // DISABLE_LICENSING 

#ifndef DISABLE_BACKUP
    // BACKUP
    /////////////////////////////////////////////////////////////////////////////////////// 
    
    /** @defgroup backup Backup
     * In this group different backup type definitions, enums and methods are
     * defined.
     * @{
     */
        
    /** @defgroup service_ts_backup TS and Service Backup
     * @{
     */

    // ------------------------------------------------------------------------------------
     
    /** Bitmap of triggers.
     *
     * For service loss triggers the bits have following meaning.
     * - bit 0: indicates that active link loss should be used as trigger. (Supported after 3.0).
     * - bit 1: indicates that UDP loss should be used as trigger. (Supported after 3.0).
     * - bit 2: indicated that UDP stream loss should be used as trigger.
     * - bit 3: indicates that ASI/8VSB/DVBS2 sync loss should be used as trigger.
     * - bit 4: indicates that any pid error should be used as trigger.
     * - bit 5: indicates that "smart" pid error should be used as trigger. (Supported after 3.0).
     * - bit 6: indicates that a pid list error should be used as trigger.
     * - bit 7: indicates that PMT error should be used as trigger.
     * - bit 8: indicates that missing in PAT should be used as trigger (only for routed services).
     * - bit 9: indicates that a scrambled input should be used as trigger (Supported after 4.5).
     * - bit 10: indicates that any pid bitrate too low should be used as trigger.
     * - bit 11: indicates that "smart" bitrate too low should be used as trigger.
     * - bit 12: indicates that a pid list for bitrate too low should be used as trigger.
     * - bit 13: indicates that hardware GPI contact 1 should be used as trigger.
     * - bit 14: indicates that hardware GPI contact 2 should be used as trigger.
     * - bit 15: indicates that hardware GPI contact 3 should be used as trigger.
     * - bit 16: indicates that hardware GPI contact 4 should be used as trigger.
     * - bit 17: indicates that hardware GPI contact 5 should be used as trigger.
     * - bit 18: indicates that a not descrambled pid should be used as trigger (from 8.9 on).
     * - bit 19: indicates that an attempt to descramble a pid in the clear should be used as trigger (from 8.9 on). 
     * - bit 20: indicates that MFP video loss should be used as trigger (from 10.1 on).
     * - bit 21: indicates that MFP audio loss should be used as trigger (from 10.10 on).
     * - bit 22: indicates that MFP SD/HD mismatch should be used as trigger (from 11.10 on).
     * - bit 23: indicates that MFP MPEG/AVC mismatch should be used as trigger (from 11.10 on).
     *
     * For TS loss triggers the bits have following meaning.
     * - bit 0: indicates that active link loss should be used as trigger. (Supported from 7.1 onwards).
     * - bit 1: indicates that UDP loss should be used as trigger. (Supported from 7.1 onwards).
     * - bit 2: indicated that UDP stream loss should be used as trigger.
     * - bit 3: indicates that ASI sync loss should be used as trigger.
     * - bit 4: indicates that sync byte error should be used as trigger. 
     * - bit 5: indicates that service loss should be used as trigger. 
     * - bit 6: indicates that PAT error should be used as trigger. (Supported from 7.1 onwards).
     * - bit 7: indicates that a not descrambled pid should be used as trigger (from 8.9 on).
     */
    typedef unsigned long TriggerBitmap_t;

    /** Set the default Service Loss Alarm triggers.
     * 
     * @param[in] RefPhys specifies BoardNr and PortNr.
     * @param[in] TriggerBitmap
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case of
     * - Invalid references RefPhys (BoardNr, PortNr).
     * - if not supported TriggerBitmap bits are used (higher than 17).
     * - if TriggerBitmap bit 2 (UDP stream loss) is enabled on an ASI board.
     * - if TriggerBitmap bit 3 (ASI sync loss) is enabled on a GBE board.
     * - if TriggerBitmap bit 6 (pid list error) is enabled. Is not allowed as default setting.
     * - if TriggerBitmap bits 4 (any pid error), 5 (smart pid error) and 6 (pid list error) are enabled together.
     * - if TriggerBitmap bit 12 (pid list bitrate error) is enabled. Is not allowed as default setting.
     * - if TriggerBitmap bits 10 (any pid bitrate error), 11 (smart pid bitrate error) and 12 (pid list bitrate error) are enabled together.
     * - if TriggerBitmap contains a combination of more than one of the bits 13 to 17, only 1 GPI pin can be set as a trigger.
     * - if TriggerBitmap bit 13 is set, GPI pin 1 is reserved for IPSec.
     */
    void SetDefaultServiceLossTriggers(in IPS_Ref_t RefPhys, in TriggerBitmap_t  TriggerBitmap)  
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported); 

    /** Get the default Service Loss Alarm triggers.
     * 
     * @param[in] RefPhys specifies BoardNr and PortNr.
     * @param[out] TriggerBitmap 
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case of invalid references RefPhys (BoardNr, PortNr).
     */                                                       
    void GetDefaultServiceLossTriggers(in IPS_Ref_t RefPhys, out TriggerBitmap_t  TriggerBitmap)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported); 
        
    /** Set the default TS Loss Alarm triggers.
     * 
     * @param[in] Board specifies BoardNr.
     * @param[in] TriggerBitmap
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case of
     * - If not supported TriggerBitmap bits are used (bit 7 and higher).
     * - If TriggerBitmap bit 0 (link loss), bit 1 (UDP loss) or bit 2 (UDP stream loss) is enabled on an ASI board.
     * - If TriggerBitmap bit 3 (ASI sync loss) is enabled on a GBE board.
     */
    void SetDefaultTS_LossTriggers(in unsigned short Board, in TriggerBitmap_t TriggerBitmap)  
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported); 

    /** Get the default TS Loss Alarm triggers.
     * 
     * @param[in] Board specifies BoardNr.
     * @param[out] TriggerBitmap 
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     */                                                       
    void GetDefaultTS_LossTriggers(in unsigned short Board, out TriggerBitmap_t TriggerBitmap)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported); 
      
    struct ServiceLossTrigger_t
    {
      IPS_Service_t service;
      TriggerBitmap_t triggerBitmap;
      PID_List_t pidList;  ///< PID range: 0..8190, List of pids to monitor: only evaluated in case bit 6 in the TriggerBitmap_t is set. 
    };
    /// A sequence of ServiceLossTrigger_t.
    typedef sequence< ServiceLossTrigger_t > ServiceLossTriggerList_t;
    
    /** Set the service loss triggers for specified services on given TS.
     * 
     * @param[in] RefTS specifies BoardNr, PortNr.and TS
     * @param[in] TriggerList
     *
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case of
     * - Invalid reference RefTS (BoardNr, PortNr and TS).
     * - Not existent TS or not an input TS.
     * - TriggerList.Service.RefTS different from RefTS.
     * - If not supported TriggerBitmap bits are used (bits higher than 17).
     * - If TriggerBitmap bit 2 (UDP stream loss) is enabled on an ASI board.
     * - If TriggerBitmap bit 3 (ASI sync loss) is enabled on a GBE board.
     * - If TriggerBitmap bits 4 (any pid error), 5 (smart pid error) and 6 (pid list error) are enabled together.
     * - If TriggerBitmap bit 6 (pid list error) is enabled with an empty PidList.
     * - If TriggerBitmap bits 10 (any pid bitrate error), 11 (smart pid bitrate error) and 12 (pid list bitrate error) are enabled together.
     * - If TriggerBitmap bit 12 (pid list error) is enabled with an empty PidList.
     * - if TriggerBitmap contains a combination of more than one of the bits 13 to 17, only 1 GPI pin can be set as a trigger.
     * - if TriggerBitmap bit 13 is set, GPI pin 1 is reserved for IPSec.
     */
    void SetServiceLossTriggers(in IPS_RefTS_t RefTS, in ServiceLossTriggerList_t TriggerList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Reset the service loss triggers for specified services on given TS.
     * This call serves to let given service(s) follow the default.
     * The service specific bitmap and eventual pid list are cleared.
     * 
     * @param[in] RefTS specifies BoardNr, PortNr.and TS.
     * @param[in] InputSidList When empty the triggers for ALL services are reset to follow the default again.
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case of
     * - Invalid reference RefTS (BoardNr, PortNr and TS).
     * - Not existent TS or not an input TS.
     */
    void ResetServiceLossTriggers(in IPS_RefTS_t RefTS, in ServiceIdList_t InputSidList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
      
    /** Get the service loss triggers for all or specified input services on given Port and TS.
     * 
     * @param[in] RefTS specifies BoardNr, PortNr and TS.
     *      wildcard RefTS.Ref == INVALID_REF for all TS's.
     * @param[in] InputSidList when empty, the triggers for ALL services are given.
     * @param[out] TriggerList
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case of
     * - Invalid reference RefTS (BoardNr, PortNr and TS).
     * - Not existent TS or not an input TS.
     * - Not existent service ID's
     * 
     * @note TriggerList.PidList will be empty if bit 6 (PID list error) or bit 12 (PID list birate error)of TriggerList.TriggerBitmap is FALSE 
     * Not supported bits in TriggerList.TriggerBitmap will always be 0.
     */
    void GetServiceLossTriggers(in IPS_RefTS_t RefTS, in ServiceIdList_t InputSidList, out ServiceLossTriggerList_t TriggerList)  
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported); 

    struct TS_LossTrigger_t
    {
      IPS_RefTS_t RefTS;
      TriggerBitmap_t triggerBitmap;
    };
    /// A sequence of TS_LossTrigger_t.
    typedef sequence<TS_LossTrigger_t> TS_LossTriggerList_t;
    
    /** Set the TS loss triggers for specified TS's on given port.
     * 
     * @param[in] Ref specifies BoardNr, PortNr.
     * @param[in] TriggerList
     *
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case of
     * - Invalid reference Ref (BoardNr, PortNr)
     * - Not existent TS or not an input TS.
     * - TriggerList.RefTS.PhysRef different from Ref.
     * - If not supported TriggerBitmap bits are used (bit 7 and higher).
     * - If TriggerBitmap bit 0 (link loss), bit 1 (UDP loss) or bit 2 (UDP stream loss) is enabled on an ASI board.
     * - If TriggerBitmap bit 3 (ASI sync loss) is enabled on a GBE board.
     */
     void SetTS_LossTriggers(in IPS_Ref_t Ref, in TS_LossTriggerList_t TriggerList)  
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Reset the TS loss triggers for specified TS's on given port.
     * This call serves to let given TS(s) follow the board default.
     * The TS specific bitmap is cleared.
     * 
     * @param[in] Ref specifies BoardNr, PortNr.
     * @param[in] RefList When empty the triggers for ALL TS's are reset to follow the default again.
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case of
     * - Invalid reference Ref (BoardNr, PortNr).
     * - Not existent TS or not an input TS.
     * - No input TS's are found on given port.
     */
    void ResetTS_LossTriggers(in IPS_Ref_t Ref, in Ref_List_t RefList)  
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get the TS loss triggers for all or specified input TS's on given Port.
     * 
     * @param[in] Ref specifies BoardNr, PortNr.
     *      wildcard Ref.PortNr == INVALID_PORT for all ports.
     * @param[in] RefList when empty, the triggers for ALL TS's are given.
     * @param[out] TriggerList
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case of
     * - Invalid reference RefTS (BoardNr, PortNr).
     * - Not existent TS or not an input TS.
     * 
     * @remark Not supported bits in TriggerList.TriggerBitmap will always be 0.
     * @remark When no input TS's are found on given port, an empty list is returned.
     */
    void GetTS_LossTriggers(in IPS_Ref_t Ref, in Ref_List_t RefList, out TS_LossTriggerList_t TriggerList)  
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /// @} end of service_ts_backup

    /** @defgroup one_to_one_backup 1:1 Device Backup
     * @{
     */

    // Device active/inactive mode.
    // Various features can be configured to act upon the active/inactive status
    // of the DCM. This status can be set through one of following ways, depending on settings:
    // - Externally by a management system like the Cisco ROSA EM (Standalone role)
    // - Negotiated between 2 DCMs in a main/backup configuration (Main/Backup role)
    // - Negotiated between 2 DCMs in a live-live configuration (Live-Live role)
    // - Independently per DCM (Single role)
    // The latter two use the status of the configurable Device Operational Failure alarm
    // to decide whether the DCM has an error and requires failover/deactivation.
    //
    // The main/backup configuration is typically used in a hot-standby setup (active/inactive) where
    // no 2 devices are active at the same point in time.
    // The single and live-live configurations are typically used in an active/active setup where
    // both devices are active at the same time.
    //
    // In a main/backup configuration revertive behaviour can be selected from one of the following:
    // - Non-Revertive: a manual action is required to activate the main DCM after failover.
    //                  (this mode is also available for Single role and causes the device to remain
    //                   inactive after the error cleared)
    // - Auto-Revertive: the main device is automatically reactivated if the error has cleared.
    //                   (this mode is also available for Single role and causes the device to
    //                    reactivate automatically after the error cleared)
    // - Floating-Revertive: the last active device remains active until an error occurs thus
    //                       minimizing the number of failovers per error event.

    enum eDeviceActiveMode
    {
      DeviceMode_Active,        ///< Device is the active device
      DeviceMode_Inactive       ///< Device is the inactive device
    };

    /** Set the device mode.
     *
     * @param[in] DeviceActiveMode
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded When called with an invalid mode.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for a non-GbE board, or when
     *             this call is not supported in the running software version.
     *
     * @note The device mode is a volatile setting: it is retained as long
     *   as the software keeps running, but is reset to PowerupDeviceActiveMode
     *   after a power failure or warm reboot.
     */
    void SetDeviceActiveMode(in eDeviceActiveMode DeviceActiveMode)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported); 

    /** Query the device mode.
     *
     * @param[out] DeviceActiveMode
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded On internal error only.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for a non-GbE board, or when
     *             this call is not supported in the running software version.
     */
    void GetDeviceActiveMode(out eDeviceActiveMode DeviceActiveMode)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported); 

    /** Set the power-up device mode.
     *
     * @param[in] DeviceActiveMode
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded When called with an invalid mode.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for a non-GbE board, or when
     *             this call is not supported in the running software version.
     *
     * @note The power-up device mode is a non-volatile setting, which is
     *   restored to the last set value after power failure or warm reboot.
     */
    void SetPowerupDeviceActiveMode(in eDeviceActiveMode DeviceActiveMode)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported); 

    /** Get the power-up device mode.
     *
     * @param[out] DeviceActiveMode
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded On internal error only.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for a non-GbE board, or when
     *             this call is not supported in the running software version.
     *
     * @version Release4.0
     */
    void GetPowerupDeviceActiveMode(out eDeviceActiveMode DeviceActiveMode)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported); 
    
    /** Get the peer device mode.
     *
     * @param[out] DeviceActiveMode
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded On internal error only.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for a non-GbE board, or when
     *             this call is not supported in the running software version.
     *
     * @version Release4.0
     */
    void GetPeerDeviceActiveMode(out eDeviceActiveMode DeviceActiveMode)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported); 
    
    enum eDeviceRole
    {
      DeviceRole_Standalone,     ///< Device does not take part in device backup
                                 ///  or is managed externally (e.g. ROSA EM)
      DeviceRole_Main,           ///< Device is main device
      DeviceRole_Backup          ///< Device is backup device
    };

    enum eDeviceRole_V2
    {
      DeviceRole_V2_Standalone,     ///< Device does not take part in device backup
                                    ///  or is managed externally (e.g. ROSA EM)
      DeviceRole_V2_Main,           ///< Device is main device
      DeviceRole_V2_Backup,         ///< Device is backup device
      DeviceRole_V2_Single,         ///< Device acts solely upon its own status
      DeviceRole_V2_LiveLive,       ///< Device is in a live-live configuration
      DeviceRole_V2_Reserved_005,
      DeviceRole_V2_Reserved_004,
      DeviceRole_V2_Reserved_003,
      DeviceRole_V2_Reserved_002,
      DeviceRole_V2_Reserved_001
    };
    
    enum eDBURevertMode
    {
      DBURevertMode_None,        ///< Device requires manual action after failover
      DBURevertMode_Revertive,   ///< Device reverts to main when failure solved
      DBURevertMode_Floating,    ///< Active device remains active until failure
                                 ///  regardless of main/backup setting
      DBURevertMode_Reserved_003,
      DBURevertMode_Reserved_004,
      DBURevertMode_Reserved_005
    };

    /** Configuration of a link between 2 devices for use with Device Backup.
     *  The primary link is always mandatory when heartbeat is used.
     **/
    struct DeviceBackupLink_t
    {
      IPS_Ref_t NetworkInterface;     ///< Specify BoardNr = 0 and PortNr = 0
                                      ///  for the 10/100 management network
                                      ///  interface and PortNr = 1 for the GbE
                                      ///  C/A network interface
      string PeerIPAddress;           ///< IP address of the other DCM, as
                                      ///  reachable via the specified network
                                      ///  interface.
      unsigned short ProtocolUDPPort; ///< UDP port to be used by both DCM's.
                                      ///  Must be the same on both DCM's for
                                      ///  this link.
    };

    typedef sequence<DeviceBackupLink_t> DeviceBackupLinkList_t;

    struct DeviceBackupParams_t
    {
      eDeviceRole DeviceRole;           ///< Role of this device. Other settings
                                        ///  are only valid if the role is not
                                        ///  standalone.
      string PeerIPAddress;             ///< IP Address of the other DCM.
      unsigned short ProtocolUDPPort;   ///< UDP Port to be used by both DCM's.
                                        ///  Must be the same value on both
                                        ///  devices.
      IPS_Ref_t NetworkInterface;       ///< Specify BoardNr = 0 and PortNr = 0
                                        ///  for the 10/100 management network
                                        ///  interface and PortNr = 1 for the
                                        ///  GbE C/A network interface.
      boolean Revertive;                ///< True if the device should
                                        ///  automatically revert to main when
                                        ///  possible
      unsigned long MainToBackupDelay;  ///< Time in seconds to wait before
                                        ///  switching to backup device, 
                                        ///  range 1-60 s
      unsigned long BackupToMainDelay;  ///< Time in seconds to wait before
                                        ///  switching back to main device,
                                        ///  range 0-60 s
    };

    /**
     * Following combinations of Roles and Modes are valid:
     * - Standalone: None
     * - Main/Backup: None, Revertive, Floating
     * - Single: None, Revertive
     * - Live-Live: Revertive
     **/
    struct DeviceBackupParamsV2_t
    {
      eDeviceRole_V2 DeviceRole;        ///< Role of this device.
      DeviceBackupLinkList_t Links;     ///< Links towards peer (0 in case of standalone)
      eDBURevertMode RevertMode;        ///< Revertive mode.
      unsigned long MainToBackupDelay;  ///< Time in seconds to wait before
                                        ///  switching to backup device or deactivating, 
                                        ///  range 1-60 s
      unsigned long BackupToMainDelay;  ///< Time in seconds to wait before
                                        ///  switching back to main device or reactivating,
                                        ///  range 0-60 s
    };
    
    /** Sets the parameters to be used by Device Backup
     *
     * @param[in] DeviceBackupParams
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When this call is not supported in the running
     *                           software version.
     * @exception OpNotSucceeded When any of the following occurs:
     *                            - Peer IP Address is invalid
     *                            - UDP Port used by another application
     *                            - Network interface is invalid
     *                            - Delay values are outside allowed range
     */
    void SetDeviceBU_Params(in DeviceBackupParams_t DeviceBackupParams)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Gets the parameters used by Device Backup
     *
     * @param[out] DeviceBackupParams
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When this call is not supported in the running
     *                           software version.
     * @exception OpNotSucceeded On internal error or whether the settings
     *                           cannot be expressed due to version mismatch.
     *                           
     */
    void GetDeviceBU_Params(out DeviceBackupParams_t DeviceBackupParams)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Sets the parameters to be used by Device Backup
     *
     * @param[in] DeviceBackupParams
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When this call is not supported in the running
     *                           software version.
     * @exception OpNotSucceeded When any of the following occurs:
     *                            - Peer IP Address is invalid
     *                            - Insufficient or duplicate links
     *                            - UDP Port used by another application
     *                            - Network interface is invalid
     *                            - Delay values are outside allowed range
     *                            - Invalid role or revertive mode
     */
    void SetDeviceBU_ParamsV2(in DeviceBackupParamsV2_t DeviceBackupParams)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Gets the parameters used by Device Backup
     *
     * @param[out] DeviceBackupParams
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When this call is not supported in the running
     *                           software version.
     * @exception OpNotSucceeded On internal error only
     */
    void GetDeviceBU_ParamsV2(out DeviceBackupParamsV2_t DeviceBackupParams)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
      
    /** Instructs this device to gracefully become the active device.
     * If the device is a main device then this call will result in a manual
     * restore operation.
     * If the device is a backup device then this call will result in a manual 
     * backup operation.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When this call is not supported in the running 
     *                           software version.
     * @exception OpNotSucceeded On internal error only
     **/
    void DeviceBU_ActivateDevice()
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    
    // In a 1:1 backup setup it is important that unicast video streams, ads
    // and control data sent to one of the two %DCM's arrive at the right %DCM.
    // This is possible by sending this data to a secondary IP address, also
    // known as IP alias, and by making sure that this IP alias is only
    // defined on the active %DCM. This is possible by using the IDL calls
    // defined below and by defining the same IP alias on corresponding %DCM
    // network interfaces in auto activation mode.

    enum eActivationMode
    {
      ActivationMode_Active,
      ActivationMode_Inactive,
      ActivationMode_Auto
    };

    /** Set activation mode for the list of IP aliases associated with a
     * specific network interface.
     *
     * @param[in] RefPhys        BoardNr and PortNr of the network interface.
     *    Board numbers 1..n refer to the I/O boards. Specify BoardNr = 0
     *    and PortNr = 0 for the 10/100 network interface, and
     *    PortNr = 1 for the GbE network interface. If BoardNr = 0xffff,
     *    PortNr is ignored and the setting is applied to all boards. If
     *    PortNr = 0xffff, the setting is applied to all ports of the
     *    specified board.
     * @param[in] ActivationMode Activation mode for the IP aliases.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded When called with an invalid ActivationMode,
     *    when one of the specified aliases is outside the subnet associated
     *    with the specified network interface, when one of the specified
     *    aliases conflicts with the IP address assigned to another GbE
     *    network interface, static route or static ARP entry.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for an ASI board, or when
     *             this call is not supported in the running software version.
     */
    void SetIP_AliasMode(in IPS_Ref_t RefPhys,
                         in eActivationMode ActivationMode)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get activation mode for the list of IP aliases associated with a
     * specific network interface.
     *
     * @param[in] RefPhys        BoardNr and PortNr of the network interface.
     *    Board numbers 1..n refer to the I/O boards. Specify BoardNr = 0
     *    and PortNr = 0 for the 10/100 network interface, and
     *    PortNr = 1 for the GbE network interface.
     * @param[in] ActivationMode Activation mode for the IP aliases.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded When RefPhys is invalid.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for an ASI board, or when
     *             this call is not supported in the running software version.
     */
    void GetIP_AliasMode(in IPS_Ref_t RefPhys,
                         out eActivationMode ActivationMode)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the list of IP aliases associated with a specific network
     * interface.
     *
     * @param[in] RefPhys        BoardNr and PortNr of the network interface.
     *    Board numbers 1..n refer to the I/O boards. Specify BoardNr = 0
     *    and PortNr = 0 for the 10/100 network interface, and
     *    PortNr = 1 for the GbE network interface.
     * @param[in] IP_Addresses   List of IP secondary IP addresses.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded When called with an invalid ActivationMode,
     *    when one of the specified aliases is outside the subnet associated
     *    with the specified network interface, when one of the specified
     *    aliases conflicts with the IP address assigned to another GbE
     *    network interface, static route or static ARP entry.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for an ASI board, or when
     *             this call is not supported in the running software version.
     */
    void SetIP_AliasList(in IPS_Ref_t RefPhys,
                         in IP_List_t IP_Addresses)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the list of IP aliases associated with a specific network
     * interface.
     *
     * @param[in] RefPhys        BoardNr and PortNr of the network interface.
     *    Board numbers 1..n refer to the I/O boards. Specify BoardNr = 0
     *    and PortNr = 0 for the 10/100 network interface, and
     *    PortNr = 1 for the GbE network interface.
     * @param[in] IP_Addresses   List of IP secondary IP addresses.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded When RefPhys is invalid.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When called for an ASI board, or when
     *             this call is not supported in the running software version.
     */
    void GetIP_AliasList(in IPS_Ref_t RefPhys,
                         out IP_List_t IP_Addresses)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Sets the list of triggers that define when a backup is needed.
     * When one of the Alarm-triggers is open then the "Device Operational
     * Failure" alarm is open, which triggers the 1:1 device backup.
     *
     * @param[in] Triggers       References of alarms that trigger the backup.
     *    Currently, only alarms on mainboard can be used as triggers.
     *    This can be expanded in the future.
     *
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded in case of
     * - A timeout occurred during IIOP processing.
     * - An unknown alarm is passed.  The previous alarms in the passed list
     *   are the new triggers.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported in case of
     * - not supported in the running software version.
     * - on any board except the mainboard.
     */
    void SetDeviceBackupTriggers(in MM_IDList Triggers)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Gets the list of triggers that define when a backup is needed.
     * When one of the Alarm-triggers is open then the "Device Operational
     * Failure" alarm is open, which triggers the 1:1 device backup.
     *
     * @param[out] Triggers       References of alarms that trigger the backup.
     *    Currently, only alarms on mainboard can be used as triggers.
     *    This can be expanded in the future.
     *
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded in case of
     * - A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported in case of
     * - not supported in the running software version.
     * - on any board except the mainboard.
     */
    void GetDeviceBackupTriggers(out MM_IDList Triggers)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);        
      
    // rule defining whether an alarm must trigger CardNotOperational
    // AlarmRef.MM_TypeID must be filled in and AlarmRef.Ref.PhysRef.BoardNr must be equal to Board
    // Others may be wildcards, but wildcards must not be followed by non-wildcard values
    // When all others are wildcards, this means all alarms of this alarm-type for this board must trigger CardNotOperational	
    struct AlarmTriggerRule_t
    {
      MM_ID_t AlarmRef;
      boolean Trigger;  // false means do not use this alarm as trigger, overruling a rule with more wildcards.
    };
    typedef sequence<AlarmTriggerRule_t> AlarmTriggerRuleList;

	/** Set list alarm trigger rules for CardNotOperational.
     *
     * @param[in] Board Specifies BoardNr.
     * @param[in] Rules       rules defining triggers for CardNotOperational.
     *
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded in case of
     * - A timeout occurred during IIOP processing.
     * - Invalid parameters.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     **/
    void SetCardNotOperationalTriggers(in unsigned short Board, in AlarmTriggerRuleList Rules)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

	/** Get list alarm trigger rules for CardNotOperational.
     *
     * @param[in] Board Specifies BoardNr.
     * @param[out] Rules       rules defining triggers for CardNotOperational.
     *
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded in case of
     * - A timeout occurred during IIOP processing.
     * - Invalid parameters.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     **/
    void GetCardNotOperationalTriggers(in unsigned short Board, out AlarmTriggerRuleList Rules)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);        

	/** Get list measurement references of all active alarms configured as trigger for backup.
     *
     * @param[in] Board Specifies BoardNr.
     * @param[out] ActiveAlarms       References of alarms that are triggering CardNotOperational.
     *
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded in case of
     * - A timeout occurred during IIOP processing.
     * - Invalid parameters.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     **/
    void GetActiveCardNotOperTriggers(in unsigned short Board, out MM_IDList ActiveAlarms)
        raises(TimeOut, OpNotAllowed, OpNotSupported);

    /// Single settings restore option type. Deprecated, use the V2 versions instead
    enum eRestoreOption
    {
       Restore_NoGbeNetwork,          ///< Exclude GbE Network settings (basic + vlan + igmp)
       Restore_NoDeviceBackup,        ///< Exclude 1:1 Device Backup settings
       Restore_NoSCS,                 ///< Exclude SCS settings
       Restore_NoSettingsBackup,      ///< Exclude Settings Backup's own settings
       Restore_NoNTP,                 ///< Exclude NTP's drift file
       Restore_NoIPsec,               ///< Exclude the IPsec settings file      
       Restore_NoStaticRouteMB,       ///< Exclude static routes for mainboard settings file
       Restore_NoDcCfgMgr,            ///< Exclude DcCfgMgr settings
       Restore_NoIgmpV2GbE,           ///< Exclude IgmpV2GbE settings (igmp)
       Restore_NoBasicNetwork         ///< Exclude Basic network settings (basic)
    };

    /// Single settings restore option
    struct RestoreOption
    {
       eRestoreOption Option;         ///< Which option
       boolean Enabled;               ///< Should the option be used
    };
    
    /// List of options
    typedef sequence<RestoreOption> RestoreOptions; 

    /** Get the restore options
     *
     * This call also returns disabled options.
     *
     * @param[out] options Restore options
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded /
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported /
     *
     * @deprecated Use GetSettingsRestoreOptions_V2 instead
     */
    void GetSettingsRestoreOptions(out RestoreOptions options)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Set restore options
     *
     * The options are merged into the current set of options.
     * Unknown settings are ignored. For duplicate options only the last one is kept.
     *
     * @param[in] options Restore options
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded /
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported /
     *
     * @deprecated Use SetSettingsRestoreOptions_V2
     */
    void SetSettingsRestoreOptions(in RestoreOptions options)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Retrieve settings from the device
     *
     * @param[out] settings Settings in binary format
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal errors.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported /
     */
    void BackupSettings(out ByteStream settings)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Restore settings onto the device
     *
     * @param[in] settings Settings in binary format retrieved from a BackupSettings call
     *            or from a settings-export via the GUI in pre-5.0 versions.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal errors, file format bad.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported /
     */
    void RestoreSettings(in ByteStream settings)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Retrieve settings from the device
     *
     * @param[in]  scope    Scope of the operation: 0-n are normal boards, 0xFFFF is
     *                      whole chassis
     * @param[out] settings Settings in binary format
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal errors or the specified card is not an
     *                           active IP Adapter card
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported /
     */
    void BackupSettings2(in unsigned short scope, out ByteStream settings)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    
    /** Restore settings onto the device. The device will be rebooted a couple
     *  of seconds after this call returned.
     *
     * @param[in] scope    Scope of the operation: 0-n are normal boards, 0xFFFF is
     *                     whole chassis
     * @param[in] settings Settings in binary format retrieved from a 
     *                     BackupSettings call
     *            or from a settings-export via the GUI in pre-5.0 versions.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal errors, file format bad or the specified
     *                           card is not an active IP Adapter card.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported /
     */
    void RestoreSettings2(in unsigned short scope, in ByteStream settings)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    
    
    /// Result of the settings restore call
    enum eRestoreSettingsResult
    {
      Restore_Done,              ///< The settings restore has finished
      Restore_Reboot,            ///< The settings restore will reboot to finish
      Restore_Busy,              ///< The async call is still being processed
      Restore_Error,             ///< The async call is done with errors.
      Restore_Result_Reserved1,
      Restore_Result_Reserved2,
      Restore_Result_Reserved3,
      Restore_Result_Reserved4
    };


    /** Restore settings onto the device and try to do this seamless.
     *  This is different with RestoreSettings2 which will enforce a reboot.
     *  As the seamless apply of settings can take some time, this call will take
     *  longer than RestoreSettings2, but it avoids reboots if not necessary.
     *
     * @param[in]  scope    Scope of the operation: 0-n are normal boards, 0xFFFF is
     *                      whole chassis
     * @param[in]  settings Settings in binary format retrieved from a 
     *                      BackupSettings call or from a settings-export via 
     *                      the GUI in pre-5.0 versions.
     * @param[in]  bReturnEarly  when set to true, the call will return after
     *                           it is determined whether a reboot is needed.
     *                           On DCM this parameter will have no effect. 
     *                           On D9036 the call will return before importing VSE settings,
     *                           use the PollRestoreSettingsResult to monitor the result.
     * @param[out] Result   Returns the result of the restore processs.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal errors, file format bad or the specified
     *                           card is not an active IP Adapter card.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported /
     * 
     * @version Release 8.5
     * 
     */
    void RestoreSettings3(in unsigned short scope, in ByteStream settings, in boolean bReturnEarly, out eRestoreSettingsResult Result)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    
    
    
    /** Check if the assynchronously launched RestoreSettingsAsync call has
     *  finished its job (poll for its status).
     *  
     * @param[out] Result The eRestoreSettingsResult. After a reboot the state will be
     *       Done, otherwise it depends of the outcome on previous call.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal errors, file format bad or the specified
     *                           card is not an active IP Adapter card.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported /
     * 
     * @version Release 8.5
     * 
     */
    void PollRestoreSettingsResult(out eRestoreSettingsResult Result)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);




    /// Single settings restore option type
    enum eRestoreOption_V2
    {
       Restore_V2_NoGbeNetwork,          ///< Exclude GbE Network settings (basic + vlan + igmp)
       Restore_V2_NoDeviceBackup,        ///< Exclude 1:1 Device Backup settings
       Restore_V2_NoSCS,                 ///< Exclude SCS settings
       Restore_V2_NoSettingsBackup,      ///< Exclude Settings Backup's own settings
       Restore_V2_NoNTP,                 ///< Exclude NTP's drift file
       Restore_V2_NoIPsec,               ///< Exclude the IPsec settings file      
       Restore_V2_NoStaticRouteMB,       ///< Exclude static routes for mainboard settings file
       Restore_V2_NoDcCfgMgr,            ///< Exclude DcCfgMgr settings
       Restore_V2_NoIgmpV2GbE,           ///< Exclude IgmpV2GbE settings (igmp)
       Restore_V2_NoBasicNetwork,        ///< Exclude Basic network settings (basic)
       Restore_V2_NoPsbSec,              ///< Exclude settings regarding product security.
       Restore_V2_Reserved_20,
       Restore_V2_Reserved_19,
       Restore_V2_Reserved_18,
       Restore_V2_Reserved_17,
       Restore_V2_Reserved_16,
       Restore_V2_Reserved_15,
       Restore_V2_Reserved_14,
       Restore_V2_Reserved_13,
       Restore_V2_Reserved_12,
       Restore_V2_Reserved_11,
       Restore_V2_Reserved_10,
       Restore_V2_Reserved_9,
       Restore_V2_Reserved_8,
       Restore_V2_Reserved_7,
       Restore_V2_Reserved_6,
       Restore_V2_Reserved_5,
       Restore_V2_Reserved_4,
       Restore_V2_Reserved_3,
       Restore_V2_Reserved_2,
       Restore_V2_Reserved_1
    };

    /// Single settings restore option
    struct RestoreOption_V2
    {
       eRestoreOption_V2 Option;         ///< Which option
       boolean Enabled;               ///< Should the option be used
    };
    
    /// List of options
    typedef sequence<RestoreOption_V2> RestoreOptions_V2; 


    /** Get the restore options
     *
     * This call also returns disabled options.
     *
     * @param[out] options Restore options
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded /
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported /
     *
     * @version 8.1
     */
    void GetSettingsRestoreOptions_V2(out RestoreOptions_V2 options)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Set restore options
     *
     * The options are merged into the current set of options.
     * Unknown settings are ignored. For duplicate options only the last one is kept.
     *
     * @param[in] options Restore options
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded /
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported /
     *
     * @version 8.1
     */
    void SetSettingsRestoreOptions_V2(in RestoreOptions_V2 options)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    ///
    /// @} end of one_to_one_backup
    ///
    
    /** @defgroup ts_backup Define and activate TS Backup
     * @{
     */

    struct TS_BackupParams_t
    {
      IPS_RefTS_List_t BackupInTS_List;
      boolean Revertive;
      unsigned long HighToLowPriorityDelay;  ///< time in seconds to wait before switching to backup
      unsigned long LowToHighPriorityDelay;  ///< time in seconds to wait before switching back to main input
    };

    /** Set the Backup parameters for an Input TS.
     * 
     * @param[in] InTS Specifies the Input TS.
     * @param[in] TS_BackupParams The parameters to apply.
     * 
     * @exception OpNotSupported in case of
     * - not supported in the running software version.
     * - when the mainboard is supplied.
     * @exception OpNotSucceeded in case of
     * - When a non-existing TsIn is provided.
     * - When a TsOut is provided instead of a TsIn.
     * - There is more than one backup source specified.
     * - The Backup source is the same as the target TsIn.
     */
    void SetTS_BU_Params(in IPS_RefTS_t InTS,  in TS_BackupParams_t TS_BackupParams)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the Backup parameters for an Input TS.
     * 
     * @param[in] InTS Specifies the Input TS.
     * @param[out] TS_BackupParams The current parameters.
     * 
     * @exception OpNotSupported in case of
     * - not supported in the running software version.
     * - when the mainboard is supplied.
     * @exception OpNotSucceeded in case of
     * - When a non-existing TsIn is provided.
     * - When a TsOut is provided iso a TsIn.
     */
    void GetTS_BU_Params(in IPS_RefTS_t InTS,  out TS_BackupParams_t TS_BackupParams)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Let the user manually set the active InputTS.
     * 
     * @param[in] InTS The main Input TS.
     * @param[in] ActiveInTS The Input TS that should be active.
     * 
     * @exception OpNotSupported
     * - not supported in the running software version.
     * - when the mainboard is supplied.
     * @exception OpNotSucceeded
     * - When a non-existing TsIn is provided.
     * - When a TsOut is provided iso a TsIn.
     * - When the ActiveInTS is currently not in the backup list.
     */
    void SetActiveInputTS(in IPS_RefTS_t InTS, in IPS_RefTS_t ActiveInTS)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the active InputTS.
     * 
     * @param[in] InTS The main Input TS.
     * @param[in] ActiveInTS The Input TS that is active.
     * 
     * @exception OpNotSupported
     * - not supported in the running software version.
     * - when the mainboard is supplied.
     * @exception OpNotSucceeded
     * - When a non-existing TsIn is provided.
     * - When a TsOut is provided iso a TsIn.
     */
    void GetActiveInputTS(in IPS_RefTS_t InTS, out IPS_RefTS_t ActiveInTS)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Sets for TS backup that the switch to the backup TS will only happen if this TS is not in alarm.
     * 
     * @param[in] Board    
     * @param[in] Enabled  TRUE if the switch to the backup TS will only happen if this TS is not in alarm.
     * 
     * @exception OpNotSupported when Board = 0 = Main board.
     * @exception OpNotSucceeded if Board is invalid
     */
    void SetTS_BU_SwitchToGoodSrcOnly(in unsigned short Board, in boolean Enabled)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Gets for TS backup if the switch to the backup TS will only happen if this TS is not in alarm.
     * 
     * @param[in] Board    
     * @param[out] Enabled  TRUE if the switch to the backup TS will only happen if this TS is not in alarm.
     * 
     * @exception OpNotSupported when Board = 0 = Main board.
     * @exception OpNotSucceeded if Board is invalid
     */
    void GetTS_BU_SwitchToGoodSrcOnly(in unsigned short Board, out boolean Enabled)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /// @} end of ts_backup
    
    /** @defgroup mip_sync MIP Synchronization feature
     * @{
     */    
    
    // MIP Synchronization setup consists of 2 DCMS which contain one or more ASI SFN MKII boards.
    // The configuration of these boards must be the same.
    // Normally device backup will also be configured since the active/inactive state of the device
    // determines the actions taken.
    // One dcm is configured as MIP Synchronization Initator, the other as MIP Synchronization Target.
    // The Initiator must know info regarding the Target (IP Address, user name, password).
    // The actual enabling of MIP Synchronization is done per ASI SFN MKII board and only on the Initiator.
    
    enum enMIP_Sync_DeviceRole
    {
      eMIP_SyncNone,
      eMIP_SyncInitiator,
      eMIP_SyncTarget
    };
    
    /** Get the MIP Synchronization role of a device
     *
     * @param[out] MIP_Sync_DeviceRole indicates device role regarding MIP Synchronization
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When this call is not supported in the running software version.
     * @exception OpNotSucceeded On internal error only.
     *
     * @version Release 9.0
     */
    void GetMIP_SyncDeviceRole (out enMIP_Sync_DeviceRole MIP_Sync_DeviceRole)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Set the MIP Synchronization role of a device
     *
     * @param[in] MIP_Sync_DeviceRole indicates device role regarding MIP Synchronization
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported When this call is not supported in the running software version.
     * @exception OpNotSucceeded On internal error only.
     * @exception OperationFailed When problems regarding settingsfile.
     *
     * @version Release 9.0
     */
    void SetMIP_SyncDeviceRole (in enMIP_Sync_DeviceRole MIP_Sync_DeviceRole)
        raises(TimeOut, OperationFailed, OpNotSucceeded, OpNotAllowed, OpNotSupported); 
    
    struct MIP_SyncTargetSettings_t
    {
      string IP_Address;
      string UserName;
      string Password;
    };
    
    /** Get the settings of the MIP Synchronization Target
     *
     * @param[out] TargetSettings settings of the MIP Synchronization Target
     *
     * @exception TimeOut         A timeout occurred during IIOP processing.
     * @exception OpNotAllowed    Not logged on.
     * @exception OpNotSupported  When this call is not supported in the running software version.
     * @exception OpNotSucceeded  On internal error only.     
     * @exception OperationFailed When DCM is not MIP Synchronization Initiator.
     *
     * @version Release 9.0
     */
    void GetMIP_SyncTargetSettings (out MIP_SyncTargetSettings_t TargetSettings)
        raises(TimeOut, OperationFailed, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Set the settings of the MIP Synchronization Target
     *
     * @param[out] TargetSettings settings of the Target MIP Synchronizer
     *
     * @exception TimeOut         A timeout occurred during IIOP processing.
     * @exception OpNotAllowed    Not logged on.
     * @exception OpNotSupported  When this call is not supported in the running software version.
     * @exception OpNotSucceeded  On internal error only.     
     * @exception OperationFailed When DCM is not MIP Synchronization Initiator or when problems regarding settingsfile.
     *
     * @version Release 9.0
     */
    void SetMIP_SyncTargetSettings (in MIP_SyncTargetSettings_t TargetSettings)
        raises(TimeOut, OperationFailed, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the MIP Synchronization Enabled setting of an ASI SFN MKII Board
     *
     * @param[in] BoardNr
     * @param[out] MIP_SyncEnabled Indicates whether MIP Sync is enabled or not
     *
     * @exception TimeOut         A timeout occurred during IIOP processing.
     * @exception OpNotAllowed    Not logged on.
     * @exception OpNotSupported  When called for non-ASI-SFN-MKII boards.
     * @exception OpNotSucceeded  On internal error only.     
     * @exception OperationFailed When DCM is not MIP Synchronization Initiator.
     *
     * @version Release 9.0
     */
    void ASI_SFN_MKII_GetMIP_SyncEnable(in unsigned short BoardNr, out boolean MIP_SyncEnabled)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the MIP Synchronization Enabled setting of an ASI SFN MKII Board
     *
     * @param[in] BoardNr 
     * @param[in] MIP_SyncEnable Indicates whether MIP Sync should be enabled or not
     *
     * @exception TimeOut         A timeout occurred during IIOP processing.
     * @exception OpNotAllowed    Not logged on.
     * @exception OpNotSupported  When called for non-ASI-SFN-MKII boards.
     * @exception OpNotSucceeded  On internal error only.     
     * @exception OperationFailed When DCM is not MIP Synchronization Initiator.
     *
     * @version Release 9.0
     */
    void ASI_SFN_MKII_SetMIP_SyncEnable(in unsigned short BoardNr, in boolean MIP_SyncEnable)
        raises(TimeOut, OperationFailed, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /// @} end of mip_sync        
        
    /// @} end of backup
#endif // DISABLE_BACKUP
#ifndef DISABLE_DTF
    // DTF
    ////////////////////////////////
    
    /** @defgroup dtf DTF
     * Types and methods to control DTF
     * @{
     */
     
    /// Defines the ASI board's sub type
    enum eASI_BoardType
    {
      ASI_BoardRegular, ///< Generic ASI mode
      ASI_BoardDTF      ///< DTF mode
    };
    
    /// Defines the scrambling type
    enum eASI_DTF_ScramblingType
    {
      DTF_OddScrambling,  ///< Odd scrambling
      DTF_EvenScrambling  ///< Even scrambling
    };
    
    /// Structure holding DTF input settings
    /// @deprecated Obsoleted by ASI_DTF_Ex_t from release 6.0
    struct ASI_DTF_t
    {
      IPS_RefTS_t     InputRef;           ///< The reference to the DTF input stream
      boolean         bBlocked;           ///< true means input not used, false means input passed
      boolean         bEncapsulated;      ///< true means output encapsulated in ghost PID, false means passed
      boolean         bRemoveStuffing;    ///< if true and bEncapsulated is false, then the original stuffing packets are removed
      unsigned short  OutputPID;          ///< Ghost PID for encapsulating this input stream
      unsigned long   AFInterval;         ///< The interval between two adaptation fields, in ms
      unsigned long   TS_InProperty;      ///< Property bitmap
      boolean         bBISS1Scrambled;    ///< true means this stream will be scrambled while encapsulating
      ByteStream      BISS1ScramblingKey; ///< scrambling key should be 6 bytes long (scrambling is always even)
    };
    
    /// Structure holding DTF input settings.
    /// The difference with the ASI_DTF_t structure is that this structure here
    /// doesn't hold the scrambling key directly.  Instead, it holds a reference
    /// to a key in the list that can be set up using the ASI_DTF_SetKeyList
    /// method.  Also the scrambling type can be selected to be odd or even.
    struct ASI_DTF_Ex_t
    {
      IPS_RefTS_t         InputRef;           ///< The reference to the DTF input stream
      boolean             bBlocked;           ///< True means input not used, false means input passed
      boolean             bEncapsulated;      ///< True means output encapsulated in ghost PID, false means passed
      boolean             bRemoveStuffing;    ///< If true and bEncapsulated is false, then the original stuffing packets are removed
      unsigned short      OutputPID;          ///< Ghost PID for encapsulating this input stream
      unsigned long       AFInterval;         ///< The interval between two adaptation fields, in ms
      unsigned long       TS_InProperty;      ///< Property bitmap: bit[0] indicates scrambling status (1 = OK)
      boolean             bBISS1Scrambled;    ///< True means this stream will be scrambled while encapsulating
      unsigned short      ScramblingKeyIndex; ///< Index into the scrambling key list, should be less than 1024, used when not overriden by the global default.
      eASI_DTF_ScramblingType ScramblingType; ///< Input level scrambling type setting, used when not overridden by the global type
    };
    
    /// Structure holding DTF RDCS input settings. From V9.0 onwards.
    struct ASI_DTF_RDCS_t
    {
      IPS_RefTS_t         InputRef;           ///< The reference to the DTF input stream 
      boolean             bRDCS;              ///< True means stream consists of a Remultiplexer Data and Control Stream
    };
    
    /// Provides a list of DTF input settings structures
    /// @deprecated Obsoleted by ASI_DTF_ListEx_t from release 6.0
    typedef sequence<ASI_DTF_t> ASI_DTF_List_t;
    
    /// Provides a list of DTF input settings structures
    typedef sequence<ASI_DTF_Ex_t>  ASI_DTF_ListEx_t;
    
    /// Provides a list of DTF RDCS input settings structures. From V9.0 onwards.
    typedef sequence<ASI_DTF_RDCS_t> ASI_DTF_RDCS_List_t;     
    
    /// Structure holding DTF output settings
    /// @deprecated Obsoleted by ASI_DTF_OutputTS_Ex_t from release 6.0
    struct ASI_DTF_OutputTS_t
    {
      IPS_RefTS_t     OutputRef;          ///< The reference to the DTF output stream, currently only stream 9 on port 9 is supported
      unsigned long   Bitrate;            ///< The outgoing bitrate of the DTF output in bps
      unsigned long   TS_OutProperty;     ///< Property bitmap
      ASI_DTF_List_t  OutputMux;          ///< List of input settings
    };
    
    /// Structure holding DTF output settings.
    /// The difference with the ASI_DTF_OutputTS_t is that this structure here
    /// provides for scrambling type, scrambling key indices and the possibility
    /// to overrule the input-level settings by one global setting.
    struct ASI_DTF_OutputTS_Ex_t
    {
      IPS_RefTS_t         OutputRef;                    ///< The reference to the DTF output stream, currently only stream 9 on port 9 is supported
      unsigned long       Bitrate;                      ///< The outgoing bitrate of the DTF output in bps
      unsigned long       TS_OutProperty;               ///< Property bitmap
      boolean             bUseMainScramblingKeyIndex;   ///< True to use the main scrambling key index for all inputs, false to use individual input key indices.
      unsigned short      MainScramblingKeyIndex;       ///< Main index into the scrambling key list
      boolean             bUseMainScramblingType;       ///< True to use the main scrambling type for all inputs, false to use individual input types.
      eASI_DTF_ScramblingType MainScramblingType;       ///< Main scrambling type
      ASI_DTF_ListEx_t    OutputMux;                    ///< List of input settings
    };
    
    /// Structure holding DTF RDCS output settings. From V9.0 onwards.
    struct ASI_DTF_OutputTS_RDCS_t
    {
      IPS_RefTS_t          OutputRef;                    ///< The reference to the DTF output stream, currently only stream 9 on port 9 is supported
      ASI_DTF_RDCS_List_t  InputSettings;                ///< List of DTF RDCS input settings
    };
    
    /// Structure holding DTF scrambling keys.
    /// @deprecated Obsoleted in release 6.0
    struct ASI_DTF_ScramblingKeyPair_t
    {
      ByteStream      OddScramblingKey;   ///< Scrambling key for use with odd scrambling, should be exactly 6 bytes long
      ByteStream      EvenScramblingKey;  ///< Scrambling key for use with even scrambling, should be exactly 6 bytes long
    };

    /// Type to hold a list of scrambling key pairs, should hold exactly 64 key pairs.
    /// @deprecated Obsoleted in release 6.0
    typedef sequence<ASI_DTF_ScramblingKeyPair_t> ASI_DTF_ScramblingKeyList;



    struct ASI_DTF_ScramblingKey_t
    {
      unsigned short    Index;    ///< Index in the array of keys, should be <1024
      string            OddKey;   ///< Hex encoded scrambling key for use with odd scrambling, a valid key is exactly 12 characters long
      string            EvenKey;  ///< Hex encoded scrambling key for use with even scrambling, a valid key is exactly 12 characters long
    };

    typedef sequence< ASI_DTF_ScramblingKey_t> ASI_DTF_KeyList_t;


    /** Configures the ASI board in either regular or DTF mode.
     * 
     * @param[in] RefPhys       The board (and port) to apply the call on.  Only port 10 (index 9) and wildcard port (0xFFFF) are currently supported.
     * @param[in] ASIBoardType  The board's sub-type
     **/
    void SetASIBoardType(in IPS_Ref_t RefPhys, in eASI_BoardType ASIBoardType)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Reads the current ASI board sub-type.
     * 
     * @param[in] RefPhys       The board (and port) to apply the call on.  Only port 10 (index 9) and wildcard port (0xFFFF) are currently supported.
     * @param[out] ASIBoardType  The board's sub-type
     **/
    void GetASIBoardType(in IPS_Ref_t RefPhys, out eASI_BoardType ASIBoardType)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Retrieves the current DTF settings.
     * 
     * @param[in] RefPhys       The board (and port) to apply the call on.  Only port 10 (index 9) is currently supported.
     *
     * @return The current DTF configuration.
     *
     * @deprecated Obsoleted in release 6.0
     **/
    ASI_DTF_OutputTS_t ASI_DTF_OutTS_Get(in IPS_Ref_t RefPhys)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Retrieves the current DTF settings.
     * 
     * @param[in] RefPhys       The board (and port) to apply the call on.  Only port 10 (index 9) is currently supported.
     *
     * @return The current DTF configuration.
     **/
    ASI_DTF_OutputTS_Ex_t ASI_DTF_OutTS_GetEx(in IPS_Ref_t RefPhys)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Retrieves the DTF RDCS settings.
     * 
     * @param[in] RefPhys       The board (and port) to apply the call on.  Only port 10 (index 9) is currently supported.
     *
     * @return The DTF RDCS settings. 
     *
     * @version Release 9.0
     **/
    ASI_DTF_OutputTS_RDCS_t ASI_DTF_OutTS_RDCS_Get(in IPS_Ref_t RefPhys)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);        
    
    /** Sets the DTF settings
     * 
     * @param[in] RefPhys       The board (and port) to apply the call on.  Only port 10 (index 9) is currently supported.
     * @param[in] OutputTS  The new DTF configuration
     *
     * @deprecated Obsoleted in release 6.0
     **/
    void ASI_DTF_Change(in IPS_Ref_t RefPhys, in ASI_DTF_OutputTS_t OutputTS)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Sets the DTF settings
     * 
     * @param[in] RefPhys       The board (and port) to apply the call on.  Only port 10 (index 9) is currently supported.
     * @param[in] OutputTS  The new DTF configuration
     *
     **/
    void ASI_DTF_ChangeEx(in IPS_Ref_t RefPhys, in ASI_DTF_OutputTS_Ex_t OutputTS)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
     /** Sets DTF RDCS settings.
     * 
     * @param[in] RefPhys    The board (and port) to apply the call on.  Only port 10 (index 9) is currently supported.
     * @param[in] OutputTS   The DTF RDCS settings of each input
     *
     * @version Release 9.0 
     **/
    void ASI_DTF_RDCS_Change(in IPS_Ref_t RefPhys, in ASI_DTF_OutputTS_RDCS_t OutputTS)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);     

    /** Retrieves the bit rate of the stuffing packets in the DTF output stream.
     * 
     * @param[in] RefPhys       The board (and port) to apply the call on.  Only port 10 (index 9) is currently supported.
     *
     * @return The bit rate of the stuffing packets
     **/
    unsigned long ASI_DTF_OutTS_GetStuffingBitRate(in IPS_Ref_t RefPhys)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Retrieves the list of 64 scrambling key pairs
     * 
     * @param[in] RefPhys       The board (and port) to apply the call on.  Only port 10 (index 9) is currently supported.
     *
     * @return                  A list holding the key pairs. 
     *
     * @deprecated Obsoleted in release 6.0
     **/
    ASI_DTF_ScramblingKeyList ASI_DTF_GetKeyList(in IPS_Ref_t RefPhys)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Sets up the list with 64 scrambling key pairs
     * 
     * @param[in] RefPhys         The board (and port) to apply the call on.  Only port 10 (index 9) is currently supported.
     * @param[in] KeyList         A list holding exactly 64 key pairs.
     *
     * @deprecated Obsoleted in release 6.0
     **/
    void ASI_DTF_SetKeyList(in IPS_Ref_t RefPhys, in ASI_DTF_ScramblingKeyList KeyList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /**  Replace DTF BISS scrambling keys
     *
     * If an index is used multiple times in the list of key pairs, only the last keypair
     * will be applied. If a key is not valid, it will erase the key that is currently in use.
     * 
     * @param[in] BoardNumber    The board to apply the call on.  Only board 0 is supported.
     * @param[in] KeyList        List of keys to fill out.
     *
     * @version 8.5
     **/
    void ASI_DTF_SetKeyList_V2(in unsigned short BoardNumber, in ASI_DTF_KeyList_t KeyList)
            raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /**  Clear all DTF related credentials
     * 
     * @param[in] BoardNumber    The board to apply the call on.  Only board 0 is supported.
     *
     * @version 8.5
     **/
    void ASI_DTF_ClearCredentials(in unsigned short BoardNumber)
            raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Enter a SWDF decryption key
     *
     * @param[in] BoardNumber    The board to apply the call on.  Only board 0 is supported.
     * @param[in] SWDK           The hex encoded decryption key, exactly 48 characters long.
     *
     * @version 8.5
     **/
    void ASI_DTF_SetSWDK(in unsigned short BoardNumber, in string SWDK)
            raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /// @} end of dtf
#endif // DISABLE_DTF
#ifndef DISABLE_MM
    // M & M
    //////////////////////////////// 

    /** @defgroup mm Measurements and alarms 
     * This module groups measurements types, enums and methods as well as alarms related things.
     * @{
     */

    enum MeasureType
    {
      Binary,
      Analog
    };

    enum MeasureValidity
    {
      MeasValidity_NotValid,
      MeasValidity_NotDefined,
      MeasValidity_Defined        
    };

    /// Rosa Like message catgories.
    enum MM_ID_Category
    {
      MM_ID_CatAll,
      MM_ID_CatOther,
      MM_ID_CatInput,
      MM_ID_CatOutput
    };

    /// Rosa like message severity indicators.
    enum MsgSeverity 
    { 
      Indeterminate, 
      Critical, 
      Major, 
      Minor, 
      Warning,
      Cleared, 
      Information
    };
        
    /// Rosa like message status indicators. 
    enum MsgStatus 
    { 
      Open,
      Closed,
      OpenMinorUpper,
      OpenMinorLower,
      OpenMajorUpper,
      OpenMajorLower,
      ClosedMinorUpper,
      ClosedMinorLower,
      ClosedMajorUpper,
      ClosedMajorLower,                
      NotDefined, 
      NotValid
    };

    /// Rosa like message behaviour indicators.
    enum MsgBehaviour 
    { 
      NotPending, 
      ClearedByUser, 
      ClearedBySystem 
    };

    /// Rosa like message classes.
    enum MsgClass 
    {
      Communication, 
      Quality, 
      Processing, 
      Equipment, 
      Environmental
    };  

    /** Structure to pass Messages from the device to whatever client.
     */
    struct MM_MessageMainPart
    {
      MM_ID_t         MsgID;              ///< unique ID identifying the sort of message
      string          SourceName;         ///< device name
      string          Text;               ///< text of the message
      string          Subject;
      Time            GenerationTime;     ///< generation time of the message - see Time above          
      MsgBehaviour    Behaviour;
      MsgClass        Class;              ///< communication, processing, ...
      unsigned long   SubClass; 
      unsigned long   SubClassNbr;        ///< sub number
      boolean         DetailPresent;
      MsgStatus       Status;             ///< begin, end ...
      MsgSeverity     Severity;        
    };

    /** 
     */
    struct MM_Message
    {
      MM_MessageMainPart  MessageMain;        
      string MeasDetail;
      double MeasValue;
      string MeasUnit;
      MeasureType MeasType; 
      MeasureValidity MeasValidity;      
      unsigned long MessageNbr;
    };

    // Message Function - used to get the message from the device
    // NOT %DCM ANYMORE boolean GetMessage(in long MsgNbr, out Message aMessage);
    // TO CHECK 
    
    /// A sequence of MM_Message.
    typedef sequence<MM_Message> MM_MessageList;
    
    /** Used to get the a sequence of messages from the device.
     *
     * @param[in] StartMsgNbr MsgNbr of first message to get.
     * @param[in] EndMsgNbr MsgNbr of last message to get.
     *
     * @return MM_MessageList list of messages with MsgNbr between and including StartMsgNbr and EndMsgNbr.
     *
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     **/
    MM_MessageList MM_GetMessageList(in unsigned long StartMsgNbr, in unsigned long EndMsgNbr)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    // Message BufferInfo - used to store the details of the MsgBuffer.
    struct MessageBufferInfo
    {
      unsigned short OldestSeqNumber;      ///< Oldest Message in the Buffer
      unsigned short MostRecentSeqNumber;  ///< Most Recent Message in the Buffer 
      unsigned short MaxSeqNumber;         ///< Maximum allowed sequence Numbers  
      unsigned short SizeOfBuffer;
    };

    // list of actions for the PendingTestAlarm.  
    // Multiple actions will be done without delay.
    // If a delay is needed, different actions should be done by the client.
    const octet PendingTestAlarm_Action_Set = 1;
    const octet PendingTestAlarm_Action_Clear = 2;
    const octet PendingTestAlarm_Action_SetClear = 3;
    const octet PendingTestAlarm_Action_ClearSet = 4;
    const octet PendingTestAlarm_Action_Register = 5;
    const octet PendingTestAlarm_Action_Unregister = 6;
    const octet PendingTestAlarm_Action_UnregisterRegisterSet = 7;
    
    /** Gets the current status of the MsgBuffer.
     *
     * @return MM_MessageList list of messages with MsgNbr between and including StartMsgNbr and EndMsgNbr.
     *
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded Never thrown.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     **/
    MessageBufferInfo GetMessageBufferInfo()
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** causes a test message to be sent.
     *
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded Never thrown.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     **/
    void GenerateTestMsg()  
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** update a test alarm via user input.
     *
     * @param[in] Board Update Alarm on a certain board (in a multi-board device).
     * @param[in] Action Update Alarm according to a certain action (see above).
     * @param[in] Detail Update Alarm Detail (only visible when alarm is set).
     *
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded Never thrown.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     **/
    void UpdatePendingTestAlarm(in unsigned short Board, in octet Action, in string Detail)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

   /** Gets all messages with open status plus current message buffer info.
     *
     * @param[out] OldestSeqNumber sequence number of oldest message in buffer.
     * @param[out] LatestSeqNumber sequence number of most recent message in buffer.
     * @param[out] OldestMessage info of oldest message in buffer.
     * @param[out] LatestMessage info of most recent message in buffer.
     * @param[out] OpenMessageList list of messages with open status.
     *
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     **/
    void MM_GetAllOpenMsgStatus(out unsigned short OldestSeqNumber, out unsigned short LatestSeqNumber, out MM_Message OldestMessage, out MM_Message LatestMessage, out MM_MessageList OpenMessageList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    // MESSAGE SETTINGS 
    /////////////////////////////////
    
    // NOT SUPPORTED 
      // - SNMP Trap
      // - Measurement Enabled
      // - TS_ID, ON_ID dependent settings

    /// Message settings.
    struct MessageSetting
    {
      boolean Enabled;                  ///< enable/disabling of individual messages.
      MsgSeverity Severity;             ///< will be used for the binary messages.
      MsgSeverity MinorSeverity;        ///< will be used for the analog messages.
      MsgSeverity MajorSeverity;        ///< will be used for the analog messages.
      unsigned long BeginDebounceTime;  ///< debouncing time when the alarm begins, switches from non-active to active.
      unsigned long EndDebounceTime;    ///< debouncing time when the alarm ends, switches from active to non-active.
    };

    /// Message type settings.
    struct MM_MessageTypeSetting
    {
      IPS_Ref_t RefPhys;          ///< mask port, port info not relevant
      unsigned short MsgTypeID;
      MessageSetting MsgSetting;
    };

    /// Measurement message settings.
    struct MM_MessageSetting
    {
        MM_ID_t        MsgID;
        MessageSetting MsgSetting;
    };

    /// A sequence of MM_MessageTypeSetting.
    typedef sequence<MM_MessageTypeSetting> MM_MessageTypeSettingList;
    
    /// A sequence of MM_MessageSetting.
    typedef sequence<MM_MessageSetting> MM_MessageSettingList;

    /** Set settings per message-type.
     *
     * @param[in] RefPhys Specifies BoardNr & PortNr (PortNr is ignored).
     * @param[in] List Specifies message-types and the settings per message-type.
     * 
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded in case of
     * - A timeout occurred during IIOP processing.
     * - Invalid parameters.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     **/
    void MM_SetMsgTypeSettingL(in IPS_Ref_t RefPhys, in MM_MessageTypeSettingList List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get settings per message-type.
     *
     * @param[in] RefPhys Specifies BoardNr & PortNr (PortNr is ignored).
     * @param[out] List Specifies message-types and the settings per message-type.
     * 
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded in case of
     * - A timeout occurred during IIOP processing.
     * - Invalid parameters.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     **/
    void MM_GetMsgTypeSettingL(in IPS_Ref_t RefPhys, out MM_MessageTypeSettingList List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set settings per message.
     *
     * @param[in] List Specifies messages and the settings per message.
     * 
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded in case of
     * - A timeout occurred during IIOP processing.
     * - Invalid parameters.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     *
     * @note not implemented yet, so OpNotSupported will always be raised.
     * @note a RefPhys parameter will probably be added.
     **/
    void MM_SetMsgSettingL(in MM_MessageSettingList List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get settings per message.
     *
     * @param[out] List Specifies messages and the settings per message.
     * 
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     *
     * @note not implemented yet, so OpNotSupported will always be raised.
     * @note a RefPhys parameter will probably be added.
     **/
    void MM_GetMsgSettingL(out MM_MessageSettingList List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Specify whether all messages are enabled.
     *
     * @param[in] AllMsgEnabled 0=all disabled, otherwise all enabled.
     *
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     **/
    void SetAllMsgEnabled(in octet AllMsgEnabled)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get Specification whether all messages are enabled.
     *
     * @param[out] AllMsgEnabled 0=all disabled, 1=all enabled.
     * 
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     **/
    void GetAllMsgEnabled(out octet AllMsgEnabled)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
   
    enum MM_MeasureStatus
    {
      AlarmBegin,       ///< Major,Minor,Critical, Warning 
      AlarmEnd          ///< Cleared 
    };

    struct MM_Measurement
    {
      MM_ID_t   MeasureID;                      
      double Value;                         
      MeasureValidity Validity;
      MM_MeasureStatus Status;                      
      boolean DetailPresent;
      string  Detail;  // 320 characters, string representation
      MsgSeverity CurrentSeverity;
    };

    /// A sequence of MM_Measurement.
    typedef sequence<MM_Measurement> MM_MeasurementList;

    enum DeviceLevel
    {
      DL_DeviceLevel,
      DL_BoardLevel,
      DL_PortLevel,
      DL_TSLevel,
      DL_ServiceLevel,
      DL_ComponentLevel
    };

    struct MM_TypeInfo
    {
      unsigned short MeasureTypeID;   // msg type ID = measurement type ID 
      string Name;
      string Unit;
      MeasureType Type; 
      DeviceLevel Level; 
      MM_ID_Category ID_Cat;
    };

    /// A sequence of MM_TypeInfo
    typedef sequence<MM_TypeInfo> MM_TypeInfoList;

    const octet AlarmAsBackupTriggerMethod_NotAllowed = 0;  ///< Alarm can not be used as backuptrigger
    const octet AlarmAsBackupTriggerMethod_Default = 1;     ///< Alarm can be used as backuptrigger and will be displayed in the default way (non default presentations can be added)

    /// V2 of MM_TypeInfo: BackupTriggerMethod is added
    struct MM_TypeInfo_V2
    {
      unsigned short MeasureTypeID;   // msg type ID = measurement type ID 
      string Name;
      string Unit;
      MeasureType Type; 
      DeviceLevel Level; 
      MM_ID_Category ID_Cat;
      octet BackupTriggerMethod;
    };

    /// A sequence of MM_TypeInfo_V2
    typedef sequence<MM_TypeInfo_V2> MM_TypeInfoList_V2;

    struct MM_MeasurementStat
    {
      MM_ID_t MeasureID;              // mask typeID in return
      unsigned long NbrOfOpenStates;
      MsgSeverity AlarmSeverity;
    } ;

    /// A sequence of MM_MeasurementStat.
    typedef sequence<MM_MeasurementStat> MM_MeasurementStatList;

    /** Get static info of measurements according to category and level.
     *
     * @param[in] RefPhys Specifies BoardNr & PortNr.
     * @param[in] ID_Cat Specifies category.
     * @param[in] Level Specifies Level in hierarchy of measurements.
     *
     * @return MM_TypeInfoList list of static measurement info.
     * 
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded in case of
     * - A timeout occurred during IIOP processing.
     * - Invalid parameters.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     *
     * @note info of all measurements below the specified level are included.
     **/
    MM_TypeInfoList MM_GetTypeInfo(in IPS_Ref_t RefPhys, in MM_ID_Category ID_Cat, in DeviceLevel Level)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get static info of measurements according to category and level (V2: field added).
     *
     * @param[in] RefPhys Specifies BoardNr & PortNr.
     * @param[in] ID_Cat Specifies category.
     * @param[in] Level Specifies Level in hierarchy of measurements.
     *
     * @return MM_TypeInfoList list of static measurement info.
     * 
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded in case of
     * - A timeout occurred during IIOP processing.
     * - Invalid parameters.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     *
     * @note info of all measurements below the specified level are included.
     **/
    MM_TypeInfoList_V2 MM_GetTypeInfo_V2(in IPS_Ref_t RefPhys, in MM_ID_Category ID_Cat, in DeviceLevel Level)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get static info of measurements according MM_TypeID.
     *
     * @param[in] Board Specifies BoardNr.
     * @param[in] MM_TypeIDs Specifies list of MM_TypeIDs for which the TypeInfo is required.
     *
     * @return MM_TypeInfoList list of static measurement info.
     * 
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded in case of
     * - A timeout occurred during IIOP processing.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     **/
    MM_TypeInfoList MM_GetTypeInfoForTypeIDs(in unsigned short Board, in MM_TypeIDList MM_TypeIDs)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get number of open measurements according to category and level.
     *
     * @param[in] TSref Specifies BoardNr & PortNr.and TS.
     * @param[in] ID_Cat Specifies category.
     * @param[in] Level Specifies Level in hierarchy of measurements.
     *
     * @return MM_MeasurementStatList list of measurement statistics.
     * 
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded in case of
     * - A timeout occurred during IIOP processing.
     * - Invalid parameters.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     *
     * @note number of all open measurements below the specified level are included.
     * @note in MM_MeasurementStatList, MM_TypeID is always masked, other references are masked according to level.
     **/
    MM_MeasurementStatList MM_GetNbrOpenMeasurements(in IPS_RefTS_t TSref, in MM_ID_Category ID_Cat, in DeviceLevel Level)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Get number of open measurements according to category and level.
     *
     * @param[in] TSref Specifies BoardNr & PortNr.and TS.
     * @param[in] ID_Cat Specifies category.
     * @param[in] Level Specifies Level in hierarchy of measurements.
     *
     * @return MM_MeasurementStatList list of measurement statistics.
     * 
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded in case of
     * - A timeout occurred during IIOP processing.
     * - Invalid parameters.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     *
     * @note number of all open measurements below the specified level are NOT included.
     * @note in MM_MeasurementStatList, MM_TypeID is always masked, other references are masked according to level.
     *
     * @version 7.0
     **/        
    MM_MeasurementStatList MM_GetNbrOpenMeasurementsOnLevel(in IPS_RefTS_t TSref, in MM_ID_Category ID_Cat, in DeviceLevel Level)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);        
    
    /** Get all measurements according to category and level.
     *
     * @param[in] TSref Specifies BoardNr & PortNr.and TS.
     * @param[in] ID_Cat Specifies category.
     * @param[in] Level Specifies Level in hierarchy of measurements.
     *
     * @return MM_MeasurementList list of measurements.
     * 
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded in case of
     * - A timeout occurred during IIOP processing.
     * - Invalid parameters.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     *
     * @note all measurements below the specified level are included.
     * @note in MM_MeasurementStatList, MM_TypeID is always masked, other references are masked according to level.
     **/
    MM_MeasurementList MM_GetAllMeasurements(in IPS_RefTS_t TSref, in MM_ID_Category ID_Cat, in DeviceLevel Level)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get all open measurements according to category and level.
     *
     * @param[in] TSref Specifies BoardNr & PortNr.and TS.
     * @param[in] ID_Cat Specifies category.
     * @param[in] Level Specifies Level in hierarchy of measurements.
     *
     * @return MM_MeasurementList list of open measurements.
     * 
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded in case of
     * - A timeout occurred during IIOP processing.
     * - Invalid parameters.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     *
     * @note all measurements below the specified level are included.
     * @note in MM_MeasurementStatList, MM_TypeID is always masked, other references are masked according to level.
     **/
    MM_MeasurementList MM_GetOpenMeasurements(in IPS_RefTS_t TSref, in MM_ID_Category ID_Cat, in DeviceLevel Level)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get measurements according to a list of references.
     *
     * @param[in] TSref Specifies BoardNr & PortNr.and TS (PortNr and TS are ignored).
     * @param[in] List list of references.
     *
     * @return MM_MeasurementList list of measurements.
     * 
     * @exception TimeOut        Never thrown.
     * @exception OpNotSucceeded in case of
     * - A timeout occurred during IIOP processing.
     * - Invalid parameters.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSupported Thrown if this call is not supported in the
     *                           running software version.
     **/
    MM_MeasurementList MM_GetMeasurements(in IPS_RefTS_t TSref, in MM_IDList List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    enum eMessage
    {
        ePAT,                       ///< PAT error
        ePMT,                       ///< PMT error
        eAudioVideoPid,             ///< PID error for audio/video PIDs
        eDataPid                    ///< PID error for data PIDs
    };

    /**
     * The bitrate threshold for video, audio and data service losses (board specific).
     */    
    struct BoardBitrateThreshold
    {   unsigned long VideoBitrateThreshold;          ///< Bitrate threshold for video PIDs - in bps
        unsigned long AudioBitrateThreshold;          ///< Bitrate threshold for audio PIDs - in bps
        unsigned long DataBitrateThreshold;           ///< Bitrate threshold for data PIDs - in bps
    };

    /**
     * Sets the service loss bitrate threshold (for video, audio and data) on the given board.
     *
     * @param[in] BoardNr is the board number
     * @param[in] BitrateThreshold is the bitrate threshold for video, audio and data service losses
     *
     * @exception OpNotSucceeded If one of the values is out of range, or an invalid board is specified.
     **/
    void SetBitrateErrorThreshold(in unsigned short BoardNr, in BoardBitrateThreshold BitrateThreshold)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * Gets the service loss bitrate threshold (for video, audio and data) on the given board.
     *
     * @param[in] BoardNr is the board number
     * @param[out] BitrateThreshold is the bitrate thresholds for video, audio and data service losses retrurned
     *
     * @return List of thresholds for video, audio and data.
     **/
    void GetBitrateErrorThreshold(in unsigned short BoardNr, out BoardBitrateThreshold BitrateThreshold)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    struct MM_MessageTypeErrorInterval
    {
        IPS_Ref_t RefPhys;          ///< mask port, port info not relevant
        eMessage Message;           ///< message type to set interval for
        long Interval;              ///< Interval in ms. Value must be between 0-46600 (incl boundaries). NB: MAX_PID_ERROR_TIMEOUT = 45000
    };
    typedef sequence<MM_MessageTypeErrorInterval> MM_MessageTypeErrorIntervalList;

    /**
     * Sets the intervals for the given messages on the given board.
     *
     * @param[in] RefPhys board information, port is masked
     * @param[in] List list of error intervals
     *
     * @exception OpNotSucceeded If RefPhys port isn't masked, List's RefPhys isn't equal to RefPhys parameter or 
     *  one of the values is out of range, or an invalid board is specified.
     */
    void MM_SetErrorInterval(in IPS_Ref_t RefPhys, in MM_MessageTypeErrorIntervalList List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * Gets the error intervals for all error types on the given board.
     *
     * @param[in] RefPhys board information, port is masked.
     * @param[out] List The MM_MessageTypeErrorIntervalList returned.
     *
     * @return List of all intervals.
     */
    void MM_GetErrorInterval(in IPS_Ref_t RefPhys, out MM_MessageTypeErrorIntervalList List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Set whether alarms will only be generated if groomed.
     * Board wide setting to filter alarms.
     * When this option is set, alarms will only be generated for services that are referred to on the output
     * (either active or configured as backup). This is the default.
     * 
     * @param[in] RefPhys specifies BoardNr and PortNr.
     * @param[in] GenerateGroomedOnly: TRUE if alarms are generated for groomed services
     *    FALSE if alarms are always.generated (also for not groomed services)
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case of
     * - Invalid references RefPhys (BoardNr, PortNr)
     * 
     * @note This setting only affects service loss alarms in version 3.0.
     */
    void SetGenerateAlarmsIfGroomed(in IPS_Ref_t RefPhys, in boolean GenerateGroomedOnly)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported); 

    /** Get whether alarms will only be generated for groomed services.
     * Board wide setting to filter alarms.
     * When this option is set, alarms will only be generated for services that are referred to on the output
     * (either active or configured as backup). By default, the generated only if groomed option will be set. 
     * 
     * @param[in] RefPhys specifies BoardNr and PortNr.
     * @param[out] GenerateGroomedOnly: TRUE if alarms are generated for groomed services
     *    FALSE if alarms are always.generated (also for not groomed services)
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case of
     * - Invalid references RefPhys (BoardNr, PortNr)
     */     
    void GetGenerateAlarmsIfGroomed(in IPS_Ref_t RefPhys, out boolean GenerateGroomedOnly)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported); 
        
    /** Set the NTP offset alarm threshold value
     *
     * @param[in]  Offset  NTP offset alarm threshold value in miliseconds
     *
     * @exception  OpNotSupported when BoardNr != 0 (Main board).
     */
    void SetNtpAlarmOffset(in long Offset)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the NTP offset alarm threshold value
     *
     * @param[out] Offset  NTP offset alarm threshold value in miliseconds
     *
     * @exception OpNotSupported when BoardNr != 0 ( Main board).
     */
    void GetNtpAlarmOffset(out long Offset)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Defines the triggers for raising a card not operational failure alarm. */
    enum eBoardPresenceTrigger_t 
    {
        ePresent, ///< Only trigger the card not operational failure alarm if the board 
                  ///< is physically present.
        eAlways   ///< Always trigger the card not operational failure alarm, even if 
                  ///< the board is not physically present.
    };

    /** Structure used in the configuration of the triggers for card not operational 
     *  failure alarms. 
     */
    struct CofTrigger_t 
    {
        /** zero based index of the board's slot number (0 = main board). */
        unsigned short          SlotNumber; 
        /** defines the trigger for the alarm. */
        eBoardPresenceTrigger_t Trigger; 
    };

    /** List of card not operational failure alarm triggers. 
     *  This is a sequence of @ref CofTrigger_t. 
     */
    typedef sequence<CofTrigger_t> CofTriggerList_t;

    /** Sets the trigger for card not operational failure alarms for one or more cards.
     *
     * @param[in] TriggerList a list containing for each card a trigger configuration
     *
     * @exception OpNotSucceeded when TriggerList is emptyr or TriggerList contains a CofTrigger with BoardNr 
     *                           equal to invalid number, e.g. 0 (Main board) or overflow.
	 * @exception OpNotAllowed not logged on
	 * @exception OpNotSupported never thrown
     * @exception Timeout never thrown
     */
    void SetCardOperFailureTriggers(in CofTriggerList_t TriggerList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Retrieves the triggers for card not operational failure alarms for all cards.
     *
     * @param[in] TriggerList a list containing for each card a trigger configuration
     *
     * @exception OpNotAllowed not logged on
     * @exception OpNotSucceeded never thrown
     * @exception OpNotSupported never thrown
     * @exception Timeout never thrown
     */
    void GetCardOperFailureTriggers(out CofTriggerList_t TriggerList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /// @} end of mm
#endif // DISABLE_MM
#ifndef DISABLE_BACKUP

    /// @addtogroup BitrateThresholdAlarms
    /// @{

    /** Structure to pass payload and stuffing bitrate threshold alarm settings. */
    struct BitrateAlarmSetting_t
    {
      unsigned long PayloadBitrateThreshold;  ///< In pbs.  When payload drops below this threshold, alarm will be triggered.
      boolean       PayloadBitrateEnabled;    ///< True means alarm monitoring is enabled for the 'Payload Bitrate Too Low' alarm.
      unsigned long StuffingRateThreshold;    ///< In bps.  When stuffing drops below this threshold, alarm will be triggered.
      boolean       StuffingRateEnabled;      ///< True means alarm monitoring is enabled for the 'Stuffing Bitrate Too Low' alarm.
    };

    /** Structure to pass payload and stuffing bitrate threshold alarm settings to one specific TS. */
    struct OutTS_AlarmSetting_t
    {
      IPS_RefTS_t           OutTsRef;         ///< Reference to the TS for which the settings are intended.
      BitrateAlarmSetting_t AlarmSetting;     ///< The alarm settings themselves.
    };

    typedef sequence<OutTS_AlarmSetting_t>  OutTS_AlarmSettingList_t; ///< List of alarm settings.
    typedef sequence<unsigned long>         RefList_t;    ///< List of TS indices

    /** Sets bitrate threshold alarm parameters for a (number of) TS(s).
     *
     * @param[in] PhysRef   The port for which the settings are intended.
     * @param[in] AlarmList A list holding the new settings in combination with the TS they're intended for.
     */
    void OutTsSetBitrateThresholdL(in IPS_Ref_t PhysRef, in OutTS_AlarmSettingList_t AlarmList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported); 

    /** Retrieves the bitrate threshold alarm parameters for a (number of) TS(s).
     *
     * @param[in] PhysRef   The port from which the settings are needed.
     * @param[in] TsIdxs    A list holding the TS indexes from which the settings are needed.
     *                      This list can be left empty to return the settings for all TSs on the given PhysRef.
     */
    OutTS_AlarmSettingList_t OutTsGetBitrateThresholdL(in IPS_Ref_t PhysRef, in RefList_t TsIdxs)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported); 

    /** Sets bitrate threshold alarm default parameters.
     *
     * @param[in] Board         The board for which the settings are intended.
     * @param[in] BitrateAlarm  The new default settings.
     */
    void SetBitrateAlarmDefaults(in unsigned short Board, in BitrateAlarmSetting_t BitrateAlarm)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported); 

    /** Retrieves bitrate threshold alarm default parameters.
     *
     * @param[in] Board         The board from which the settings are needed.
     */
    BitrateAlarmSetting_t GetBitrateAlarmDefaults(in unsigned short Board)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported); 

    /// @} end of BitrateThresholdAlarms
    
    /// @addtogroup backup 
    /// @{
    struct ServiceBackupParams_t
    {
       boolean Revertive;
       unsigned long HighToLowPriorityDelay; ///< time in seconds to wait before switching to backup
       unsigned long LowToHighPriorityDelay; ///< time in seconds to wait before switching back to main input
    };

    struct BackupService_t
    {
       IPS_Service_t BackupService; ///< specifies BoardNr, PortNr, TS and output SID 
    };
    typedef sequence<BackupService_t> BackupServiceList_t;

    struct BackupSrvTable_t
    {
      IPS_Service_t MergeSvcSource; ///< specifies BoardNr, PortNr, TS and input SID of merged service 
                                    ///< (main or merged in service)
      BackupServiceList_t BackupSvcList; ///< specifies list of BoardNr, PortNr, TS and input SID 
                                         ///< for backup service
    };
    typedef sequence<BackupSrvTable_t> BackupSrvTableList_t;

    /** Sets the ServiceBackup parameters for an output service. Obsolete from V6.0 onwards.
     * 
     * @param[in] OutService specifies BoardNr, PortNr, TS and output SID to set the BU-params for
     * @param[in] ServiceBackupParams BU-parameters
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case of
     * - Invalid OutService reference (BoardNr, PortNr, TS and SID)
     */
    void SetServiceBU_Params(in IPS_Service_t OutService, in ServiceBackupParams_t ServiceBackupParams)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Gets the ServiceBackup parameters of an output service. Obsolete from V6.0 onwards.
     *  If the mode is floating (not supported in this IIOP call), then Revertive false will be returned. 
     * @param[in] OutService specifies BoardNr, PortNr, TS and output SID to get the BU-params of
     * @param[out] ServiceBackupParams BU-parameters
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case of
     * - Invalid OutputService reference (BoardNr, PortNr, TS and SID)
     */
    void GetServiceBU_Params(in IPS_Service_t OutService, out ServiceBackupParams_t ServiceBackupParams)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    enum eServiceBackupMode_t
    { // SBU = Service BackUp
        eSBU_NonRevertive,
        eSBU_Revertive,
        eSBU_Floating   ///< In this mode a switch will happen when the active source is bad 
                        ///< and any other good source is available.
    };
    
    struct ServiceBackupParams2_t
    {
      eServiceBackupMode_t  BU_Mode;
      unsigned long HighToLowPriorityDelay;  // time in seconds to wait before switching to backup
      unsigned long LowToHighPriorityDelay;  // time in seconds to wait before switching back to main input
    };

    /** Sets the ServiceBackup parameters for an output service. Supported from V6.0 onwards.
     * 
     * @param[in] OutService specifies BoardNr, PortNr, TS and output SID to set the BU-params for
     * @param[in] ServiceBackupParams2 BU-parameters
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case of
     * - Invalid OutService reference (BoardNr, PortNr, TS and SID)
     * - Invalid mode specified in the ServiceBackupParams
     */
    void SetServiceBU_Params2(in IPS_Service_t OutService, in ServiceBackupParams2_t ServiceBackupParams2)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Gets the ServiceBackup parameters of an output service. Supported from V6.0 onwards.
     * 
     * @param[in] OutService specifies BoardNr, PortNr, TS and output SID to get the BU-params of
     * @param[out] ServiceBackupParams2 BU-parameters
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case of
     * - Invalid OutputService reference (BoardNr, PortNr, TS and SID)
     */
    void GetServiceBU_Params2(in IPS_Service_t OutService, out ServiceBackupParams2_t ServiceBackupParams2)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    /** Sets the ServiceBackupList of an output service.
     * 
     * @param[in] OutService specifies BoardNr, PortNr, TS and output SID to set the BuSrv-List for
     * @param[in] BackupSrvList List of backup input services
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case of
     * - Invalid OutputService reference (BoardNr, PortNr, TS and SID)
     * - number of backup services in BackupSrvList.BackupSvcList.BackupService > 1. 
     * 
     * @note Only one backup service can be specified
     * @note From Release V8.2.87 onwards it is possible to specify up to 8 backup services      
     */
    void SetServiceBU_BackupL(in IPS_Service_t OutService, in BackupSrvTableList_t BackupSrvList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Gets the ServiceBackupList of an output service.
     * 
     * @param[in] OutService specifies BoardNr, PortNr, TS and output SID  to get the BuSrv-List of
     * @param[out] BackupSrvList List backup input services 
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case of 
     * - Invalid OutputService reference (BoardNr, PortNr, TS and SID)
     */
    void GetServiceBU_BackupL(in IPS_Service_t OutService, out BackupSrvTableList_t BackupSrvList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Lets the user activate for a certain output service, the input service to be used.
     * If it appears that the chosen input service is in alarm, the input will automatically
     * switch to another backup input service after the specified delay time.
     * If the revertive setting is activated then the service will switch back
     * to the original service if that service is active
     * 
     * @param[in] OutService        Service where the active source should be set.
     * @param[in] InMergeSvcSource  Merged service reference for wich a certain input service source is activated
     * @param[in] ActiveInService   Input service source to be activated
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded Invalid service reference. 
     */
    void SetActiveInputService(in IPS_Service_t OutService, in IPS_Service_t InMergeSvcSource, in IPS_Service_t ActiveInService)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Gets for a certain output service, the active input service.
     * 
     * @param[in] OutService        Service where the active source should is requested from.
     * @param[in] InMergeSvcSource  Merged service reference where the active source should is requested from
     * @param[out] ActiveInService   Active input service source
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded Invalid service reference. 
     */
    void GetActiveInputService(in IPS_Service_t OutService, in IPS_Service_t InMergeSvcSource, out IPS_Service_t ActiveInService)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Sets for service backup that the switch to the backup service will only happen if this service is not in alarm.
     * 
     * @param[in] Board    
     * @param[in] Enabled  TRUE if the switch to the backup service will only happen if this service is not in alarm.
     * 
     * @exception OpNotSupported when Board = 0 = Main board.
     * @exception OpNotSucceeded if Board is invalid
     */
    void SetServiceBU_SwitchToGoodSrcOnly(in unsigned short Board, in boolean Enabled)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Gets for service backup if the switch to the backup service will only happen if this service is not in alarm.
     * 
     * @param[in] Board    
     * @param[out] Enabled  TRUE if the switch to the backup service will only happen if this service is not in alarm.
     * 
     * @exception OpNotSupported when Board = 0 = Main board.
     * @exception OpNotSucceeded if Board is invalid
     */
    void GetServiceBU_SwitchToGoodSrcOnly(in unsigned short Board, out boolean Enabled)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    struct AltSrcBU_Setting_t
    {
      AlternateSrcId_t AlternateSrcId;
      BackupSrvTableList_t BackupSrvTableList;
    };
    typedef sequence<AltSrcBU_Setting_t> AltSrcBU_SettingList_t;


    /** Sets the ServiceBackupList of an output service for a certian alternate source.
     * 
     * @param[in] OutService specifies BoardNr, PortNr, TS and output SID to set the BuSrv-List for
     * @param[in] AltSrcBU_Setting The settings that contain the backup sources
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case of
     * - Invalid OutputService reference (BoardNr, PortNr, TS and SID)
     * - number of backup services in BackupSrvList.BackupSvcList.BackupService > 1. 
     * 
     * @note Only one backup service can be specified
     * @note From Release V8.2.87 onwards it is possible to specify up to 8 backup services 
     *
     * @version Release 7.1
     */
    void SetServiceBU_BackupL_V2(in IPS_Service_t OutService, in AltSrcBU_Setting_t AltSrcBU_Setting)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Gets the Backup services for all alternate sources of an output service.
     * 
     * @param[in] OutService specifies BoardNr, PortNr, TS and output SID  to get the BuSrv-List of
     * @param [in] AlternateSrcIdList The IDs of the alternate sources for which settings are requested.
                   If empty, then settings of all services on the TS are returned.
     * @param[out] AltSrcBU_SettingList List backup input services 
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded in case of 
     * - Invalid OutputService reference (BoardNr, PortNr, TS and SID)
     *
     * @version Release 7.1
     */

    void GetServiceBU_BackupL_V2(in IPS_Service_t OutService, in AlternateSrcIdList_t AlternateSrcIdList, out AltSrcBU_SettingList_t AltSrcBU_SettingList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    struct AltSrcMergeActiveInSvc_t
    {
      AlternateSrcId_t AlternateSrcId; ///< The id of the alternate svc where the merge svc is located
      IPS_Service_t MergeService;      ///< The Merge Svc on which the Backup Svc is located
      IPS_Service_t ActiveInService;   ///< The Backup Svc that is (get) or should be (set) activated
    };
    typedef sequence<AltSrcMergeActiveInSvc_t> AltSrcMergeActiveInSvcList_t;

    /** Lets the user activate for a certain output service, the input service to be used.
     * 
     * @param[in] OutService        Service where the active source should be set.
     * @param[in] AltSrcMergeActiveInSvc  the backup service to activate
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded Invalid service reference. 
     *
     * @version Release 7.1
     */
    void SetActiveInputService_V2(in IPS_Service_t OutService, in AltSrcMergeActiveInSvc_t AltSrcMergeActiveInSvc)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Gets for a certain output service, the active input services for all its alternate sources.
     * 
     * @param[in] OutService        Service where the active source should is requested from.
     * @param [in] AlternateSrcIdList The IDs of the alternate sources for which settings are requested.
                   If empty, then settings of all services on the TS are returned.
     * @param[out] AltSrcMergeActiveInSvcList   Active input service sources
     * 
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded Invalid service reference. 
     *
     * @version Release 7.1
     */
    void GetActiveInputServices_V2(in IPS_Service_t OutService, in AlternateSrcIdList_t AlternateSrcIdList, out AltSrcMergeActiveInSvcList_t AltSrcMergeActiveInSvcList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    enum ServiceSourcePriority_t
    {
      eMainPriority,
      eHighestBackupPriority,
      eReservedPriority1,  // future use
      eReservedPriority2,  // future use
      eReservedPriority3,  // future use
      eReservedPriority4,  // future use
      eReservedPriority5,  // future use
      eReservedPriority6,  // future use    
      eReservedPriority7   // future use
    };

    struct TsOutSvcSourceSelection_t
    {
      IPS_RefTS_t               RefTs;
      ServiceSourcePriority_t   SrcToActivate;
    };
    
    typedef sequence<TsOutSvcSourceSelection_t> TsOutSvcSourceSelectionList_t;
    
    /** Lets the user activate for a all active alternate output services on a board  the main 
     *  or backup service sources. (also for all active merged services)
     * 
     * @param[in] BoardNr             specifies for which (output) board the call is meant     
     * @param[in] SourcePrio        specifies which source should be activated (main or highest priority backup source).
     * 
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded Invalid priority given. 
     * @exception OpNotAllowed   Not logged on
     *
     * @version Release 8.0
     */  
    void BoardBU_SvcSourcesActivate(in unsigned short BoardNr, in ServiceSourcePriority_t SourcePrio)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Lets the user activate for all active alternate output services 
     * of one or more output transport streams, the main 
     *  or backup service sources. (also for all active merged services)
     *
     * @param[in] PhysRef The port the OutTS are attached to. 
     *            ANY_PORT allowed
     * @param[in] TsOutSvcSourceSelectionList List of RefTs/SvcSourceSelection
     * 
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSupported when BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case of
     * - PhysRef does not exist 
     * - ServiceSourcePriority_t  out of range
     * - RefTs does not match PhysRef or cannot be found
     * @exception OpNotAllowed   Not logged on.
     *
     * @version Release 8.0
     */    
    void OutTS_BU_SvcSource_ActivateL(in IPS_Ref_t PhysRef, in TsOutSvcSourceSelectionList_t TsOutSvcSourceSelectionList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /// @} end add to group backup
#endif // DISABLE_BACKUP

#ifndef DISABLE_SMX
        /// @addtogroup statmux 
    /// @{

    struct SMX_PoolRef_t
    {
      unsigned short BoardNr;
      unsigned short PoolNr;
    };

    enum StatMuxMode
    {
      SMM_Async,
      SMM_Sync,
      SMM_Off
    };

    enum ContentMode
    {
      CM_AVC_MPEG2_Combined,
      CM_MPEG2
    };

    struct SMX_StatMuxPool
    {
      SMX_PoolRef_t PoolRef;
      string Name;
      unsigned long Bitrate;
      StatMuxMode Mode;
      ContentMode CM_Mode;
      unsigned short Priority;
    };

    typedef sequence<SMX_StatMuxPool> SMX_StatMuxPoolList;

    /**
     * @todo Documentation.
     */
    SMX_StatMuxPoolList SMX_StatMuxPools_GetL(in SMX_PoolRef_t PoolRef)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    struct SMX_StatMuxPool_V2
    {
      SMX_PoolRef_t PoolRef;
      string Name;
      unsigned long Bitrate;
      StatMuxMode Mode;
      ContentMode CM_Mode;
      unsigned short Priority;
      boolean Active;
	  string multicastIP;
    };

    typedef sequence<SMX_StatMuxPool_V2> SMX_StatMuxPoolList_V2;

    /**
     * @todo Documentation.
     */
    SMX_StatMuxPoolList_V2 SMX_StatMuxPools_GetL_V2(in SMX_PoolRef_t PoolRef)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @todo Documentation.
     */
    void SMX_StatMuxPools_SetL(in unsigned short BoardNr, in SMX_StatMuxPoolList PoolList)
          raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

	/**
     * @todo Documentation.
     */
    void SMX_StatMuxPools_SetL_V2(in unsigned short BoardNr, in SMX_StatMuxPoolList_V2 PoolList)
          raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    struct SMX_EncRef_t
    {
      SMX_PoolRef_t PoolRef;
      unsigned long EncRef;
    };

    enum EncoderState
    {
      ES_OK,
      ES_Disconnected
    };

    enum FrameRateCodes
    {
      FRAME_RATE_CODE_23_HZ,
      FRAME_RATE_CODE_24_HZ,
      FRAME_RATE_CODE_25_HZ,
      FRAME_RATE_CODE_29_HZ,
      FRAME_RATE_CODE_30_HZ,
      FRAME_RATE_CODE_50_HZ,
      FRAME_RATE_CODE_59_HZ,
      FRAME_RATE_CODE_60_HZ
    };

    enum VideoFormats
    {
      MQF_VF_SD,
      MQF_VF_HD1080I,
      MQF_VF_HD720P,
      MQF_VF_HDP3
    };

    enum EncoderType
    {
      ET_MPEG2,
      ET_AVC
    };

    struct SMX_Encoder_t
    {
      SMX_EncRef_t EncRef;
      IPS_Ref_t Management;
      string SourceIP;
      IPS_UDP_Socket_t Destination;
      short Priority;
      EncoderState State;
      unsigned long MinBitrate;
      unsigned long MaxBitrate;
      unsigned long DefBitrate;
      unsigned long TargetBitrate;
      FrameRateCodes FrameRateCode;
      VideoFormats VideoFormat;
      EncoderType Type;
    };

    typedef sequence<SMX_Encoder_t> SMX_EncoderList;

    /**
     * @todo Documentation.
     */
    SMX_EncoderList SMX_Encoders_GetL(in SMX_PoolRef_t PoolRef)
          raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    struct SMX_ServiceRef_t
    {
      SMX_EncRef_t EncRef;
      unsigned long SID;
    };

    struct SMX_Service_t
    {
      SMX_EncRef_t EncRef;
      unsigned long SID;
      DvbString_t ServiceName;
      IPS_UDP_Socket_t Source;
    };

    typedef sequence<SMX_Service_t> SMX_ServiceList;

    /**
     * @todo Documentation.
     */
    IP_List_t SMX_EncoderBlackList_GetL(in unsigned short BoardNr)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @todo Documentation.
     */
    void SMX_EncoderBlackList_AddL(in unsigned short BoardNr, in IP_List_t EncoderList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @todo Documentation.
     */
    void SMX_EncoderBlackList_DeleteL(in unsigned short BoardNr, in IP_List_t EncoderList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @todo Documentation.
     */
    SMX_ServiceList SMX_Service_GetL(in SMX_PoolRef_t PoolRef)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    enum BackupType
    {
      BT_Main,
      BT_Backup
    };

    /**
     * @todo Documentation.
     */
    string SMX_BoardSetup_Get(in unsigned short BoardNr)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @todo Documentation.
     */
    void SMX_BoardSetup_Set(in unsigned short BoardNr, in string MulticastIP)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @todo Documentation.
     */
    BackupType SMX_BackupType_Get(in unsigned short BoardNr)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @todo Documentation.
     */
    void SMX_BackupType_Set(in unsigned short BoardNr, in BackupType Type)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @todo Documentation.
     */
    boolean SMX_GetStatmux(in unsigned short BoardNr)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @todo Documentation.
     */
    void SMX_SetStatmux(in unsigned short BoardNr, in boolean Enabled)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    enum SMX_EnablingMode_e
    {
      SMX_StatmuxDisabled,
      SMX_StatmuxEnabled,
      SMX_D9036StatmuxEnabled
    };

    /**
     * @brief SMX_GetStatmux(in unsigned short BoardNr) Get the statmux enabling mode.
     * @note Older version this was a boolean 0=statmux disabled 1=statmux enabled (D9032 statmux).
     * @version release 8.9
    */
    SMX_EnablingMode_e SMX_GetStatmux_V2(in unsigned short BoardNr)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /**
     * @brief SMX_SetStatmux(in unsigned short BoardNr, in SMX_EnablingMode_e EnableMode) Sets the statmux enabling mode.
     * @note Older version this was a boolean 0=statmux disabled 1=statmux enabled (D9032 statmux).
     * @version release 8.9
    */
    void SMX_SetStatmux_V2(in unsigned short BoardNr, in SMX_EnablingMode_e EnableMode)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    struct SMX_EncVideoBitRate_t
    {
      SMX_ServiceRef_t ServiceRef;
      BitRateSampleList_t videoBitRateSamplelist;
    };

    typedef sequence<SMX_EncVideoBitRate_t> SMX_EncVideoBitRateList;

    /**
     * @todo Documentation.
     */
	void SMX_GetStatmuxPoolBitrates(in SMX_PoolRef_t PoolRef, out SMX_EncVideoBitRateList EncBitRatesList, out BitRateSampleList_t NullRateList)
		raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /// @} end add to group statmux

    /** 
     * @defgroup D9036 Statmux.
     * @brief Types and methods used to configure D9036 Statmux.
     * @version release 9.0
     */

    /**
     * @brief QoS for D9036 Statmux Device
     * @note Placed at device level in the GUI.
     * @version release 9.0
     */
    enum SMX36_QoSMode_e
    {
      SMX36_QoSMode_ToS_CoS_Precedence,
      SMX36_QoSMode_Differentiated,
      SMX36_QoSMode_Custom
    };

    enum SMX36_ToS_e
    {
      SMX36_ToS_Normal,
      SMX36_ToS_MinCost,
      SMX36_ToS_MaxReliability,
      SMX36_ToS_MaxThroughput,
      SMX36_ToS_MinDelay
    };

    enum SMX36_CoS_e
    {
      SMX36_CoS_Routine,
      SMX36_CoS_Priority,
      SMX36_CoS_Immediate,
      SMX36_CoS_Flash,
      SMX36_CoS_FlashOverride,
      SMX36_CoS_CriticECP,
      SMX36_CoS_InternetworkControl,
      SMX36_CoS_NetworkControl
    };

    struct SMX36_NetworkQoS_t 
    {
      unsigned short TTL_Value; ///< TTL (Time to live) range [1-255].
      SMX36_QoSMode_e QosMode;  ///< QoS Mode.
      SMX36_ToS_e ToS;          ///< (mode ToS_CoS_Precedence) ToS value (not custom).
      SMX36_CoS_e CoS;          ///< (mode ToS_CoS_Precedence) CoS value.
      unsigned short codePoint; ///< (mode Differentiated) Differentiated Service code Point range [0-255].
      unsigned short ToSCustom; ///< (mode Custom) ToS custom value range [0-255].
    };

    /**
     * @brief SMX36_QoS_Get() Reads the QoS parameters for all statmux communication in the Device.
     * @version release 9.0
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     */
    SMX36_NetworkQoS_t SMX36_QoS_Get()
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /**
     * @brief SMX36_QoS_Set(in SMX36_NetworkQoS_t QoS) Sets the QoS parameters for all statmux communication in the Device.
     * @version release 9.0
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Set failed. 
     */
    void SMX36_QoS_Set( in SMX36_NetworkQoS_t QoS)
          raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /****************************************************
     * Community settings for the device D9036 Statmux.
     ****************************************************/
    struct SMX36_Community_t
    {
      string Name;               ///< Name of the statmux community MAX string length = 20
      string MulticastIPAddress; ///< The Community multicast IP used by units to join the statmux community
      unsigned short UdpPort;    ///< Community communication port range: 1024 (0X400) .. 65535
    };

    /**
     * @brief SMX36_Community_Get() Reads the community parameters for the device i.e. all boards in the device.
     * @version release 9.0
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     */
    SMX36_Community_t SMX36_Community_Get()
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);
    /**
     * @brief SMX36_Community_Set(in SMX36_Community_t Community) Sets the community parameters for the device i.e. all boards in the device.
     * @version release 9.0
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     */
    void SMX36_Community_Set(in SMX36_Community_t Community)
          raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /**
     * @brief SMX36_PortPairSetup_Get(in unsigned short BoardNr ) Reads the used Physical PortPair number 0=pairA 2=pairB. 
     * @version release 9.0
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     */
    unsigned short SMX36_PortPairSetup_Get(in unsigned short BoardNr )
          raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);
    
    /**
     * @brief SMX36_PortPairSetup_Set(in unsigned short BoardNr, in unsigned short PortNumber) Sets the used Physical PortPair [0,2].
     * @version release 9.0
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     */
    void SMX36_PortPairSetup_Set(in unsigned short BoardNr, in unsigned short PortNumber)
          raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /*******************************************************
     * Statmux Controller Board settings for D9036 Statmux.
     *******************************************************/
    enum SMX36_StatmuxControllerBackupState_e
    {
      SMX36_StatmuxControllerBackupState_Active,
      SMX36_StatmuxControllerBackupState_Inactive
    };
    
    struct SMX36_StatmuxController_t
    {
      long Id;              ///< RO Statmux Controller Id.
      string DeviceIPAddress; ///< RO management IPaddress of the device where the controller is placed.   
      string SystemName;    ///< RO Systemname hat is the name of the DCM.
      string CardName;      ///< RO (CardName) Board of the statmux controller.
      short PoolCapacity;   ///< RO The max number of pool the controller can handle.
      short ActivePools;    ///< RO The number of active running pools on the controller.
      short SVCCapacity;    ///< RO The max number of SVC (video channels) the controller can handle.
      short ActiveVSEs;     ///< RO The number of active running VSE on the controller.
      SMX36_StatmuxControllerBackupState_e BackupState; ///< Future need to be clarified.
    };

    typedef sequence<SMX36_StatmuxController_t> SMX36_StatmuxControllerList_t;

    /**
     * @brief SMX36_StatmuxControllerList_t SMX36_Controllers_GetL( in long Id ) Reads the statmux controller parameters.
     * @note If the Id equal or less than -1 all statmux controlers within the statmux community is listed.
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     * @version release 9.0
     */
    SMX36_StatmuxControllerList_t SMX36_Controllers_GetL( in long Id )
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /**
     * @brief SMX36_GetStartingUdpPort() Reads the starting UDP port number given to the SPS to be used for communication with the SPSs.
     * @version release 9.0
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     */
    unsigned short SMX36_GetStartingUdpPort()
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);
    /**
     * @brief SMX36_SetStartingUdpPort(in unsigned short StartingUdpPort) Sets the starting UDP port number given to the SPS to be used for communication with the SPSs.
     * @version release 9.0
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     */
    void SMX36_SetStartingUdpPort(in unsigned short StartingUdpPort)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /**********************************************
     * Statmux Pool settings for D9036 Statmux.
     **********************************************/
    enum SMX36_PoolSafeRateMode_e
    {
      SMX36_PoolSafeRateMode_Default,
      SMX36_PoolSafeRateMode_Min,
      SMX36_PoolSafeRateMode_Reserved  ///< Not used.
    };

    enum SMX36_PoolGuaranteeMinRateMode_e
    {
      SMX36_PoolGuaranteeMinRateOff,
      SMX36_PoolGuaranteeMinRateON
    };

    struct SMX36_Pool_t
    {
      long Id;                   ///< RO Pool Id.
      string Name;               ///< Name of pool. MAX string length = 20
      unsigned short UdpPort;    ///< RO UDP Port used to communicate to the SPS.  
      unsigned long controllerId;       ///< RO Statmux controller Id of the board where the pool is running if alocated else 0.
      unsigned short VSEParticipants;   ///< RO The number of VSE running in the pool.  
      unsigned long Bandwidth;   ///< (bps) The bandwidth of the pool (bps). Must be greather than BandwidthOverhead.
      unsigned long BandwidthOverhead;  ///< (bps) Overhead/Free-space to the bandwidth used to prevent overshoot on a mux with a small input buffer. must be less that bandwidth 
      unsigned short STickLength;       ///< (ms) The S-Tick length of the pool.
      unsigned short MaxVSECapacity;    ///< Maximum number of VSE's expected to be in the pool. range (1-24)
      unsigned long Pool_Property;      ///< Read only Bitmap used by GUI to display specific icons 
      SMX36_PoolSafeRateMode_e SafeRateMode; ///< Safe rate mode defines the rate the VSE must fall back on if communication fails to statmux controller. 
      unsigned short SPSInstance;       ///< RO (Reserved) The instance number of the SPS where the pool is running if allocated else 0. 
      SMX36_PoolGuaranteeMinRateMode_e GuaranteeMinRateMode; ///< Controls whether VSE's releases unused videobandwidth below the min rate to 
                                                             ///the rest of the pool when the video complexity is low.
    };

    typedef sequence<SMX36_Pool_t> SMX36_PoolList_t;

    struct SMX36_Pool_V2_t
    {
      long Id;                   ///< RO Pool Id.
      string Name;               ///< Name of pool. MAX string length = 20
      unsigned short UdpPort;    ///< RO UDP Port used to communicate to the SPS.  
      unsigned long controllerId;       ///< RO Statmux controller Id of the board where the pool is running if alocated else 0.
      unsigned short VSEParticipants;   ///< RO The number of VSE running in the pool.  
      unsigned long Bandwidth;   ///< (bps) The bandwidth of the pool (bps). Must be greather than BandwidthOverhead.
      unsigned long BandwidthOverhead;  ///< (bps) Overhead/Free-space to the bandwidth used to prevent overshoot on a mux with a small input buffer. must be less that bandwidth 
      unsigned short STickLength;       ///< (ms) The S-Tick length of the pool.
      unsigned short MaxVSECapacity;    ///< Maximum number of VSE's expected to be in the pool. range (1-24)
      unsigned long Pool_Property;      ///< Read only Bitmap used by GUI to display specific icons 
      SMX36_PoolSafeRateMode_e SafeRateMode; ///< Safe rate mode defines the rate the VSE must fall back on if communication fails to statmux controller. 
      unsigned short SPSInstance;       ///< RO (Reserved) The instance number of the SPS where the pool is running if allocated else 0. 
      boolean  NtpSyncRequired;         ///< RW If True, then if DCM NTP Sync Alarm is set, put all VSE members to default rate.
    };

    typedef sequence<SMX36_Pool_V2_t> SMX36_PoolList_V2_t;

    /**
     * @brief SMX36_Pool_GetL(in long poolid) Reads the Pool parameters.
     * @note If the Id is less or equal to -1 all pool's in the statmux community is listed.
     * @version release 9.0 (V2->V11.00)
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     */
    SMX36_PoolList_t SMX36_Pool_GetL(in long poolid)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);
    SMX36_PoolList_V2_t SMX36_Pool_V2_GetL(in long poolid)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);
    /**
     * @brief SMX36_Pool_SetL(in SMX36_PoolList_t Poollist) Sets the parameters for the pool in the list.
     * @version release 9.0 (V2->V11.00)
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     */
    void SMX36_Pool_SetL(in SMX36_PoolList_t Poollist)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);
    void SMX36_Pool_V2_SetL(in SMX36_PoolList_V2_t Poollist)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /**
     * @brief SMX36_Pool_Create(in string PoolName) creates a pool and return the Id.
     * @note If The Name already exist no pool will be created and the return Id will be zero.
     *       If it is not possible to allocate the resources for the Pool the call will return OperationFailed. 
     *       The Pool will be created with the following parameter values:
     *       BandwidthOverhead = 0, STickLength = 30, SafeRateMode = SMX36_PoolSafeRateMode_Default, 
     *       GuaranteeMinRateMode = SMX36_PoolGuaranteeMinRateOff.
     * @version release 9.0
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Unable to create pool or an internal error occurred. 
     */
    long SMX36_Pool_Create(in string PoolName, in unsigned long PoolBandwidth, in unsigned short PoolMaxVSECapacity)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /**
     * @brief SMX36_Pool_Delete(in SMX36_PoolIdList_t PoolIdlist) delets the pool.
     * @version release 9.0
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     */
    typedef sequence<long> SMX36_PoolIdList_t;

    void SMX36_Pool_DeleteL(in SMX36_PoolIdList_t PoolIdlist )
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /********************************************************
     * Pool algorithm selection for D9036 Statmux.
     ********************************************************/
    enum SMX36_AlgorithmType_e 
    {
      SMX36_AlgorithmType_RateTable,    ///< pre-URC version
      SMX36_AlgorithmType_URC,          ///< Unified Rate Control
      SMX36_AlgorithmType_reserved1,
      SMX36_AlgorithmType_reserved2,
      SMX36_AlgorithmType_reserved3,
      SMX36_AlgorithmType_reserved4,
      SMX36_AlgorithmType_reserved5,
      SMX36_AlgorithmType_reserved6,
      SMX36_AlgorithmType_reserved7,
      SMX36_AlgorithmType_reserved8
    };

    struct SMX36_AlgorithmIdentifier_t {
      SMX36_AlgorithmType_e   Type;           ///< Algorithm Type
      unsigned long           MajorVersion;   ///< Major version part: the xx out of Vxx.yy
      unsigned long           MinorVersion;   ///< Minor version part: the yy out of Vxx.yy
    };

    typedef sequence<SMX36_AlgorithmIdentifier_t> SMX36_AlgorithmIdentifierList_t;

    /**
     * @brief SMX36_SupportedAlgorithm_GetL() Retrieve the supported D9036 statmux algorithms.
     * @version release 11.0
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     */
    SMX36_AlgorithmIdentifierList_t SMX36_SupportedAlgorithm_GetL()
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /**
     * @brief SMX36_DefaultAlgorithm_Get() Retrieve the default selected algorithm for a pool.
     * @note Currently this is the algorithm as used by all pools.
     * @version release 11.0
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     */
    SMX36_AlgorithmIdentifier_t SMX36_DefaultAlgorithm_Get()
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /**
     * @brief SMX36_DefaultAlgorithm_Set( in SMX36_AlgorithmIdentifier_t DefaultAlgorithm ) 
     *        Set the algorithm to be used by all pools.
     * @note  Currently this is a system wide enforcment. As such it will stop all pools and 
     *        and restart them (service affecting!) if the new setting is different
     *        than the current one.
     * @version release 11.0
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     */
    void SMX36_DefaultAlgorithm_Set(in SMX36_AlgorithmIdentifier_t DefaultAlgorithm)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);



    /********************************************************
     * Encoder settings for D9036 Statmux.
     ********************************************************/
    enum SMX36_EncoderStatus_e
    {
      SMX36_EncoderStatus_Disconnected,
      SMX36_EncoderStatus_Connected
    };

    struct SMX36_Encoder_t {
      long Id;                           ///< Encoder Id 
      string EncoderIPAddress;           ///< RO IPaddress of the encoder management port.
      string EncoderName;                ///< RO Name of the Encoder running. (MAX string length = 20)
      unsigned short EcoderVSECapacity;  ///< RO The Maximum number of VSE the current encoder can handle.  
      SMX36_EncoderStatus_e status;      ///< RO Status of the Encoder (Read only).
      unsigned long Encoder_Property;    ///< Read only Bitmap used by GUI to display specific icons 
    };

    typedef sequence<SMX36_Encoder_t> SMX36_EncoderList_t;

    /**
     * @brief SMX36_Encoder_GetL( in long Encoderid) Reads the Encoder parameters.
     * @note If the Id equal to -1 all Encoder's in the statmux community are listed.
     * @version release 9.0
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     */
    SMX36_EncoderList_t SMX36_Encoder_GetL( in long Encoderid)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /**
     * @brief SMX36_Encoder_Create( in string EncoderIPAddress ) creates an encoder and return the Id.
     * @note If The EncoderIPAdress already have been used no encoder will be created and the return will be zero.
     * @version release 9.0
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded unable to create encoder or Internal error. 
     */
    long SMX36_Encoder_Create(in string EncoderIPAddress )
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /**
     * @brief SMX36_Encoder_Delete(in SMX36_EncoderIdList_t EncoderIdlist) delets the encoder.
     * @version release 9.0
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     */
    typedef sequence<long> SMX36_EncoderIdList_t;

    void SMX36_Encoder_DeleteL(in SMX36_EncoderIdList_t EncoderIdlist )
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);


    /********************************************************
     * Video Service Elements VSE settings for D9036 Statmux.
     ********************************************************/
    enum SMX36_VSEDelay_e
    {
      SMX36_VSEDelay_Normal,
      SMX36_VSEDelay_Low,
      SMX36_VSEDelay_High
    };

    enum SMX36_VSEDelay_V2_e
    {
      SMX36_VSEDelay_V2_Normal,
      SMX36_VSEDelay_V2_Low,
      SMX36_VSEDelay_V2_High,
      SMX36_VSEDelay_Reserved1,
      SMX36_VSEDelay_Reserved2,
      SMX36_VSEDelay_Reserved3,
      SMX36_VSEDelay_Reserved4,
      SMX36_VSEDelay_Reserved5,
      SMX36_VSEDelay_Reserved6
    };

    struct SMX36_VSEParams_t
    {
      unsigned long DefBitrate;     ///< (bps) Default bitrate. Range (200.000 -> 60.000.000)
      unsigned long MinBitrate;     ///< (bps) Minimum bitrate. Range (200.000 -> 60.000.000)
      unsigned long MaxBitrate;     ///< (bps) Maximum bitrate. Range (200.000 -> 60.000.000)
      short Priority;               ///< VSE Priority. Range (0..6)
      SMX36_VSEDelay_e Delay;       ///< VSE Delay.
      short MinQ;                   ///< (Future) Minimum quality.
    };

    /** For URC mode (planned 10.20) */
    struct SMX36_VSEParams_V2_t
    {
      unsigned long DefBitrate;     ///< (bps) Default bitrate. Range (200.000 -> 60.000.000)
      unsigned long MinBitrate;     ///< (bps) Minimum bitrate. Range (200.000 -> 60.000.000)
      unsigned long MaxBitrate;     ///< (bps) Maximum bitrate. Range (200.000 -> 60.000.000)
      short Priority;               ///< VSE Priority. Range (0..6)
      SMX36_VSEDelay_V2_e Delay;    ///< VSE Delay.
      short MinQ;                   ///< (Future) Minimum quality.
      boolean GuaranteeMinBitrate;  ///< if true, enforce minimum bitrate (by stuffing if needed), default: True
    };

    enum SMX36_VSEStatus_e
    {
      SMX36_VSEStatus_Disconnected, ///< Unable to communicate with VSE.
      SMX36_VSEStatus_Running,      ///< Statmuxing 
      SMX36_VSEStatus_Running_Safe, ///< Statmuxing but running with SAfe rate.
      SMX36_VSEStatus_Not_Running,  ///< Not configured to run statmux.  
      SMX36_VSEStatus_CBR,          ///< Constant bitrate mode.
      SMX36_VSEStatus_Capped_VBR    ///< Varialbe bitrate mode. 
    };

    enum SMX36_VSEBitRateMode_e
    {
      SMX36_VSEBitRateMode_Manual,  ///< User configures the default rates for the VSE.
      SMX36_VSEBitRateMode_Auto,    ///< The system calculates the default rates for the VSE.
      SMX36_VSEBitRateMode_reserved ///< reserved future use
    };

    enum SMX_VSEBackedupState_e
    {
      SMX36_VSEBackedupStat_no,     ///< The VSE is not backedup by an other VSE.
      SMX36_VSEBackedupStat_yes     ///< The VSE is curently backedup by an other VSE see backuplist.
    };

    struct SMX36_VSE_t
    {
      long Id;                        ///< RO Unique ID of the video service element.
      long EncoderId;                 ///< RO Id of the encoder where the VSE is running.   
      string VSEName;                 ///< RO VSEName of this Video encoding stream. MAX string length = 50.
      string VideoStreamEncoderName;  ///< RO For future use.
      SMX36_VSEStatus_e status;       ///< RO Status of the VSE.   
      long PoolId;                    ///< Pool Id of the pool containing this VSE if any if not assigned the id is -1. 
      SMX36_VSEParams_t params;       ///< Statmux parameters for the VSE.
      unsigned long VSE_Property;     ///< Read only Bitmap used by GUI to display specific icons 
      unsigned long BandwidthReserve; ///< (bps) Reserved bandwidth for other tributary's that the video, Used for auto bandwidth calculation on the pool.
      SMX36_VSEBitRateMode_e BitRateMode; ///< Default rate configuration mode manual or automatic. 
      string VideoSEClass;            ///< RO Video stream encoder class. String length = 80. 
      SMX_VSEBackedupState_e BackupState; ///< RO VSE backup state. 
    };

    typedef sequence<SMX36_VSE_t> SMX36_VSEList_t;

    /** Implemented in V9.10 **/
    struct SMX36_VSE_V2_t
    {
      long Id;                        ///< RO Unique ID of the video service element.
      long EncoderId;                 ///< RO Id of the encoder where the VSE is running.   
      string VSEName;                 ///< RO VSEName of this Video encoding stream. MAX string length = 50.
      string VideoStreamEncoderName;  ///< RO For future use.
      SMX36_VSEStatus_e status;       ///< RO Status of the VSE.   
      long PoolId;                    ///< Pool Id of the pool containing this VSE if any if not assigned the id is -1. 
      SMX36_VSEParams_t params;       ///< Statmux parameters for the VSE.
      unsigned long VSE_Property;     ///< Read only Bitmap used by GUI to display specific icons 
      unsigned long BandwidthReserve; ///< (bps) Reserved bandwidth for other tributary's that the video, Used for auto bandwidth calculation on the pool. 
      SMX36_VSEBitRateMode_e BitRateMode; ///< Default rate configuration mode manual or automatic. 
      string VideoSEClass;            ///< RO Video stream encoder class. String length = 80. 
      SMX_VSEBackedupState_e BackupState; ///< RO VSE backup state. 
      boolean Enabled;                ///< Is the VSE to be enabled in the statmux Pool.  
      string expectedVideoRateMode;   ///< RO Set when the VSE is placed in a Pool a alarm is raised if actual divigates from expected.  
    };

    typedef sequence<SMX36_VSE_V2_t> SMX36_VSEList_V2_t;

    enum SMX36_VSE_Codec_e
    {
      SMX36_VSE_Codec_Unknown,          ///< Only possible in status case, when encoder is offline and thus Codec is unknown.
      SMX36_VSE_Codec_Mpeg2,            ///< MPEG2 standard.
      SMX36_VSE_Codec_Avc,              ///< H.264 / AVC standard.
      SMX36_VSE_Codec_Reserved1,        ///< Reserved for future use
      SMX36_VSE_Codec_Reserved2,        ///< Reserved for future use
      SMX36_VSE_Codec_Reserved3,        ///< Reserved for future use
      SMX36_VSE_Codec_Reserved4,        ///< Reserved for future use
      SMX36_VSE_Codec_Reserved5,        ///< Reserved for future use
      SMX36_VSE_Codec_Reserved6         ///< Reserved for future use
    };

    enum SMX36_VSE_Format_e
    {
      SMX36_VSE_Format_Unknown,          ///< Only possible in status case, when encoder is offline and thus Format is unknown.
      SMX36_VSE_Format_SD,               ///< Standard definition
      SMX36_VSE_Format_HD,               ///< High definition
      SMX36_VSE_Format_Reserved1,        ///< Reserved for future use
      SMX36_VSE_Format_Reserved2,        ///< Reserved for future use
      SMX36_VSE_Format_Reserved3,        ///< Reserved for future use
      SMX36_VSE_Format_Reserved4,        ///< Reserved for future use
      SMX36_VSE_Format_Reserved5,        ///< Reserved for future use
      SMX36_VSE_Format_Reserved6         ///< Reserved for future use
    };

    /** Implemented in V10.20 **/
    struct SMX36_VSE_V3_t
    {
      long Id;                        ///< RO Unique ID of the video service element, as linked with the VSE after creation.
      long EncoderId;                 ///< RO Id of the encoder where the VSE is running (set upon SMX36_VSE_Create()
      string VSEName;                 ///< RO VSEName of this Video encoding stream. MAX string length = 50, set upon SMX36_VSE_Create()
      string VideoStreamEncoderName;  ///< RO For future use: (if multi video in vse, not yet used)
      SMX36_VSEStatus_e status;       ///< RO Status of the VSE.
      long PoolId;                    ///< Pool Id of the pool containing this VSE if any if not assigned the id is -1.
      unsigned long VSE_Property;     ///< Read only Bitmap used by GUI to display specific icons.
      unsigned long BandwidthReserve; ///< (bps) Reserved bandwidth for other tributary's that the video, Used for auto bandwidth calculation on the pool.
      SMX36_VSEBitRateMode_e BitRateMode; ///< Default rate configuration mode manual or automatic.
      SMX_VSEBackedupState_e BackupState; ///< RO VSE backup state. 
      boolean Enabled;                ///< Is the VSE to be enabled in the statmux Pool.
      string expectedVideoRateMode;   ///< RO Set when the VSE is placed in a Pool a alarm is raised if actual divigates from expected.

      /** new in V10.20 URC:
       * - string VideoSEClass from V2 is replaced by VideoCodecStatus and VideoFormatStatus enumerations.
       *   Depending on the enumeration, valid min/max range of defaul/min/max bitrate settings (params) can change.
       * - When VSE is not preconfigured and thus is a detected VSE, the Status will be copied on the settings.
       * - When a VSE is preconfigured, the Setting are set in the GUI and Status is Unknown (as VSE is offline).
       * - Setting can be changed at any time in the GUI.
       * - When setting does not match status and status is not Unknown (aka VSE is offline) an Alarm will be raised.
       */
      SMX36_VSE_Codec_e	VideoCodecStatus;   ///< RO, status as set on VSE: a way to get valid ranges of min/maxbitrates
      SMX36_VSE_Format_e VideoFormatStatus; ///< RO, status as set on VSE: a way to get valid ranges of min/maxbitrates
      SMX36_VSE_Codec_e VideoCodecSetting;  ///< RW, as set on GUI: a way to get valid ranges of min/maxbitrates and check that VSE is still set as expected
      SMX36_VSE_Format_e VideoFormatSetting;///< RW, as set on GUI: a way to get valid ranges of min/maxbitrates and check that VSE is still set as expected

      SMX36_VSEParams_V2_t params;    ///< Statmux parameters for the VSE.
    };

    typedef sequence<SMX36_VSE_V3_t> SMX36_VSEList_V3_t;


    enum SMX36_Video_Rate_Mode_e
    {
      SMX36_Video_Rate_Mode_Ignore,           ///< Do not enforce certain video rate mode when adding VSE to pool.
      SMX36_Video_Rate_Mode_Statmux,          ///< VSE is running in statmuxed rate mode
      SMX36_Video_Rate_Mode_CBR,              ///< VSE is running in CBR rate mode
      SMX36_Video_Rate_Mode_Capped_VBR,       ///< VSE is running in Capped VBR rate mode
      SMX36_Video_Rate_Mode_Reserved1,        ///< Reserved for future use
      SMX36_Video_Rate_Mode_Reserved2,        ///< Reserved for future use
      SMX36_Video_Rate_Mode_Reserved3,        ///< Reserved for future use
      SMX36_Video_Rate_Mode_Reserved4,        ///< Reserved for future use
      SMX36_Video_Rate_Mode_Reserved5,        ///< Reserved for future use
      SMX36_Video_Rate_Mode_Reserved6,        ///< Reserved for future use
      SMX36_Video_Rate_Mode_Reserved7,        ///< Reserved for future use
      SMX36_Video_Rate_Mode_Reserved8         ///< Reserved for future use
    };

    /** Implemented in V11.00 **/
    struct SMX36_VSE_V4_t
    {
      long Id;                        ///< RO Unique ID of the video service element, as linked with the VSE after creation.
      long EncoderId;                 ///< RO Id of the encoder where the VSE is running (set upon SMX36_VSE_Create()
      string VSEName;                 ///< RO VSEName of this Video encoding stream. MAX string length = 50, set upon SMX36_VSE_Create()
      string VideoStreamEncoderName;  ///< RO For future use: (if multi video in vse, not yet used)
      SMX36_VSEStatus_e status;       ///< RO Status of the VSE.
      long PoolId;                    ///< Pool Id of the pool containing this VSE if any if not assigned the id is -1.
      unsigned long VSE_Property;     ///< Read only Bitmap used by GUI to display specific icons.
      unsigned long BandwidthReserve; ///< (bps) Reserved bandwidth for other tributary's that the video, Used for auto bandwidth calculation on the pool.
      SMX36_VSEBitRateMode_e BitRateMode; ///< Default rate configuration mode manual or automatic.
      SMX_VSEBackedupState_e BackupState; ///< RO VSE backup state. 
      boolean Enabled;                ///< Is the VSE to be enabled in the statmux Pool.

      /** new in V11.00 URC:
       * - It is now possible to enforce the expected video rate mode from the VSE, by
       *   setting the enforced video rate mode to something else than ignore.
       * - Before, the expected video rate mode was default set to "Statmux" when preconfiguring
       *   VSE. For on-line VSEs the video rate mode of the VSE at the moment of joining the
       *   pool was set as the expected video rate mode. 
       * - If the enforced video rate mode is set to ignore, the previous behavior is kept.
       * - When the expected video rate mode is different compared with actual 
       *   video rate mode as detected on the on-line VSE, then an Alarm is triggered.
       */
      SMX36_Video_Rate_Mode_e expectedVideoRateMode;   ///< RO Set when the VSE is placed in a Pool. If enforceVideoRateMode is not Ignore, then this will be the saem as the enforceVideoRateMode.
      SMX36_Video_Rate_Mode_e enforcedVideoRateMode;   ///< RW To enforce the video rate mode expected from the VSE.

      /** new in V10.20 URC: See V3
       */
      SMX36_VSE_Codec_e	VideoCodecStatus;   ///< RO, status as set on VSE: a way to get valid ranges of min/maxbitrates
      SMX36_VSE_Format_e VideoFormatStatus; ///< RO, status as set on VSE: a way to get valid ranges of min/maxbitrates
      SMX36_VSE_Codec_e VideoCodecSetting;  ///< RW, as set on GUI: a way to get valid ranges of min/maxbitrates and check that VSE is still set as expected
      SMX36_VSE_Format_e VideoFormatSetting;///< RW, as set on GUI: a way to get valid ranges of min/maxbitrates and check that VSE is still set as expected

      SMX36_VSEParams_V2_t params;    ///< Statmux parameters for the VSE.
    };

    typedef sequence<SMX36_VSE_V4_t> SMX36_VSEList_V4_t;


    /**
     * @brief SMX36_VSE_GetL( in long VSEid) Reads the VSE parameters.
     * @note If the Id equal to -1 all VSE's the statmux community are listed.
     * @version release 9.0 (V2->9.10) (V3->10.20) (V4->11.00)
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     */
    SMX36_VSEList_t SMX36_VSE_GetL( in long VSEid)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);
    SMX36_VSEList_V2_t SMX36_VSE_V2_GetL( in long VSEid)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);
    SMX36_VSEList_V3_t SMX36_VSE_V3_GetL( in long VSEid)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);
    SMX36_VSEList_V4_t SMX36_VSE_V4_GetL( in long VSEid)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /**
     * @brief SMX36_VSE_SetL( in SMX36_VSEList_t VSE) Sets the VSE parameters.
     * @note If a VSE is to be added the Id for the VSE must be -1.
     * @version release 9.0 (V2->9.10) (V3->10.20) (V4->11.00)
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     */
    void SMX36_VSE_SetL( in SMX36_VSEList_t VSE)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);
    void SMX36_VSE_V2_SetL( in SMX36_VSEList_V2_t VSE)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);
    void SMX36_VSE_V3_SetL( in SMX36_VSEList_V3_t VSE)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);
    void SMX36_VSE_V4_SetL( in SMX36_VSEList_V4_t VSE)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /**
     * @brief SMX36_VSE_Create( in long EncoderId, in string VSEName ) creates an VSE and return the Id.
     * @note If The VSEName already have been used no VSE will be created and the return will be zero.
     * @version release 9.0
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded unable to create VSE or Internal error. 
     */
    long SMX36_VSE_Create(in long EncoderId, in string VSEName )
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /**
     * @brief SMX36_VSE_Delete( in SMX36_VSEIdList_t VSEIdlist ) Delete VSEs.
     * @note Only VSE with the status SMX36_VSEStatus_Disconnected will be deleted.
     * @version release 9.0
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     */
    typedef sequence<long> SMX36_VSEIdList_t;

    void SMX36_VSE_DeleteL( in SMX36_VSEIdList_t VSEIdlist )
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /********************************************************
    * Calculate(Predict) default rates
    ********************************************************/
    struct SMX36_VSE_CalculatedRates_t
    {
      long Id;                          ///< RO Unique ID of the VSE.
      unsigned long DefBitrate;         ///< RO Calculated Default Rate.
      boolean Enabled;                  ///< RO If the VSE is enabled or disabled in the Poollist.
    };
    typedef sequence<SMX36_VSE_CalculatedRates_t> SMX36_VSE_CalculatedRatesList_t;

    struct SMX_Pool_Calculate_t {
      long Id;                          ///< RO Pool Id.
      unsigned long Bandwidth;          ///< (bps) The bandwidth of the pool (bps). Must be greater than BandwidthOverhead.
      unsigned long BandwidthOverhead;  ///< (bps) Overhead/Free-space to the bandwidth used to prevent overshoot on a mux with a small input buffer. must be less that bandwidth 
    };

    /**
     * @brief SMX36_VSE_CalculateDefaultRates Calculate the VSE default rates using the in data.
     * @version release 9.10
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     */
    SMX36_VSE_CalculatedRatesList_t SMX36_VSE_CalculateDefaultRates(in SMX_Pool_Calculate_t Pool, in SMX36_VSEList_V2_t VSElist)
       raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /**
     * @brief SMX36_VSE_CalcDefaultRates_V2 Calculate the VSE default rates using the VSE data with support for code/format
     * @version release 10.20
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     */
    SMX36_VSE_CalculatedRatesList_t SMX36_VSE_CalcDefaultRates_V2(in SMX_Pool_Calculate_t Pool, in SMX36_VSEList_V3_t VSElist)
       raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /********************************************************
     * Swap Encoder in the D9036 Statmux.
     ********************************************************/

    /**
     * @brief SMX36_SwapEncoder(in string MainEncoderIPAddress, in string BackupEncoderIPAddress)
     *        Replaces all the main encoder VSE's with the backup encoder VSE's in the cases 
     *        where the VSE name's matches between the main and backup encoder. 
     * @note For version 9.0 If an entry in the backup list the entry
                             is deleted from the list before the VSE replacement is made.
             For version 9.10 If a swapped VSE matches an entry in the backup list 
                              i.e. both the main and backup name's in the backup entry, the backup
                              entry will be reversed before the swap is made.
     * @version release 9.10
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     */
    void SMX36_SwapEncoder(in string MainEncoderIPAddress, in string BackupEncoderIPAddress)
       raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

     /********************************************************
     * VSE backup list in the D9036 Statmux.
     ********************************************************/

    enum SMX36_VSEBackupState_e
    {
      SMX36_VSEBackupState_inactive,  ///< The Backup is not activated the SafeRate is set on the backup VSE.
      SMX36_VSEBackupState_active,    ///< The Backup is activated, backup VSE is active and the main VSE inactive.
      SMX36_VSEBackupState_reserved   ///< reserved for future use.
    };
    
    /** @version release 9.10 added suport for safeguard **/
    enum SMX36_VSEBackupState_V2_e
    {
      SMX36_VSEBackupState_inactive_V2, ///< The Backup is not activated the SafeRate is set on the backup VSE.
      SMX36_VSEBackupState_active_V2,   ///< The Backup is activated, backup VSE is active and the main VSE inactive.
      SMX36_VSEBackupState_inactive_Safeguard, ///< Same as inactive but if communication is lost to Main or Backup VSE the VSE will run saft rate.
  	  SMX36_VSEBackupState_active_Safeguard,   ///< Same as active but if communication is lost to Main or Backup VSE the VSE will run saft rate.
      SMX36_VSEBackupState_reserved_5,  ///< reserved for future use.
      SMX36_VSEBackupState_reserved_6,  ///< reserved for future use.
      SMX36_VSEBackupState_reserved_7,  ///< reserved for future use.
      SMX36_VSEBackupState_reserved_8,  ///< reserved for future use.
      SMX36_VSEBackupState_reserved_9,  ///< reserved for future use.
      SMX36_VSEBackupState_reserved_10  ///< reserved for future use.
    };

    struct SMX36_VSEBackup_t
    { 
      string MainEncoderIPAddress;         ///< Management IP Address of the Main encoder.   
      string MainVSEName;                  ///< VSE Name of the main VSE (max length = 20).
      string MainVideoStreamEncoderName;   ///< future Name of the video stream on which the statmuxing is running.
      string BackupEncoderIPAddress;       ///< Management IP Address of the Backup encoder. 
      string BackupVSEName;                ///< VSE Name of the Backup VSE (max length = 20). 
      string BackupVideoStreamEncoderName; ///< future Name of the video stream on which the statmuxing is running.                
      SMX36_VSEBackupState_e BackupState;  ///< State of the configured VSE backup.
    };

    /** @version release 9.10 added suport for safeguard **/
    struct SMX36_VSEBackup_V2_t
    { 
      string MainEncoderIPAddress;           ///< Management IP Address of the Main encoder.   
      string MainVSEName;                    ///< VSE Name of the main VSE (max length = 20).
      string MainVideoStreamEncoderName;     ///< future Name of the video stream on which the statmuxing is running.
      string BackupEncoderIPAddress;         ///< Management IP Address of the Backup encoder. 
      string BackupVSEName;                  ///< VSE Name of the Backup VSE (max length = 20). 
      string BackupVideoStreamEncoderName;   ///< future Name of the video stream on which the statmuxing is running.                
      SMX36_VSEBackupState_V2_e BackupState; ///< State of the configured VSE backup.
    };
        
    typedef sequence<SMX36_VSEBackup_t> SMX36_VSEBackupList_t;
    /** @version release 9.10 added suport for safeguard **/
    typedef sequence<SMX36_VSEBackup_V2_t> SMX36_VSEBackupList_V2_t;
 
    /**
     * @brief SMX36_VSEBackupList_GetL( ) Get the VSE Backup list.
     * @note entry's with backup state set to floating is removed and is therefore not in the list.
     * @version release 9.0
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     */
    SMX36_VSEBackupList_t SMX36_VSEBackupList_GetL()
       raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);
    /** @version release 9.10 added suport for safeguard **/
    SMX36_VSEBackupList_V2_t SMX36_VSEBackupList_V2_GetL()
       raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);
        
    /**
     * @brief SMX36_VSEBackupList_AddL( in SMX36_VSEBackupList_t VSEBackupList ) Add entry's to   
     *   the VSE backup list.
     * @note If the BackupState is active the main VSE is set inactive and the backup VSE is set   
     *   active, using all the parameters from the main VSE on the backup VSE. 
     *   If an entry already exists in the backup list the state of the existing entry is change 
     *   according to the state of the new entry and the new entry is ignored.
     *   If a new entry contains a VSE already used by another entry the entry is ignored.
     *   If the backup VSE in a new entry is allocated to a pool the entry is ignored.  
     * @version release 9.0
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     */
    void SMX36_VSEBackupList_AddL( in SMX36_VSEBackupList_t BackupList )
         raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);
    /** @version release 9.10 added suport for safeguard **/
    void SMX36_VSEBackupList_V2_AddL( in SMX36_VSEBackupList_V2_t BackupList )
         raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);
    
    /**
     * @brief SMX36_VSEBackupList_DeleteL( in SMX36_VSEBackupList_t BackupList ) Remove entry's from  
     * the backup list (based on Main Enc IP, Main VSE info).
     * @note If backup-state is active the backup is reversed so that the backup VSE is set inactive  
     * and the main VSE to active.
     *   Only the main VSE data needs to be specified.
     * @version release 9.0
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     */
    void SMX36_VSEBackupList_DeleteL( in SMX36_VSEBackupList_t BackupList ) 
         raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);
    /** @version release 9.10 added suport for safeguard **/
    void SMX36_VSEBackupList_V2_DeleteL( in SMX36_VSEBackupList_V2_t BackupList ) 
         raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);
        
    /**
     * @brief SMX36_VSEBackupList_FlushL( ) Deletes all entry's the entire VSE backup list.
     * @version release 9.0
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     * remove full list.
     */
    void SMX36_VSEBackupList_FlushL( ) 
         raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /**
     * @brief SMX36_VSEBackupList_SetL( in SMX36_VSEBackupList_t VSEBackupList ) Set the VSE backup 
     * state and backup VSE for a certain Main VSE identified by the MainEncoderIPAddress and MainVSEName. 
     * For example the BackupState.
     * @note  If the Main VSE is not already registered the entry is ignored.
     * @version release 9.0
     * @exception TimeOut A timeout occurred during IIOP processing.
     * @exception OpNotSucceeded Internal error. 
     */
    void SMX36_VSEBackupList_SetL( in SMX36_VSEBackupList_t BackupList )
       raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);
    /** @version release 9.10 added suport for safeguard **/
    void SMX36_VSEBackupList_V2_SetL( in SMX36_VSEBackupList_V2_t BackupList )
       raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /// @} end defgroup D9036 Statmux

#endif // DISABLE_SMX
#ifndef DISABLE_IPSEC
    // IPsec
    ////////////////////////////////
    
    /** @defgroup ipsec IPsec
     * Types and methods to configure IPsec on the management ports.
     * @{
     */

    struct IPSecHost
    {
      string PeerIPAddress; ///< The IP address of the IPsec capable host
      string PreSharedKey;  ///< The preshard key used for setting up IPsec
    };

    typedef sequence<IPSecHost> IPSecHostList;

    /** Adds a host for which DCM requires IPSec to be used in order to communicate 
     *  over the management network.
     *
     * @param[in] HostList List of hosts to add, where each host has a valid unicast
     *            ip address and a keylength not greater than 200.
     *
     * @exception OpNotSucceeded A host has already been added, the IP address is not
     *            valid or the key is too long.
     **/
    void IPSec_HostAddL(in IPSecHostList HostList)
      raises(TimeOut, OutOfRange, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Removes a host for which DCM requires IPSec to be used in order to communicate 
     *  over the management network.
     *
     * @param[in] HostList List of hosts to delete. Only the IP-address is used 
     *                 to identify the host.
     *
     * @exception OpNotSucceeded A host is not known.
     *
     * @note If the last host is deleted, the device will automatically allow non-IPSec 
     *       traffic to the device and it is not re-enabled when adding new hosts.
     **/
    void IPSec_HostDeleteL(in IPSecHostList HostList)
      raises(TimeOut, OutOfRange, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Changes the pre-shared key for a host
     *
     * @param[in] HostList List of hosts to change pre-shared key for.
     *
     * @exception OpNotSucceeded A host is not known or a pre-shared key is too long.
     **/
    void IPSec_HostChangeL(in IPSecHostList HostList)
      raises(TimeOut, OutOfRange, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Returns the list of hosts for which DCM requires IPSec to be used in order to
     *  communicate over the management network.
     *
     * @return HostList List of hosts. The PreSharedKey field of the entries will contain 
     *         a dummy string instead of the real key.
     **/
    void IPSec_HostGetL(out IPSecHostList HostList)
      raises(TimeOut, OutOfRange, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Enables or disables non-IPSec IP data for the given management interface.
     *
     * Non-IPSec traffic is enabled by default.
     * If IPSec hosts are configured and both interfaces allow non-IPSec traffic, 
     * then IPSec usage is optional. As soon as an interface disables non-IPSec traffic, 
     * the use of IPSec becomes mandatory.
     *
     * @param[in] PhysPort Physical port. Board must be 0 (mainboard), 
     *                     Port must be 0 (10/100) or 1 (GbE)
     * @param[in] enabled  True to allow non-IPSec traffic for the management interface, 
     *                     false otherwise
     *
     * @exception OpNotSucceeded PhysPort does not specify a valid mgmt interface or 
     *                           an attempt was made to disable non-IPSec traffic while 
     *                           no IPSec hosts were defined
     **/
    void IPSec_SetRequireIPSec(in IPS_Ref_t PhysPort, in boolean enabled)
      raises(TimeOut, OutOfRange, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /** Indicates whether non-IPSec IP data is allowed to go through the given 
     *  management port.
     *
     * @param[in] PhysPort Physical port. Board must be 0 (mainboard), 
     *                     Port must be 0 (10/100) or 1 (GbE)
     * @param[out] enabled True if non-IPSec traffic is allowed for the management port.
     *
     * @exception OpNotSucceeded PhysPort does not specify a valid mgmt port
     **/
    void IPSec_GetRequireIPSec(in IPS_Ref_t PhysPort, out boolean enabled)
      raises(TimeOut, OutOfRange, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /// @} end defgroup ipsec
#endif // DISABLE_IPSEC
#ifndef DISABLE_SECURITY

    // Product Security
    ////////////////////////////////
    
    /** @defgroup secpsb SecurityPSB
     * Types and methods related to compliance with PSB
     * @{
     */

    /*
     * IDL types and method related to SEC-OFF-PROC
     */

    /// IP services that are externally visible and that can
    ///  be configured.
    enum eExtIpServices {
      eIpServiceIIOP,
      eIpServiceSSH,
      eIpServiceFTP,
      eIpServiceSNMP,
      eIpServiceIPConfig,
      eIpServiceTelnet,
      eIpServiceSNMPSvcConf,
      eIpService_Reserved_9,
      eIpService_Reserved_8,
      eIpService_Reserved_7,
      eIpService_Reserved_6,
      eIpService_Reserved_5,
      eIpService_Reserved_4,
      eIpService_Reserved_3,
      eIpService_Reserved_2,
      eIpService_Reserved_1,
      eIpService_Reserved_0
    };

    struct ExtIpServiceCtrl {
      eExtIpServices Service;
      boolean bEnabled;
    };

    typedef sequence<ExtIpServiceCtrl> ExtIpServiceCtrlList;

    /** Enable/disable a number of externally visible IP services.
     * Only the services that are returned by GetExternalIpServicesL can
     * be configured.
     *
     * @param[in] Services List of the services that need to be reconfigured
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSupported when BoardNr != 0 (Main board).
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSucceeded In case of
     * - list contains duplicate service types
     * - service type out of range or reserved
     *
     * @note This call doesn't follow the until first error approach. If an error
     * is found in the input parameter, no settings are applied.
     *
     * @version Release 8.1
     */
    void SetExternalIpServicesL( in ExtIpServiceCtrlList Services)
      raises (TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    /** Retrieve a list of services that can be enabled/disabled on the mainboard
     * together with the current status of that service.
     *
     * @param[out] Services The list of services
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSupported when BoardNr != 0 (Main board).
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSucceeded Internal error
     *
     * @version Release 8.1
     */
    void GetExternalIpServicesL( out ExtIpServiceCtrlList Services)
      raises (TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /*
     * IDL types and methods related to SEC-DSP-PROC
     */

    ///Transport layer protocol type of a socket
    enum enPSBSocketType
    {
      ePsbSocketTypeTcp,
      ePsbSocketTypeUdp,
      ePsbSocketTypeTcp6,
      ePsbSocketTypeUdp6,
      ePsbSocketTypeReserved7,
      ePsbSocketTypeReserved6,
      ePsbSocketTypeReserved5,
      ePsbSocketTypeReserved4,
      ePsbSocketTypeReserved3,
      ePsbSocketTypeReserved2,
      ePsbSocketTypeReserved1,
      ePsbSocketTypeReserved0
    };

    /** Description of an active or listening port */
    struct IpServiceDisplayData {
      enPSBSocketType   SckType;     ///<Tcp, udp, tcp6, udp6, ...
      string            ItfName;     ///<Interface of listening port, or 'all'
      string            LocalIp;     ///<IP address of local itf or 0.0.0.0 (any)
      string            RemoteIp;    ///<Remote IP address or 0.0.0.0 (any)
      unsigned short    LocalPort;   ///<Port number of listening port
      unsigned short    RemotePort;  ///<0 or port number in case of established connection
      string            ProtoName;   ///<Name of application level protocol if meaningful one exists, e.g. ssh
      string            ProcessName; ///<Name of process that has opened the port
      string            Description; ///<Usage description and features that are related
      unsigned long     IpSvcProperty;/**< Bitmap:
                                       * - bit 0: blocked (firewall, configuration, )
                                       */
    };

    typedef sequence<IpServiceDisplayData> IpServiceDisplayDataList;

    /** Retrieves a list of active and listening TCP/IP ports, alike netstat
     *
     * @param[in] Board   Board number
     *
     * @param[out] Listeners Netstat-like list of ports
     *
     * @exception TimeOut        A timeout occurred during IIOP processing.
     * @exception OpNotSupported when BoardNr doesn't correspond to mainboard, GbE card or IP video GW card.
     * @exception OpNotAllowed   Not logged on.
     * @exception OpNotSucceeded In case 
     * - board out of range
     *
     * @version Release 8.1
     */
    void GetListeningIpServicesL( in unsigned short Board, out IpServiceDisplayDataList Listeners)
      raises (TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /// @} end defgroup secpsb
#endif // DISABLE_SECURITY
#ifndef DISABLE_SCR

    /** 
    * @defgroup scrambler SCRAMBLER
    * This module contains types, enums and methods related to the scrambler.
    * @{
    **/
      
    // ------------------------------------------------------------------------------------
    // Scrambler structures & enums
    // ------------------------------------------------------------------------------------
  
    // Hitachi Japan
    // ------------------------------------------------------------------------------------
    
    /// JCL initial value for Hitachi
    struct JclInitialValue_t      // 64 bit value
    {
      unsigned long  Part1;       
      unsigned long  Part2;       
    };

    /// JCL system ID for Hitachi
    struct JclSystemId_t          // 256 bit value
    {
      unsigned long  Part1;       
      unsigned long  Part2;       
      unsigned long  Part3;       
      unsigned long  Part4;       
      unsigned long  Part5;       
      unsigned long  Part6;       
      unsigned long  Part7;       
      unsigned long  Part8;       
    };


    // Simulcrypt interfaces
    // ------------------------------------------------------------------------------------

    typedef sequence<unsigned long> IdList;  ///< list of ID's (for several purposes)


    // ECMG
    // ------------------------------------------------------------------------------------

    /// ECMG type
    enum eEcmgType
    {
      EcmgStandard,               ///< (default value)
      M_Crypt,                    ///< creates streams even if no ECMs are requested 
                                  ///< overrules AC with fixed format: ON_ID, TS_ID, SID
      Nagra,                      ///< overrules AC with fixed format: ECM_ID
      Hitachi
    };

    /**
     * @brief ECMG type.
     *
     * @version release 8.9
     **/
    enum eEcmgType_V2
    {
      EcmgType_Standard,          ///< (default value)
      EcmgType_M_Crypt,           ///< creates streams even if no ECMs are requested 
                                  ///< overrules AC with fixed format: ON_ID, TS_ID, SID
      EcmgType_Nagra,             ///< overrules AC with fixed format: ECM_ID
      EcmgType_Hitachi,   
      EcmgType_PowerVu,           ///< PowerVu specific scrambling (external CWG...)
      EcmgType_Reserved5,         ///< PowerKEY specific scrambling (add hint bit)
      EcmgType_Reserved6,         ///< Reserved for future use
      EcmgType_Reserved7,         ///< Reserved for future use
      EcmgType_Reserved8          ///< Reserved for future use
    };

    /// ECM pid source
    enum eEcmPidSource
    {
      EcmId,                      ///< use EcmId as pid for ECM
      EcmPidSourceAuto            ///< automatic allocate pid for ECM (default value)
    };

    /// ECMG channel_id allocation
    enum eEcmgChannelIdMode
    {
      EcmgChannelIdManual,        ///< use manual configured channel_id
      EcmgChannelIdAuto           ///< automatic allocate channel_id (default value)
    };

    /// ECMG connection status
    enum eEcmgConnectionStatus
    {
      EcmgClosed,                 ///< backup channel in cold standby
      EcmgTryingToConnect,        ///< hot standby, trying socket connect
      EcmgEstablishingChannel,    ///< socket ok, trying channel connect
      EcmgChannelOpen             ///< channel ok
    };

    /// Type of ECMG descriptor rule
    enum eEcmgDescRuleType 
    {
      EcmgAddPrivateData,         ///< add private data to descriptor (default value)
      EcmgDoNotInsertDescriptor   ///< do not insert descriptor (in PSIG imported table)
    };

    /// Insertion level of ECMG descriptor in PMT
    enum eDescInsertionLevel 
    {
      FollowScg,                  ///< insert according SCG (default value)
                                  // (service-scrambling: insert under service, component-scrambling: insert under ES)
      InsertAtESLevel             ///< insert at ES level 
                                  // (service-scrambling: insert under all ES's)
    };


    /**
     * @brief Insertion level of ECMG descriptor in PMT.
     *
     * @version release 8.1
     **/
    enum eDescInsertionLevel_V2
    {
      FollowScg_V2,               ///< insert according SCG (default value)
                                  // (service-scrambling: insert under service, component-scrambling: insert under ES)
      InsertAtESLevel_V2,         ///< insert at ES level 
                                  // (service-scrambling: insert under all ES's)
      InsertAtServiceLevel_V2,    ///< insert at service level
                                  // (component-scrambling: insert under service)
      eDescInsertionLevel_V2_Reserved4,  ///< Reserved for future use
      eDescInsertionLevel_V2_Reserved5,  ///< Reserved for future use
      eDescInsertionLevel_V2_Reserved6   ///< Reserved for future use
    };
    
    typedef sequence<unsigned short> EcmIdList ; ///< list of EcmId's


    // EMMG
    // ------------------------------------------------------------------------------------

    /// Type of data for socket
    enum eDataSocket
    {
      TCP,                        ///< TCP protocol (default value)
      UDP                         ///< UDP protocol
    };

    /// EMM pid source
    enum eEmmPidSource
    {
      StreamId,                   ///< use StreamId as pid for EMM
      ChannelId,                  ///< use ChannelId as pid for EMM
      DataId,                     ///< use DataId as pid for EMM
      PacketId,                   ///< use PacketId as pid for EMM
                                  // only useful when streaming packets,
                                  // when streaming sections, the behaviour is the same as auto
      EmmPidSourceAuto            ///< automatic allocate pid for EMM (default value)
    };

    /// Enable/disable section grouping for EMM's
    enum eEmmSectionGrouping
    {
      NoGrouping,                 ///< disable section grouping for EMM's
      Grouping                    ///< enable section grouping for EMM's
    };

    ///@todo To be reworked?
    /// EMMG connection state
    enum eConnectionState
    {
      EmmWaitingForConnect,       ///< trying socket connect
      EmmWaitingForChannel,       ///< socket OK, trying channel connect
      EmmChannelOpen              ///< channel OK
    };

    /// Type of EMMG descriptor rule
    enum eEmmgDescRuleType 
    {
      EmmgAddPrivateData,         ///< add private data to descriptor (default value)
      EmmgDoNotInsertDescriptor   ///< do not insert descriptor (in PSIG imported table?)
    };

    typedef sequence<unsigned short> DataIdList; ///< list of DataId's


    // EIS
    // ------------------------------------------------------------------------------------

    /// EIS type
    enum eEisType
    {
      SaEis,                      ///< SA specific EIS (= ROSA SCTask) (default value)
      CaVendorEis                 ///< external CA vendor EIS
    };


    // PSIG
    // ------------------------------------------------------------------------------------
    
    //  PSIG type (defined earlier...)
    //enum ePsigType
    //{
    //  SaPsig,                         ///< SA specific PSIG (= ROSA SI Distributor) (default value)
    //  CaVendorPsig                    ///< external CA vendor PSIG
    //};


    // CWG
    // ------------------------------------------------------------------------------------

    /**
     * @brief CWG proxy type.
     *
     * @version release 9.0
     **/
    enum eCwgType
    {
      CwgType_PowerVu,            ///< PowerVu CWG
      CwgType_Reserved2,          //   Reserved for future use
      CwgType_Reserved3           //   Reserved for future use
    };

    /**
     * @brief CWG channel_id allocation.
     *
     * @version release 9.0
     **/
    enum eCwgChannelIdMode
    {
      CwgChannelIdManual,         ///< use manual configured channel_id
      CwgChannelIdAuto            ///< automatic allocate channel_id (default value)
    };

    /**
     * @brief CWG connection status.
     *
     * @version release 9.0
     **/
    enum eCwgConnectionStatus
    {
      CwgClosed,                  ///< backup channel in cold standby
      CwgTryingToConnect,         ///< hot standby, trying socket connect
      CwgEstablishingChannel,     ///< socket ok, trying channel connect
      CwgChannelOpen              ///< channel ok
    };

    
    // ------------------------------------------------------------------------------------
    // Scrambler IDLs
    // ------------------------------------------------------------------------------------
  
    // Client notifications
    // ------------------------------------------------------------------------------------

    /**
     * @brief Notifies the client whether it is a scrambler or not.
     *
     * @param[out]    bScrambler  scrambler or not
     *
     * @exception TimeOut         a timeout occurred during IIOP processing
     * @exception OpNotSucceeded  internal error only
     * @exception OpNotAllowed    not logged on
     * @exception OpNotSupported  when called on other board than the mainboard or
     *                            when call not yet supported on running software version
     *
     * @version release 2.0
     **/
    void IsScrambler(out boolean bScrambler)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    // Backup support
    // ------------------------------------------------------------------------------------

    /**
     * @brief Set the device (%DCM) as backup device or not.
     *
     * @param[in]     bIsBackup   device becomes backup or not (range [0, 1])
     *
     * @exception TimeOut         a timeout occurred during IIOP processing
     * @exception OpNotSucceeded  internal error only
     * @exception OpNotAllowed    not logged on
     * @exception OpNotSupported  when called on other board than the mainboard or
     *                            when call not yet supported on running software version
     * @exception OutOfRange      when parameters invalid
     *
     * @version release 2.5
     * @deprecated  This call should not be used anymore since release 4.0.
     *              Instead, SetDeviceActiveMode should be used.
     **/
    void SetDeviceAsBackup(in boolean bIsBackup)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OutOfRange);

  
    // SCS Settings
    // ------------------------------------------------------------------------------------

    /**
     * @brief Set global SCS settings.
     *
     * @param[in]     ScrambleOnlyAV    scramble only audio and video 
     *                                  (range [0, 1])
     * @param[in]     CheckElementsAtProvisionTime  check SCG at provision time 
     *                                              (range [0, 1])
     * @param[in]     ScgAcceptDelay    minimum delay (in sec) to accept SCG after reboot
     *                                  (range [0, 120])
     *
     * @exception TimeOut         a timeout occurred during IIOP processing
     * @exception OpNotSucceeded  internal error only
     * @exception OpNotAllowed    not logged on
     * @exception OpNotSupported  when called on other board than the mainboard or
     *                            when call not yet supported on running software version
     * @exception OutOfRange      when parameters invalid
     *
     * @version release 2.0
     **/
    void SetScsSettings(in boolean ScrambleOnlyAV, in boolean CheckElementsAtProvisionTime, 
        in unsigned long ScgAcceptDelay /* seconds */)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Get global SCS settings.
     *
     * @param[out]    ScrambleOnlyAV    scramble only audio and video
     * @param[out]    CheckElementsAtProvisionTime  check SCG at provision time
     * @param[out]    ScgAcceptDelay    minimum delay to accept SCG after reboot
     *
     * @exception TimeOut         a timeout occurred during IIOP processing
     * @exception OpNotSucceeded  internal error only
     * @exception OpNotAllowed    not logged on
     * @exception OpNotSupported  when called on other board than the mainboard or
     *                            when call not yet supported on running software version
     *
     * @version release 2.0
     **/
    void GetScsSettings(out boolean ScrambleOnlyAV, out boolean CheckElementsAtProvisionTime, 
        out unsigned long ScgAcceptDelay /* seconds */)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set strong pairing enforcement bit clear flag (NDS specific).
     *
     * @param[in]     bClearStrongPairingEnforcementBit  indicate whether to clear bit in CW or not
     *                                                   (range [0, 1])
     *
     * @exception TimeOut         a timeout occurred during IIOP processing
     * @exception OpNotSucceeded  internal error only
     * @exception OpNotAllowed    not logged on
     * @exception OpNotSupported  when called on other board than the mainboard or
     *                            when call not yet supported on running software version
     * @exception OutOfRange      when parameters invalid
     *
     * @version release 5.5
     **/
    void SetClearStrongPairingEnforceBit(in boolean bClearStrongPairingEnforcementBit)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OutOfRange);
  
    /**
     * @brief Get strong pairing enforcement bit clear flag (NDS specific).
     *
     * @param[out]    bClearStrongPairingEnforcementBit  indicate whether to clear bit in CW or not
     *
     * @exception TimeOut         a timeout occurred during IIOP processing
     * @exception OpNotSucceeded  internal error
     * @exception OpNotAllowed    not logged on
     * @exception OpNotSupported  when called on other board than the mainboard or
     *                            when call not yet supported on running software version
     *
     * @version release 5.5
     **/
    void GetClearStrongPairingEnforceBit(out boolean bClearStrongPairingEnforcementBit)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
  

    // Hitachi Japan
    // ------------------------------------------------------------------------------------

    /**
     * @brief Set JCL configuration.
     *
     * @param[in]     InitialValue  JCL initial value
     * @param[in]     SystemId      JCL system ID
     *
     * @exception TimeOut         a timeout occurred during IIOP processing
     * @exception OpNotSucceeded  internal error
     * @exception OpNotAllowed    not logged on
     * @exception OpNotSupported  when called on other board than the mainboard or
     *                            when call not yet supported on running software version
     *
     * @version release 2.0
     *
     * @note  JCL scrambling not yet supported
     **/
    void SetJclConfig(in JclInitialValue_t InitialValue, in JclSystemId_t SystemId)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get JCL configuration.
     *
     * @param[out]    InitialValue  JCL initial value
     * @param[out]    SystemId      JCL system ID
     *
     * @exception TimeOut         a timeout occurred during IIOP processing
     * @exception OpNotSucceeded  internal error only
     * @exception OpNotAllowed    not logged on
     * @exception OpNotSupported  when called on other board than the mainboard or
     *                            when call not yet supported on running software version
     *
     * @version release 2.0
     *
     * @note  JCL scrambling not yet supported
     **/
    void GetJclConfig(out JclInitialValue_t InitialValue, out JclSystemId_t SystemId)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    // Simulcrypt interfaces
    // ------------------------------------------------------------------------------------

    /**
     * @brief Get list of configured proxies.
     *
     * @param[out]    EcmgIds       list of ECMG's (proxy_id)
     * @param[out]    EmmgIds       list of EMMG's (proxy_id)
     * @param[out]    EisIds        list of EIS's (proxy_id)
     * @param[out]    PsigIds       list of PSIG's (proxy_id)
     * @param[out]    MCryptEisIds  list of MCrypt EIS's (proxy_id), obsolete
     * @param[out]    MCryptPsigIds list of MCrypt PSIG's (proxy_id), obsolete
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 2.0
     **/
    void GetInterfaceList(out IdList EcmgIds, out IdList EmmgIds, out IdList EisIds, 
        out IdList PsigIds, out IdList MCryptEisIds, out IdList MCryptPsigIds)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get list of configured proxies.
     *
     * @param[out]    EcmgIds       list of ECMG's (proxy_id)
     * @param[out]    EmmgIds       list of EMMG's (proxy_id)
     * @param[out]    EisIds        list of EIS's (proxy_id)
     * @param[out]    PsigIds       list of PSIG's (proxy_id)
     * @param[out]    CwgIds        list of CWG's (proxy_id)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 8.9
     **/
    void GetInterfaceList_V2(out IdList EcmgIds, out IdList EmmgIds, out IdList EisIds, 
        out IdList PsigIds, out IdList CwgIds)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    // ECMG
    // ------------------------------------------------------------------------------------

    /**
     * @brief Create an ECMG proxy.
     *
     * @param[out]    EcmgId  proxy_id of newly created ECMG proxy
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  when out of proxy_id's
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 2.0
     **/
    void CreateEcmg(out unsigned long EcmgId)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Delete an ECMG proxy.
     *
     * @param[in]     EcmgId  proxy_id (range [0, 40[) of ECMG proxy to delete
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 2.0
     **/
    void DeleteEcmg(in unsigned long EcmgId) 
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Set ECMG proxy configuration settings.
     *
     * @param[in]     EcmgId            proxy_id (range [0, 40[) of ECMG proxy
     * @param[in]     Name              name of ECMG proxy (length max 20 characters)
     * @param[in]     EcmgType          type of ECMG proxy
     * @param[in]     CasId             CA_system_id of ECMG
     * @param[in]     SubCasId          CA_subsystem_id of ECMG
     * @param[in]     EcmPidSource      ECM pid source
     * @param[in]     EcmPidLowerLimit  lower limit for ECM pid selection (for auto mode)
                                        (range [0x20, 0x1fff[)
     * @param[in]     EcmPidUpperLimit  upper limit for ECM pid selection (for auto mode)
                                        (range [0x20, 0x1fff[)
     * @param[in]     EcmgChannelIdMode ECMG channel_id selection mode
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId or parameter
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    called on other board than the mainboard or
     *                              not yet supported on running software version
     * @exception OutOfRange        when parameters invalid
     *
     * @version release 2.0
     * @deprecated This call should not be used anymore since release 8.9 (replaced by call SetEcmgConfig_V2)
     **/
    void SetEcmgConfig(in unsigned long EcmgId, in string Name, in eEcmgType EcmgType, 
        in unsigned short CasId, in unsigned short SubCasId, in eEcmPidSource EcmPidSource, 
        in unsigned short EcmPidLowerLimit, in unsigned short EcmPidUpperLimit, 
        in eEcmgChannelIdMode EcmgChannelIdMode)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Get ECMG proxy configuration settings.
     *
     * @param[in]     EcmgId            proxy_id (range [0, 40[) of ECMG proxy
     * @param[out]    Name              name of ECMG proxy
     * @param[out]    EcmgType          type of ECMG proxy
     * @param[out]    CasId             CA_system_id of ECMG
     * @param[out]    SubCasId          CA_subsystem_id of ECMG
     * @param[out]    EcmPidSource      ECM pid source
     * @param[out]    EcmPidLowerLimit  lower limit for ECM pid selection (for auto mode)
     * @param[out]    EcmPidUpperLimit  upper limit for ECM pid selection (for auto mode)
     * @param[out]    EcmgChannelIdMode ECMG channel_id selection mode
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error
     * @exception InvalidSelection  invalid EcmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @version release 2.0
     * @deprecated This call should not be used anymore since release 8.9 (replaced by call GetEcmgConfig_V2)
     **/
    void GetEcmgConfig(in unsigned long EcmgId, out string Name, out eEcmgType EcmgType, 
        out unsigned short CasId, out unsigned short SubCasId, out eEcmPidSource EcmPidSource, 
        out unsigned short EcmPidLowerLimit, out unsigned short EcmPidUpperLimit, 
        out eEcmgChannelIdMode EcmgChannelIdMode)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set ECMG proxy configuration settings.
     *
     * @param[in]     EcmgId            proxy_id (range [0, 40[) of ECMG proxy
     * @param[in]     Name              name of ECMG proxy (length max 20 characters)
     * @param[in]     EcmgType          type of ECMG proxy
     * @param[in]     CasId             CA_system_id of ECMG
     * @param[in]     SubCasId          CA_subsystem_id of ECMG
     * @param[in]     EcmPidSource      ECM pid source
     * @param[in]     EcmPidLowerLimit  lower limit for ECM pid selection (for auto mode)
                                        (range [0x20, 0x1fff[)
     * @param[in]     EcmPidUpperLimit  upper limit for ECM pid selection (for auto mode)
                                        (range [0x20, 0x1fff[)
     * @param[in]     EcmgChannelIdMode ECMG channel_id selection mode
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId or parameter
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    called on other board than the mainboard or
     *                              not yet supported on running software version
     * @exception OutOfRange        when parameters invalid
     *
     * @version release 8.9 - PowerVu type behaves as Standard ECMG
     * @version release 9.0
     **/
    void SetEcmgConfig_V2(in unsigned long EcmgId, in string Name, in eEcmgType_V2 EcmgType, 
        in unsigned short CasId, in unsigned short SubCasId, in eEcmPidSource EcmPidSource, 
        in unsigned short EcmPidLowerLimit, in unsigned short EcmPidUpperLimit, 
        in eEcmgChannelIdMode EcmgChannelIdMode)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Get ECMG proxy configuration settings.
     *
     * @param[in]     EcmgId            proxy_id (range [0, 40[) of ECMG proxy
     * @param[out]    Name              name of ECMG proxy
     * @param[out]    EcmgType          type of ECMG proxy
     * @param[out]    CasId             CA_system_id of ECMG
     * @param[out]    SubCasId          CA_subsystem_id of ECMG
     * @param[out]    EcmPidSource      ECM pid source
     * @param[out]    EcmPidLowerLimit  lower limit for ECM pid selection (for auto mode)
     * @param[out]    EcmPidUpperLimit  upper limit for ECM pid selection (for auto mode)
     * @param[out]    EcmgChannelIdMode ECMG channel_id selection mode
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error
     * @exception InvalidSelection  invalid EcmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @version release 8.9 - PowerVu type behaves as Standard ECMG
     * @version release 9.0
     **/
    void GetEcmgConfig_V2(in unsigned long EcmgId, out string Name, out eEcmgType_V2 EcmgType, 
        out unsigned short CasId, out unsigned short SubCasId, out eEcmPidSource EcmPidSource, 
        out unsigned short EcmPidLowerLimit, out unsigned short EcmPidUpperLimit, 
        out eEcmgChannelIdMode EcmgChannelIdMode)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set ECMG backup settings (obsolete!).
     *
     * @param[in]     EcmgId            proxy_id (range [0, 40[) of ECMG proxy
     * @param[in]     BackupRevertive   ??? (range [0,1]
     * @param[in]     RevertTime        ??? (in sec) (range [0, 60])
     * @param[in]     HotStandby        ??? (range [0, 1]
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     * @exception OutOfRange        when parameters invalid
     *
     * @version release 2.0
     * @deprecated  This call should not be used on DCM.
     **/
    void SetEcmgBackup(in unsigned long EcmgId, in boolean BackupRevertive, in long RevertTime, 
        in boolean HotStandby)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Get ECMG backup settings (obsolete!).
     *
     * @param[in]     EcmgId            proxy_id (range [0, 40[) of ECMG proxy
     * @param[out]    BackupRevertive   ???
     * @param[out]    RevertTime        ??? (in sec)
     * @param[out]    HotStandby        ???
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error
     * @exception InvalidSelection  invalid EcmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @version release 2.0
     * @deprecated  This call should not be used on DCM.
     **/
    void GetEcmgBackup(in unsigned long EcmgId, out boolean BackupRevertive, out long RevertTime, 
        out boolean HotStandby)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief ???
     *
     * @param[in]     EcmgId    proxy_id (range [0, 40[) of ECMG proxy
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @note Not supported!!!
     **/
    void RevertNow(in unsigned long EcmgId)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get status of ECMG proxy.
     *
     * @param[in]     EcmgId                proxy_id (range [0, 40[) of ECMG proxy
     * @param[out]    NoOfRequestedStreams  total number of requested streams on proxy (all channels)
     * @param[out]    NoOfOpenStreams       total number of open streams on proxy (all channels)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @version release 2.0
     **/
    void GetEcmgStatus(in unsigned long EcmgId, out unsigned long NoOfRequestedStreams, 
        out unsigned long NoOfOpenStreams)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get list of available connections (channels) for an ECMG proxy.
     *
     * @param[in]     EcmgId    proxy_id (range [0, 40[) of ECMG proxy
     * @param[out]    ConnIds   list of configured connections (conn_id)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @version release 2.0
     * @deprecated This call should not be used anymore since release 8.9 (replaced by call GetEcmgConnList)
     **/
    void GetConnList(in unsigned long EcmgId, out IdList ConnIds)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get list of available connections (channels) for an ECMG proxy.
     *
     * @param[in]     EcmgId    proxy_id (range [0, 40[) of ECMG proxy
     * @param[out]    ConnIds   list of configured connections (conn_id)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @version release 8.9
     **/
    void GetEcmgConnList(in unsigned long EcmgId, out IdList ConnIds)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Create a new connection (channel) for an ECMG proxy.
     *
     * @param[in]     EcmgId    proxy_id (range [0, 40[) of ECMG proxy
     * @param[out]    ConnId    conn_id of newly created connection (channel)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @version release 2.0
     **/
    void CreateEcmgConn(in unsigned long EcmgId, out unsigned long ConnId)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Delete a connection (channel) for an ECMG proxy.
     *
     * @param[in]     EcmgId    proxy_id (range [0, 40[) of ECMG proxy
     * @param[in]     ConnId    conn_id of connection (channel) to delete
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId, ConnId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @version release 2.0
     **/
    void DeleteEcmgConn(in unsigned long EcmgId, in unsigned long ConnId)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set connection (channel) configuration settings.
     *
     * @param[in]     EcmgId      proxy_id (range [0, 40[) of ECMG proxy
     * @param[in]     ConnId      conn_id of connection (channel)
     * @param[in]     IpAddress   IP address of ECMG to connect with (range ]0, 0xffffffff])
     * @param[in]     Port        port on ECMG to establisch connection on (range [100, 0xffff])
     * @param[in]     ChannelId   channel_id to be used (for manual mode)
     * @param[in]     Priority    priority of connection (for backup and load balancing)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId, ConnId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     * @exception OutOfRange        when parameters invalid
     *
     * @version release 2.0
     * @deprecated This call should not be used anymore since release 10.10 (replaced by call SetEcmgConnConfig_V2)
     **/
    void SetEcmgConnConfig(in unsigned long EcmgId, in unsigned long ConnId, 
        in unsigned long IpAddress, in unsigned short Port, in unsigned short ChannelId,  
        in long Priority)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Get connection (channel) configuration settings.
     *
     * @param[in]     EcmgId      proxy_id (range [0, 40[) of ECMG proxy
     * @param[in]     ConnId      conn_id of connection (channel)
     * @param[out]    IpAddress   IP address of ECMG to connect with
     * @param[out]    Port        port on ECMG to establisch connection on
     * @param[out]    ChannelId   channel_id to be used (for manual mode)
     * @param[out]    Priority    priority of connection (for backup and load balancing)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId, ConnId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     * @exception OutOfRange        when parameters invalid (e.g. IPv6 address configured)
     *
     * @version release 2.0
     * @deprecated This call should not be used anymore since release 10.10 (replaced by call GetEcmgConnConfig_V2)
     **/
    void GetEcmgConnConfig(in unsigned long EcmgId, in unsigned long ConnId, 
        out unsigned long IpAddress, out unsigned short Port, out unsigned short ChannelId, 
        out long Priority)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Set connection (channel) configuration settings.
     *
     * @param[in]     EcmgId      proxy_id (range [0, 40[) of ECMG proxy
     * @param[in]     ConnId      conn_id of connection (channel)
     * @param[in]     IPAddress   IP address of ECMG to connect with
     * @param[in]     Port        port on ECMG to establisch connection on (range [100, 0xffff])
     * @param[in]     ChannelId   channel_id to be used (for manual mode)
     * @param[in]     Priority    priority of connection (for backup and load balancing)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId, ConnId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     * @exception OutOfRange        when parameters invalid
     *
     * @version release 10.10
     **/
    void SetEcmgConnConfig_V2(in unsigned long EcmgId, in unsigned long ConnId, 
        in string IPAddress, in unsigned short Port, in unsigned short ChannelId,  
        in long Priority)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Get connection (channel) configuration settings.
     *
     * @param[in]     EcmgId      proxy_id (range [0, 40[) of ECMG proxy
     * @param[in]     ConnId      conn_id of connection (channel)
     * @param[out]    IPAddress   IP address of ECMG to connect with
     * @param[out]    Port        port on ECMG to establisch connection on
     * @param[out]    ChannelId   channel_id to be used (for manual mode)
     * @param[out]    Priority    priority of connection (for backup and load balancing)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId, ConnId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @version release 10.10
     **/
    void GetEcmgConnConfig_V2(in unsigned long EcmgId, in unsigned long ConnId, 
        out string IPAddress, out unsigned short Port, out unsigned short ChannelId, 
        out long Priority)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get status of connection (channel) in ECMG proxy.
     *
     * @param[in]     EcmgId                proxy_id (range [0, 40[) of ECMG proxy
     * @param[in]     ConnId                conn_id of connection (channel)
     * @param[out]    EcmgConnectionStatus  status of connection
     * @param[out]    UsedChannelId         channel_id used for connection
     * @param[out]    NoOfOpenStreams       number of open streams on connection (channel)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId, ConnId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @version release 2.0
     **/
    void GetEcmgConnStatus(in unsigned long EcmgId, in unsigned long ConnId, 
        out eEcmgConnectionStatus EcmgConnectionStatus, out unsigned short UsedChannelId, 
        out unsigned short NoOfOpenStreams)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set ECMG proxy advanced settings (part 1).
     *
     * @param[in]     EcmgId                        proxy_id (range [0, 40[) of ECMG proxy
     * @param[in]     OverruleMaxCompTime           flag to overrule max_comp_time 
     *                                              (range [0, 1])
     * @param[in]     MaxCompTime                   overruled value for max_comp_time (in ms)
     *                                              (range [0, 60000])
     * @param[in]     OverruleMinimumCPDuration     flag to overrule min_CP_duration
     *                                              (range [0, 1])
     * @param[in]     MinimumCPDuration             overruled value for min_CP_duration (in ms)
     *                                              (range [1000, 3600000])
     * @param[in]     OverruleTransitionStartDelay  flag to overrule transition_delay_start
     *                                              (range [0, 1])
     * @param[in]     TransitionStartDelay          overruled value for transition_delay_start (in ms)
     *                                              (range [-30000, 0])
     * @param[in]     OverruleTransitionStopDelay   flag to overrule transition_delay_stop
     *                                              (range [0, 1])
     * @param[in]     TransitionStopDelay           overruled value for taransition_delay_stop (in ms)
     *                                              (range [0, 30000])
     * @param[in]     OverruleStartDelay            flag to overrule delay_start
     *                                              (range [0, 1])
     * @param[in]     StartDelay                    overruled value for delay_start (in ms)
     *                                              (range [-30000, 30000])
     * @param[in]     OverruleStopDelay             flag to overrule dalay_stop
     *                                              (range [0, 1])
     * @param[in]     StopDelay                     overruled value for delay_stop (in ms)
     *                                              (range [-30000, 30000])
     * @param[in]     OverruleAcStartDelay          flag to overrule AC_delay_start
     *                                              (range [0, 1])
     * @param[in]     AcStartDelay                  overruled value for AC_delay_start (in ms)
     *                                              (range [-30000, 30000])
     * @param[in]     OverruleAcStopDelay           flag to overrule AC_delay_stop
     *                                              (range [0, 1])
     * @param[in]     AcStopDelay                   overruled value for AC_delay_stop (in ms)
     *                                              (range [-30000, 30000])
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     * @exception OutOfRange        when parameters invalid
     *
     * @version release 2.0
     **/
    void SetEcmgOverrule(in unsigned long EcmgId, 
        in boolean OverruleMaxCompTime,          in short MaxCompTime,
        in boolean OverruleMinimumCPDuration,    in unsigned long MinimumCPDuration,
        in boolean OverruleTransitionStartDelay, in short TransitionStartDelay,
        in boolean OverruleTransitionStopDelay,  in short TransitionStopDelay,
        in boolean OverruleStartDelay,           in short StartDelay,
        in boolean OverruleStopDelay,            in short StopDelay,
        in boolean OverruleAcStartDelay,         in short AcStartDelay,
        in boolean OverruleAcStopDelay,          in short AcStopDelay)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Get ECMG proxy advanced settings (part 1).
     *
     * @param[in]     EcmgId                        proxy_id (range [0, 40[) of ECMG proxy
     * @param[out]    OverruleMaxCompTime           flag to overrule max_comp_time
     * @param[out]    MaxCompTime                   overruled value for max_comp_time (in ms)
     * @param[out]    OverruleMinimumCPDuration     flag to overrule min_CP_duration
     * @param[out]    MinimumCPDuration             overruled value for min_CP_duration (in ms)
     * @param[out]    OverruleTransitionStartDelay  flag to overrule transition_delay_start
     * @param[out]    TransitionStartDelay          overruled value for transition_delay_start (in ms)
     * @param[out]    OverruleTransitionStopDelay   flag to overrule transition_delay_stop
     * @param[out]    TransitionStopDelay           overruled value for taransition_delay_stop (in ms)
     * @param[out]    OverruleStartDelay            flag to overrule delay_start
     * @param[out]    StartDelay                    overruled value for delay_start (in ms)
     * @param[out]    OverruleStopDelay             flag to overrule dalay_stop
     * @param[out]    StopDelay                     overruled value for delay_stop (in ms)
     * @param[out]    OverruleAcStartDelay          flag to overrule AC_delay_start
     * @param[out]    AcStartDelay                  overruled value for AC_delay_start (in ms)
     * @param[out]    OverruleAcStopDelay           flag to overrule AC_delay_stop
     * @param[out]    AcStopDelay                   overruled value for AC_delay_stop (in ms)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @version release 2.0
     **/
    void GetEcmgOverrule(in unsigned long EcmgId, 
        out boolean OverruleMaxCompTime,           out short MaxCompTime,
        out boolean OverruleMinimumCPDuration,     out unsigned long MinimumCPDuration,
        out boolean OverruleTransitionStartDelay,  out short TransitionStartDelay,
        out boolean OverruleTransitionStopDelay,   out short TransitionStopDelay,
        out boolean OverruleStartDelay,            out short StartDelay,
        out boolean OverruleStopDelay,             out short StopDelay,
        out boolean OverruleAcStartDelay,          out short AcStartDelay,
        out boolean OverruleAcStopDelay,           out short AcStopDelay)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set ECMG proxy advanced settings (part 2).
     *
     * @param[in]     EcmgId                proxy_id (range [0, 40[) of ECMG proxy
     * @param[in]     OverruleMaxStreams    flag to overrule max_streams
     *                                      (range [0, 1])
     * @param[in]     MaxStreams            overruled value for max_streams
     *                                      (range [0, 80])
     * @param[in]     OverruleEcmRepPeriod  flag to overrule ECM_rep_period
     *                                      (range [0, 1])
     * @param[in]     EcmRepPeriod          overruled value for ECM_rep_period (in ms)
     *                                      (range [0, 30000])
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     * @exception OutOfRange        when parameters invalid
     *
     * @version release 2.0
     **/
    void SetEcmgOverruleExt(in unsigned long EcmgId,
        /*in boolean OverruleMaxCompTime,           in short MaxCompTime,
        in boolean OverruleMinimumCPDuration,     in unsigned long MinimumCPDuration,
        in boolean OverruleTransitionStartDelay,  in short TransitionStartDelay,
        in boolean OverruleTransitionStopDelay,   in short TransitionStopDelay,
        in boolean OverruleStartDelay,            in short StartDelay,
        in boolean OverruleStopDelay,             in short StopDelay,
        in boolean OverruleAcStartDelay,          in short AcStartDelay,
        in boolean OverruleAcStopDelay,           in short AcStopDelay,*/
        in boolean OverruleMaxStreams,            in unsigned short MaxStreams,
        in boolean OverruleEcmRepPeriod,          in unsigned short EcmRepPeriod)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Get ECMG proxy advanced settings (part 2).
     *
     * @param[in]     EcmgId                proxy_id (range [0, 40[) of ECMG proxy
     * @param[out]    OverruleMaxStreams    flag to overrule max_streams
     * @param[out]    MaxStreams            overruled value for max_streams
     * @param[out]    OverruleEcmRepPeriod  flag to overrule ECM_rep_period
     * @param[out]    EcmRepPeriod          overruled value for ECM_rep_period (in ms)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @version release 2.0
     **/
    void GetEcmgOverruleExt(in unsigned long EcmgId, 
        /*out boolean OverruleMaxCompTime,          out short MaxCompTime,
        out boolean OverruleMinimumCPDuration,    out unsigned long MinimumCPDuration,
        out boolean OverruleTransitionStartDelay, out short TransitionStartDelay,
        out boolean OverruleTransitionStopDelay,  out short TransitionStopDelay,
        out boolean OverruleStartDelay,           out short StartDelay,
        out boolean OverruleStopDelay,            out short StopDelay,
        out boolean OverruleAcStartDelay,         out short AcStartDelay,
        out boolean OverruleAcStopDelay,          out short AcStopDelay,*/
        out boolean OverruleMaxStreams,           out unsigned short MaxStreams,
        out boolean OverruleEcmRepPeriod,         out unsigned short EcmRepPeriod)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get list of available descriptor rules for ECMG proxy.
     *
     * @param[in]     EcmgId        proxy_id (range [0, 40[) of ECMG proxy
     * @param[out]    DescRuleIds   list of configured descriptor rules (desc_rule_id)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @version release 2.0
     **/
    void GetEcmgDescList(in unsigned long EcmgId, out IdList DescRuleIds)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Create a new descriptor rule for an ECMG proxy.
     *
     * @param[in]     EcmgId      proxy_id (range [0, 40[) of ECMG proxy
     * @param[out]    DescRuleId  desc_rule_id of newly created descriptor rule
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @version release 2.0
     **/
    void CreateEcmgDescriptor(in unsigned long EcmgId, out unsigned long DescRuleId)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Delete a descriptor rule for an ECMG proxy.
     *
     * @param[in]     EcmgId      proxy_id (range [0, 40[) of ECMG proxy
     * @param[in]     DescRuleId  desc_rule_id of descriptor rule to delete
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId, DescRuleId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @version release 2.0
     **/
    void DeleteEcmgDescriptor(in unsigned long EcmgId, in unsigned long DescRuleId)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set descriptor rule (on ECMG proxy) configuration settings.
     * 
     * @param[in]     EcmgId          proxy_id (range [0, 40[) of ECMG proxy
     * @param[in]     DescRuleId      desc_rule_id of descriptor rule
     * @param[in]     DescRuleName    name of descriptor rule (length max 30 characters)
     * @param[in]     Type            type of descriptor rule ('add private date' or 'do not insert')
     * @param[in]     InsertionLevel  insertion level of descriptor
     * @param[in]     DescriptorData  extra (private) data to append to descriptor
     *                                (length of data max 100 bytes)
     * @param[in]     EcmIds          list of EcmId's where descriptor rule applies to
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId, DescRuleId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     * @exception OutOfRange        when parameters invalid
     *
     * @remark  descriptor string format: hex byte array
     *          possible future extentions:
     *            - EcmPid: inserts 13 bit ECM pid (preceeded by hex nibble E of which one bit is overwritten)
     *            - EcmId:  inserts 16 bits EcmId
     *            - CasId:  inserts 16 bits CasId
     *
     * @version release 2.0
     * @deprecated This call should not be used anymore since release 8.1 (replaced by call SetEcmgDescriptor_V2)
     **/
    void SetEcmgDescriptor(in unsigned long EcmgId, in unsigned long DescRuleId, 
        in string DescRuleName, in eEcmgDescRuleType Type, in eDescInsertionLevel InsertionLevel, 
        in string DescriptorData, in EcmIdList EcmIds)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Get descriptor rule (on ECMG proxy) configuration settings.
     * 
     * @param[in]     EcmgId          proxy_id (range [0, 40[) of ECMG proxy
     * @param[in]     DescRuleId      desc_rule_id of descriptor rule
     * @param[out]    DescRuleName    name of descriptor rule
     * @param[out]    Type            type of descriptor rule ('add private date' or 'do not insert')
     * @param[out]    InsertionLevel  insertion level of descriptor
     * @param[out]    DescriptorData  extra (private) data to append to descriptor
     * @param[out]    EcmIds          list of EcmId's where descriptor rule applies to
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId, DescRuleId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @remark  descriptor string format: hex byte array
     *          possible future extentions:
     *            - EcmPid: inserts 13 bit ECM pid (preceeded by hex nibble E of which one bit is overwritten)
     *            - EcmId:  inserts 16 bits EcmId
     *            - CasId:  inserts 16 bits CasId
     *
     * @version release 2.0
     * @deprecated This call should not be used anymore since release 8.1 (replaced by call GetEcmgDescriptor_V2)
     **/
    void GetEcmgDescriptor(in unsigned long EcmgId, in unsigned long DescRuleId, 
        out string DescRuleName, out eEcmgDescRuleType Type, out eDescInsertionLevel InsertionLevel, 
        out string DescriptorData, out EcmIdList EcmIds)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set descriptor rule (on ECMG proxy) configuration settings.
     * 
     * @param[in]     EcmgId          proxy_id (range [0, 40[) of ECMG proxy
     * @param[in]     DescRuleId      desc_rule_id of descriptor rule
     * @param[in]     DescRuleName    name of descriptor rule (length max 30 characters)
     * @param[in]     Type            type of descriptor rule ('add private date' or 'do not insert')
     * @param[in]     InsertionLevel  insertion level of descriptor
     * @param[in]     DescriptorData  extra (private) data to append to descriptor
     *                                (length of data max 100 bytes)
     * @param[in]     EcmIds          list of EcmId's where descriptor rule applies to
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId, DescRuleId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     * @exception OutOfRange        when parameters invalid
     *
     * @remark  descriptor string format: hex byte array
     *          possible future extentions:
     *            - EcmPid: inserts 13 bit ECM pid (preceeded by hex nibble E of which one bit is overwritten)
     *            - EcmId:  inserts 16 bits EcmId
     *            - CasId:  inserts 16 bits CasId
     *
     * @version release 8.1
     **/
    void SetEcmgDescriptor_V2(in unsigned long EcmgId, in unsigned long DescRuleId, 
        in string DescRuleName, in eEcmgDescRuleType Type, in eDescInsertionLevel_V2 InsertionLevel, 
        in string DescriptorData, in EcmIdList EcmIds)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Get descriptor rule (on ECMG proxy) configuration settings.
     * 
     * @param[in]     EcmgId          proxy_id (range [0, 40[) of ECMG proxy
     * @param[in]     DescRuleId      desc_rule_id of descriptor rule
     * @param[out]    DescRuleName    name of descriptor rule
     * @param[out]    Type            type of descriptor rule ('add private date' or 'do not insert')
     * @param[out]    InsertionLevel  insertion level of descriptor
     * @param[out]    DescriptorData  extra (private) data to append to descriptor
     * @param[out]    EcmIds          list of EcmId's where descriptor rule applies to
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId, DescRuleId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @remark  descriptor string format: hex byte array
     *          possible future extentions:
     *            - EcmPid: inserts 13 bit ECM pid (preceeded by hex nibble E of which one bit is overwritten)
     *            - EcmId:  inserts 16 bits EcmId
     *            - CasId:  inserts 16 bits CasId
     *
     * @version release 8.1
     **/
    void GetEcmgDescriptor_V2(in unsigned long EcmgId, in unsigned long DescRuleId, 
        out string DescRuleName, out eEcmgDescRuleType Type, out eDescInsertionLevel_V2 InsertionLevel, 
        out string DescriptorData, out EcmIdList EcmIds)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set ECMG hot connection backup setting(overrule ECMG disconnection).
     *
     * @param[in]     EcmgId              proxy_id (range [0, 40[) of ECMG proxy
     * @param[in]     bBackupHotStandby   flag to indicate if hot ECMG connection backup is needed
     *                                    (range [0, 1])
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     * @exception OutOfRange        when parameters invalid
     *
     * @remark  non-active DCM will set up connection to ECMG, 
     *          except if hot connection backup is disabled.
     *
     * @version release 2.5
     **/
    void SetHotEcmgConnection(in unsigned long EcmgId, in boolean bBackupHotStandby)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Get ECMG hot connection backup setting(overrule ECMG disconnection).
     *
     * @param[in]     EcmgId              proxy_id (range [0, 40[) of ECMG proxy
     * @param[out]    bBackupHotStandby   flag to indicate if hot ECMG connection backup is needed
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @remark  non-active DCM will set up connection to ECMG, 
     *          except if hot connection backup is disabled.
     *
     * @version release 2.5
     **/
    void GetHotEcmgConnection(in unsigned long EcmgId, out boolean bBackupHotStandby)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set ECMG notify CP extension.
     *
     * @param[in]   EcmgId              proxy_id (range [0, 40[) of ECMG proxy
     * @param[in]   NotifyCPExtension   enable/disable CP extension notification
     *                                  (range [0, 1], default 0)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     * @exception OutOfRange        when parameters invalid
     *
     * @version release 8.9
     **/
    void SetEcmgNotifyCPExtension(in unsigned long EcmgId, in boolean NotifyCPExtension)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Get ECMG notify CP extension.
     *
     * @param[in]   EcmgId              proxy_id (range [0, 40[) of ECMG proxy
     * @param[out]  NotifyCPExtension   enable/disable CP extension notification
     *                                  (range [0, 1], default 0)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EcmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @version release 8.9
     **/
    void GetEcmgNotifyCPExtension(in unsigned long EcmgId, out boolean NotifyCPExtension)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);


    // EMMG
    // ------------------------------------------------------------------------------------

    /**
     * @brief Create an EMMG proxy.
     *
     * @param[out]    EmmgId  proxy_id of newly created EMMG proxy
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  when out of proxy_id's
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 2.0
     **/
    void CreateEmmg(out unsigned long EmmgId)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Delete an EMMG proxy.
     *
     * @param[in]     EmmgId  proxy_id (range [0, 40[) of EMMG proxy to delete
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EmmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 2.0
     **/
    void DeleteEmmg(in unsigned long EmmgId)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set EMMG proxy configuration settings.
     *
     * @param[in]     EmmgId            proxy_id (range [0, 40[) of EMMG proxy
     * @param[in]     Name              name of EMMG proxy (length max 50 characters)
     * @param[in]     ClientId          client_id of EMMG (range [-1, 0x7fff])
     * @param[in]     DataSocket        type of data for socket (TCP or UDP)
     * @param[in]     TcpPort           TCP port where to listen for EMMG
     * @param[in]     UdpPort           UDP port where to listen for EMMG
     * @param[in]     MaxBandwidth      maximum bandwidth to be used for EMM (in bps)
     *                                  (range [0, 5000000])
     * @param[in]     EmmPidSource      EMM pid source (stream_id, channel_id, data_id, packet_id or auto)
     * @param[in]     EmmPidLowerLimit  lower limit for EMM pid selection (for auto mode)
     *                                  (range [0x00, 0x1fff])
     * @param[in]     EmmPidUpperLimit  upper limit for EMM pid selection (for auto mode)
     *                                  (range [0x00, 0x1fff])
     * @param[in]     SectionGrouping   enable/disable section frouping for EMM's
     *                                  (range [0, 1])
     *
     * @remark ClientId 0 for don't care
     * @remark MaxBandwidth triggers only alarm, no specific enforcing beyond the total output bandwidth limit
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EmmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     * @exception OutOfRange        when parameters invalid
     *
     * @version release 2.0
     **/
    void SetEmmgConfig(in unsigned long EmmgId, in string Name, in long ClientId, 
        in eDataSocket DataSocket, in unsigned short TcpPort, in unsigned short UdpPort, 
        in unsigned long MaxBandwidth, in eEmmPidSource EmmPidSource, 
        in unsigned short EmmPidLowerLimit, in unsigned short EmmPidUpperLimit, 
        in eEmmSectionGrouping SectionGrouping)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Get EMMG proxy configuration settings.
     *
     * @param[in]     EmmgId            proxy_id (range [0, 40[) of EMMG proxy
     * @param[out]    Name              name of EMMG proxy
     * @param[out]    ClientId          client_id of EMMG
     * @param[out]    DataSocket        type of data for socket (TCP or UDP)
     * @param[out]    TcpPort           TCP port where to listen for EMMG
     * @param[out]    UdpPort           UDP port where to listen for EMMG
     * @param[out]    MaxBandwidth      maximum bandwidth to be used for EMM (in bps)
     * @param[out]    EmmPidSource      EMM pid source (stream_id, channel_id, data_id, packet_id or auto)
     * @param[out]    EmmPidLowerLimit  lower limit for EMM pid selection (for auto mode)
     * @param[out]    EmmPidUpperLimit  upper limit for EMM pid selection (for auto mode)
     * @param[out]    SectionGrouping   enable/disable section frouping for EMM's
     *
     * @remark ClientId -1 for don't care
     * @remark MaxBandwidth triggers only alarm, no specific enforcing beyond the total output bandwidth limit
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EmmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 2.0
     **/
    void GetEmmgConfig(in unsigned long EmmgId, out string Name, out long ClientId, 
        out eDataSocket DataSocket, out unsigned short TcpPort, out unsigned short UdpPort, 
        out unsigned long MaxBandwidth, out eEmmPidSource EmmPidSource, 
        out unsigned short EmmPidLowerLimit, out unsigned short EmmPidUpperLimit, 
        out eEmmSectionGrouping SectionGrouping)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /** 
     * @brief Get status of EMMG proxy.
     *
     * @param[in]     EmmgId                proxy_id (range [0, 40[) of EMMG proxy
     * @param[out]    EmmgConnectionState   status of connection
     * @param[out]    NoOfOpenStreams       number of open streams on connection
     * @param[out]    CurrentBandwidth      total bandwidth of all EMM's currently imported via EMMG
     * @param[out]    ConnectionPeer        IP address of connected EMMG
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EmmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     * @exception OutOfRange        when parameters invalid (e.g. peer has IPv6 address)
     *
     * @version release 2.0
     * @deprecated This call should not be used anymore since release 10.10 (replaced by call GetEmmgStatus_V2)
     **/ 
    void GetEmmgStatus(in unsigned long EmmgId, out eConnectionState EmmgConnectionState, 
        out unsigned long NoOfOpenStreams, out unsigned long CurrentBandwidth, 
        out unsigned long ConnectionPeer)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /** 
     * @brief Get status of EMMG proxy.
     *
     * @param[in]     EmmgId                proxy_id (range [0, 40[) of EMMG proxy
     * @param[out]    EmmgConnectionState   status of connection
     * @param[out]    NoOfOpenStreams       number of open streams on connection
     * @param[out]    CurrentBandwidth      total bandwidth of all EMM's currently imported via EMMG
     * @param[out]    ConnectionPeer        IP address of connected EMMG
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EmmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 10.10
     **/ 
    void GetEmmgStatus_V2(in unsigned long EmmgId, out eConnectionState EmmgConnectionState, 
        out unsigned long NoOfOpenStreams, out unsigned long CurrentBandwidth, 
        out string ConnectionPeer)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get list of available descriptor rules for EMMG proxy.
     *
     * @param[in]     EmmgId        proxy_id (range [0, 40[) of EMMG proxy
     * @param[out]    DescRuleIds   list of configured descriptor rules (desc_rule_id)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EmmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 2.0
     **/
    void GetEmmgDescList(in unsigned long EmmgId, out IdList DescRuleIds)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Create a new descriptor rule for an EMMG proxy.
     *
     * @param[in]     EmmgId      proxy_id (range [0, 40[) of EMMG proxy
     * @param[out]    DescRuleId  desc_rule_id of newly created descriptor rule
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EmmgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 2.0
     **/
    void CreateEmmgDescriptor(in unsigned long EmmgId, out unsigned long DescRuleId)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Delete a descriptor rule for an EMMG proxy.
     *
     * @param[in]     EmmgId      proxy_id (range [0, 40[) of EMMG proxy
     * @param[in]     DescRuleId  desc_rule_id of descriptor rule to delete
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EmmgId, DescRuleId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 2.0
     **/
    void DeleteEmmgDescriptor(in unsigned long EmmgId, in unsigned long DescRuleId)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set descriptor rule (on EMMG proxy) configuration settings.
     *
     * @param[in]     EmmgId          proxy_id (range [0, 40[) of EMMG proxy
     * @param[in]     DescRuleId      desc_rule_id of descriptor rule
     * @param[in]     DescRuleName    name of descriptor rule (length max 30 characters)
     * @param[in]     Type            type of descriptor rule ('add private data' or 'do no insert')
     * @param[in]     DescriptorData  extra (private) data to append to descriptor
     *                                (length of data max 100 bytes)
     * @param[in]     DataIds         list of DataId's where descriptor rule applies to
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EmmgId, DescRuleId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     * @exception OutOfRange        when parameters invalid
     *
     * @version release 2.0
     **/
    void SetEmmgDescriptor(in unsigned long EmmgId, in unsigned long DescRuleId, 
        in string DescRuleName, in eEmmgDescRuleType Type, in string DescriptorData, 
        in DataIdList DataIds)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Get descriptor rule (on EMMG proxy) configuration settings.
     *
     * @param[in]     EmmgId          proxy_id (range [0, 40[) of EMMG proxy
     * @param[out]    DescRuleId      desc_rule_id of descriptor rule
     * @param[out]    DescRuleName    name of descriptor rule
     * @param[out]    Type            type of descriptor rule ('add private data' or 'do no insert')
     * @param[out]    DescriptorData  extra (private) data to append to descriptor
     * @param[out]    DataIds         list of DataId's where descriptor rule applies to
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EmmgId, DescRuleId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 2.0
     **/
    void GetEmmgDescriptor(in unsigned long EmmgId, in unsigned long DescRuleId, 
        out string DescRuleName, out eEmmgDescRuleType Type, out string DescriptorData, 
        out DataIdList DataIds)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);


    // EIS
    // ------------------------------------------------------------------------------------

    /**
     * @brief Create an EIS proxy.
     *
     * @param[out]    EisId   proxy_id (range [0, 40[) of newly created EIS proxy
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  when out of proxy_id's
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 2.0
     **/
    void CreateEis(out unsigned long EisId)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Delete an EIS proxy.
     *
     * @param[in]     EisId   proxy_id (range [0, 40[) of EIS proxy to delete
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EisId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 2.0
     **/
    void DeleteEis(in unsigned long EisId)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Create a MCrypt EIS proxy.
     *
     * @param[out]    EisId   proxy_id (range [0, 40[) of newly created MCrypt EIS proxy
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  when out of proxy_id's
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 2.0
     * @deprecated This call should not be used (replace by call CreateEis)
     **/
    void CreateMCryptEis(out unsigned long EisId)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Delete a MCrypt EIS proxy.
     *
     * @param[in]     EisId   proxy_id (range [0, 40[) of MCrypt EIS proxy to delete
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EisId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 2.0
     * @deprecated This call should not be used (replace by call DeleteEis)
     **/
    void DeleteMCryptEis(in unsigned long EisId)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set EIS proxy configuration settings.
     *
     * @param[in]     EisId     proxy_id (range [0, 40[) of EIS proxy
     * @param[in]     Name      name of EIS proxy (length max 20 characters)
     * @param[in]     EisType   type of EIS proxy
     * @param[in]     TcpPort   TCP port where to listen for EIS
     * @param[in]     OverruleRecommendedCpDuration flag to overrule recommended_CP_duration
     *                                              (range [0, 1])
     * @param[in]     RecommendedCpDuration         overruled value for recommended_CP_duration (in ms)
     *                                              (range [0x00, 0x7fffffff])
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EisId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     * @exception OutOfRange        when parameters invalid
     *
     * @version release 2.0
     **/
    void SetEisConfig(in unsigned long EisId, in string Name, in eEisType EisType, 
        in unsigned short TcpPort, in boolean OverruleRecommendedCpDuration, 
        in unsigned long RecommendedCpDuration)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Get EIS proxy configuration settings.
     *
     * @param[in]     EisId     proxy_id (range [0, 40[) of EIS proxy
     * @param[out]    Name      name of EIS proxy
     * @param[out]    EisType   type of EIS proxy
     * @param[out]    TcpPort   TCP port where to listen for EIS
     * @param[out]    OverruleRecommendedCpDuration flag to overrule recommended_CP_duration
     * @param[out]    RecommendedCpDuration         overruled value for recommended_CP_duration (in ms)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EisId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 2.0
     **/
    void GetEisConfig(in unsigned long EisId, out string Name, out eEisType EisType, 
        out unsigned short TcpPort, out boolean OverruleRecommendedCpDuration, 
        out unsigned long RecommendedCpDuration)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get status of EIS proxy.
     *
     * @param[in]     EisId               proxy_id (range [0, 40[) of EIS proxy
     * @param[out]    EisConnectionState  status of connection
     * @param[out]    ConnectionPeer      IP address of connected EIS
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EisId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     * @exception OutOfRange        when parameters invalid (e.g. peer has IPv6 address)
     *
     * @version release 2.0
     * @deprecated This call should not be used anymore since release 10.10 (replaced by call GetEisStatus_V2)
     **/
    void GetEisStatus(in unsigned long EisId, out eConnectionState EisConnectionState, 
        out unsigned long ConnectionPeer)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Get status of EIS proxy.
     *
     * @param[in]     EisId               proxy_id (range [0, 40[) of EIS proxy
     * @param[out]    EisConnectionState  status of connection
     * @param[out]    ConnectionPeer      IP address of connected EIS
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EisId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 10.10
     **/
    void GetEisStatus_V2(in unsigned long EisId, out eConnectionState EisConnectionState, 
        out string ConnectionPeer)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);


    // PSIG
    // ------------------------------------------------------------------------------------

    /**
     * @brief Create a PSIG proxy.
     *
     * @param[out]    PsigId  proxy_id (range [0, 40[) of newly created PSIG proxy
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  when out of proxy_id's
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 2.0
     **/
    void CreatePsig(out unsigned long PsigId)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Delete a PSIG proxy.
     *
     * @param[in]     PsigId  proxy_id (range [0, 40[) of PSIG proxy to delete
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EisId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 2.0
     **/
    void DeletePsig(in  unsigned long PsigId)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Create a MCrypt PSIG proxy.
     *
     * @param[out]    PsigId  proxy_id (range [0, 40[) of newly created MCrypt PSIG proxy
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  when out of proxy_id's
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 2.0
     * @deprecated This call should not be used (replace by call CreatePsig)
     **/
    void CreateMCryptPsig(out unsigned long PsigId)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Delete a MCrypt PSIG proxy.
     *
     * @param[in]     PsigId  proxy_id (range [0, 40[) of MCrypt PSIG proxy to delete
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EisId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 2.0
     * @deprecated This call should not be used (replace by call DeletePsig)
     **/
    void DeleteMCryptPsig(in  unsigned long PsigId)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set PSIG proxy configuration settings.
     *
     * @param[in]     PsigId        proxy_id (range [0, 40[) of PSIG proxy
     * @param[in]     Name          name of PSIG proxy (length max 20 characters)
     * @param[in]     PsigType      type of PSIG proxy
     * @param[in]     TcpPort       TCP port where to listen for PSIG
     * @param[in]     MaxBandwidth  maximum bandwidth to be used for PSI (in bps)
     *                              (range [0, 2000000])
     *
     * @remark MaxBandwidth triggers only alarm, no specific enforcing beyond the total output bandwidth limit
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EisId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     * @exception OutOfRange        when parameters invalid
     *
     * @version release 2.0
     **/
    void SetPsigConfig(in unsigned long PsigId, in string Name, in ePsigType PsigType, 
        in unsigned short TcpPort, in unsigned long MaxBandwidth)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Set PSIG proxy configuration settings.
     *
     * @param[in]     PsigId        proxy_id (range [0, 40[) of PSIG proxy
     * @param[out]    Name          name of PSIG proxy
     * @param[out]    PsigType      type of PSIG proxy
     * @param[out]    TcpPort       TCP port where to listen for PSIG
     * @param[out]    MaxBandwidth  maximum bandwidth to be used for PSI (in bps)
     *
     * @remark MaxBandwidth triggers only alarm, no specific enforcing beyond the total output bandwidth limit
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EisId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 2.0
     **/
    void GetPsigConfig(in unsigned long PsigId, out string Name, out ePsigType PsigType, 
        out unsigned short TcpPort, out unsigned long MaxBandwidth)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set PSIG proxy configuration settings.
     *
     * @param[in]     PsigId        proxy_id (range [0, 40[) of PSIG proxy
     * @param[in]     Name          name of PSIG proxy (length max 20 characters)
     * @param[in]     PsigType      type of PSIG proxy
     * @param[in]     TcpPort       TCP port where to listen for PSIG
     * @param[in]     MaxBandwidth  maximum bandwidth to be used for PSI (in bps)
     *                              (range [0, 2000000])
     * @param[in]     DoNotModify   If set, tables imported on this proxy will be played out
     *                              exactly as received, without changing any fields.
     *
     * @remark MaxBandwidth triggers only alarm, no specific enforcing beyond the total output bandwidth limit
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EisId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     * @exception OutOfRange        when parameters invalid
     *
     * @version release 7.0
     **/
    void SetPsigConfig2(in unsigned long PsigId, in string Name, in ePsigType PsigType, 
        in unsigned short TcpPort, in unsigned long MaxBandwidth, in boolean DoNotModify)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Set PSIG proxy configuration settings.
     *
     * @param[in]     PsigId        proxy_id (range [0, 40[) of PSIG proxy
     * @param[out]    Name          name of PSIG proxy
     * @param[out]    PsigType      type of PSIG proxy
     * @param[out]    TcpPort       TCP port where to listen for PSIG
     * @param[out]    MaxBandwidth  maximum bandwidth to be used for PSI (in bps)
     * @param[in]     DoNotModify   Tables imported on this proxy will be played out
     *                              exactly as received, without changing any fields.
     *
     * @remark MaxBandwidth triggers only alarm, no specific enforcing beyond the total output bandwidth limit
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EisId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 7.0
     **/
    void GetPsigConfig2(in unsigned long PsigId, out string Name, out ePsigType PsigType, 
        out unsigned short TcpPort, out unsigned long MaxBandwidth, out boolean DoNotModify)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set PSIG proxy configuration settings.
     *
     * @param[in]     PsigId        proxy_id (range [0, 40[) of PSIG proxy
     * @param[in]     Name          name of PSIG proxy (length max 20 characters)
     * @param[in]     PsigType      type of PSIG proxy
     * @param[in]     TcpPort       TCP port where to listen for PSIG
     * @param[in]     MaxBandwidth  maximum bandwidth to be used for PSI (in bps)
     *                              (range [0, 2000000])
     * @param[in]     DoNotModify   If set, tables imported on this proxy will be played out
     *                              exactly as received, without changing any fields.
     * @param[in]     AllowMultipleNITa   If set, more than one NITa can be provisioned for the same TS
     *
     * @remark MaxBandwidth triggers only alarm, no specific enforcing beyond the total output bandwidth limit
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EisId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     * @exception OutOfRange        when parameters invalid
     *
     * @version release 9.0
     **/
    void SetPsigConfig3(in unsigned long PsigId, in string Name, in ePsigType PsigType, 
        in unsigned short TcpPort, in unsigned long MaxBandwidth, in boolean DoNotModify, in boolean AllowMultipleNITa)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Get PSIG proxy configuration settings.
     *
     * @param[in]     PsigId        proxy_id (range [0, 40[) of PSIG proxy
     * @param[out]    Name          name of PSIG proxy
     * @param[out]    PsigType      type of PSIG proxy
     * @param[out]    TcpPort       TCP port where to listen for PSIG
     * @param[out]    MaxBandwidth  maximum bandwidth to be used for PSI (in bps)
     * @param[out]    DoNotModify   Tables imported on this proxy will be played out
     *                              exactly as received, without changing any fields.
     * @param[out]    MultipleNITa  If set, more than one NITa can be provisioned for the same TS
     *
     * @remark MaxBandwidth triggers only alarm, no specific enforcing beyond the total output bandwidth limit
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EisId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 9.0
     **/
    void GetPsigConfig3(in unsigned long PsigId, out string Name, out ePsigType PsigType, 
        out unsigned short TcpPort, out unsigned long MaxBandwidth, out boolean DoNotModify, out boolean MultipleNITa)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get status of PSIG proxy.
     *
     * @param[in]     PsigId                proxy_id (range [0, 40[) of PSIG proxy
     * @param[out]    PsigConnectionState   status of connection
     * @param[out]    NoOfStreams           number of open streams on connection
     * @param[out]    CurrentBandwidth      total bandwidth of all PSI currently imported via PSIG
     * @param[out]    ConnectionPeer        IP address of connected PSIG
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EisId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     * @exception OutOfRange        when parameters invalid (e.g. peer has IPv6 address)
     *
     * @version release 2.0
     * @deprecated This call should not be used anymore since release 10.10 (replaced by call GetPsigStatus_V2)
     **/
    void GetPsigStatus(in unsigned long PsigId, out eConnectionState PsigConnectionState, 
        out unsigned long NoOfStreams, out unsigned long CurrentBandwidth, out unsigned long ConnectionPeer)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Get status of PSIG proxy.
     *
     * @param[in]     PsigId                proxy_id (range [0, 40[) of PSIG proxy
     * @param[out]    PsigConnectionState   status of connection
     * @param[out]    NoOfStreams           number of open streams on connection
     * @param[out]    CurrentBandwidth      total bandwidth of all PSI currently imported via PSIG
     * @param[out]    ConnectionPeer        IP address of connected PSIG
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid EisId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     * @exception OutOfRange        when parameters invalid (e.g. peer has IPv6 address)
     *
     * @version release 10.10
     **/
    void GetPsigStatus_V2(in unsigned long PsigId, out eConnectionState PsigConnectionState, 
        out unsigned long NoOfStreams, out unsigned long CurrentBandwidth, out string ConnectionPeer)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);


    // CWG
    // ------------------------------------------------------------------------------------

    /**
     * @brief Create an CWG proxy.
     *
     * @param[out]    CwgId   proxy_id of newly created CWG proxy
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  when out of proxy_id's
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 9.0
     **/
    void CreateCwg(out unsigned long CwgId)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Delete an CWG proxy.
     *
     * @param[in]     CwgId   proxy_id (range [0, 40[) of CWG proxy to delete
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid CwgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 9.0
     **/
    void DeleteCwg(in unsigned long CwgId) 
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Set CWG proxy configuration settings.
     *
     * @param[in]     CwgId            proxy_id (range [0, 40[) of CWG proxy
     * @param[in]     Name              name of CWG proxy (length max 20 characters)
     * @param[in]     Type              type of CWG proxy
     * @param[in]     CasId             CA_system_id of CWG
     * @param[in]     SubCasId          CA_subsystem_id of CWG
     * @param[in]     ChannelIdMode     CWG channel_id selection mode
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid CwgId or parameter
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    called on other board than the mainboard or
     *                              not yet supported on running software version
     * @exception OutOfRange        when parameters invalid
     *
     * @version release 9.0
     **/
    void SetCwgConfig(in unsigned long CwgId, in string Name, in eCwgType Type, 
        in unsigned short CasId, in unsigned short SubCasId, in eCwgChannelIdMode ChannelIdMode)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Get CWG proxy configuration settings.
     *
     * @param[in]     CwgId             proxy_id (range [0, 40[) of CWG proxy
     * @param[out]    Name              name of CWG proxy
     * @param[out]    Type              type of CWG proxy
     * @param[out]    CasId             CA_system_id of CWG
     * @param[out]    SubCasId          CA_subsystem_id of CWG
     * @param[out]    ChannelIdMode     CWG channel_id selection mode
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error
     * @exception InvalidSelection  invalid CwgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @version release 9.0
     **/
    void GetCwgConfig(in unsigned long CwgId, out string Name, out eCwgType Type, 
        out unsigned short CasId, out unsigned short SubCasId, out eCwgChannelIdMode ChannelIdMode)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get status of CWG proxy.
     *
     * @param[in]     CwgId                 proxy_id (range [0, 40[) of CWG proxy
     * @param[out]    NoOfRequestedStreams  total number of requested streams on proxy (all channels)
     * @param[out]    NoOfOpenStreams       total number of open streams on proxy (all channels)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid CwgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @version release 9.0
     **/
    void GetCwgStatus(in unsigned long CwgId, out unsigned long NoOfRequestedStreams, 
        out unsigned long NoOfOpenStreams)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get list of available connections (channels) for an CWG proxy.
     *
     * @param[in]     CwgId     proxy_id (range [0, 40[) of CWG proxy
     * @param[out]    ConnIds   list of configured connections (conn_id)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid CwgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @version release 9.0
     **/
    void GetCwgConnList(in unsigned long CwgId, out IdList ConnIds)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Create a new connection (channel) for an CWG proxy.
     *
     * @param[in]     CwgId     proxy_id (range [0, 40[) of CWG proxy
     * @param[out]    ConnId    conn_id of newly created connection (channel)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid CwgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @version release 9.0
     **/
    void CreateCwgConn(in unsigned long CwgId, out unsigned long ConnId)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Delete a connection (channel) for an CWG proxy.
     *
     * @param[in]     CwgId     proxy_id (range [0, 40[) of CWG proxy
     * @param[in]     ConnId    conn_id of connection (channel) to delete
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid CwgId, ConnId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @version release 9.0
     **/
    void DeleteCwgConn(in unsigned long CwgId, in unsigned long ConnId)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set connection (channel) configuration settings.
     *
     * @param[in]     CwgId       proxy_id (range [0, 40[) of CWG proxy
     * @param[in]     ConnId      conn_id of connection (channel)
     * @param[in]     IpAddress   IP address of CWG to connect with (range ]0, 0xffffffff])
     * @param[in]     Port        port on CWG to establisch connection on (range [100, 0xffff])
     * @param[in]     ChannelId   channel_id to be used (for manual mode)
     * @param[in]     Priority    priority of connection (for backup and load balancing)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid CwgId, ConnId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     * @exception OutOfRange        when parameters invalid
     *
     * @version release 9.0
     * @deprecated This call should not be used anymore since release 10.10 (replaced by call SetCwgConnConfig_V2)
     **/
    void SetCwgConnConfig(in unsigned long CwgId, in unsigned long ConnId, 
        in unsigned long IpAddress, in unsigned short Port, in unsigned short ChannelId,  
        in long Priority)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Get connection (channel) configuration settings.
     *
     * @param[in]     CwgId       proxy_id (range [0, 40[) of CWG proxy
     * @param[in]     ConnId      conn_id of connection (channel)
     * @param[out]    IpAddress   IP address of CWG to connect with
     * @param[out]    Port        port on CWG to establisch connection on
     * @param[out]    ChannelId   channel_id to be used (for manual mode)
     * @param[out]    Priority    priority of connection (for backup and load balancing)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid CwgId, ConnId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     * @exception OutOfRange        when parameters invalid (e.g. IPv6 address configured)
     *
     * @version release 9.0
     * @deprecated This call should not be used anymore since release 10.10 (replaced by call GetCwgConnConfig_V2)
     **/
    void GetCwgConnConfig(in unsigned long CwgId, in unsigned long ConnId, 
        out unsigned long IpAddress, out unsigned short Port, out unsigned short ChannelId, 
        out long Priority)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Set connection (channel) configuration settings.
     *
     * @param[in]     CwgId       proxy_id (range [0, 40[) of CWG proxy
     * @param[in]     ConnId      conn_id of connection (channel)
     * @param[in]     IpAddress   IP address of CWG to connect with
     * @param[in]     Port        port on CWG to establisch connection on (range [100, 0xffff])
     * @param[in]     ChannelId   channel_id to be used (for manual mode)
     * @param[in]     Priority    priority of connection (for backup and load balancing)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid CwgId, ConnId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     * @exception OutOfRange        when parameters invalid
     *
     * @version release 10.10
     **/
    void SetCwgConnConfig_V2(in unsigned long CwgId, in unsigned long ConnId, 
        in string IpAddress, in unsigned short Port, in unsigned short ChannelId,  
        in long Priority)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Get connection (channel) configuration settings.
     *
     * @param[in]     CwgId       proxy_id (range [0, 40[) of CWG proxy
     * @param[in]     ConnId      conn_id of connection (channel)
     * @param[out]    IpAddress   IP address of CWG to connect with
     * @param[out]    Port        port on CWG to establisch connection on
     * @param[out]    ChannelId   channel_id to be used (for manual mode)
     * @param[out]    Priority    priority of connection (for backup and load balancing)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid CwgId, ConnId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @version release 10.10
     **/
    void GetCwgConnConfig_V2(in unsigned long CwgId, in unsigned long ConnId, 
        out string IpAddress, out unsigned short Port, out unsigned short ChannelId, 
        out long Priority)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get status of connection (channel) in CWG proxy.
     *
     * @param[in]     CwgId                 proxy_id (range [0, 40[) of CWG proxy
     * @param[in]     ConnId                conn_id of connection (channel)
     * @param[out]    ConnectionStatus      status of connection
     * @param[out]    UsedChannelId         channel_id used for connection
     * @param[out]    NoOfOpenStreams       number of open streams on connection (channel)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid CwgId, ConnId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @version release 9.0
     **/
    void GetCwgConnStatus(in unsigned long CwgId, in unsigned long ConnId, 
        out eCwgConnectionStatus ConnectionStatus, out unsigned short UsedChannelId, 
        out unsigned short NoOfOpenStreams)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set CWG proxy advanced settings.
     *
     * @param[in]     CwgId                 proxy_id (range [0, 40[) of CWG proxy
     * @param[in]     OverruleMaxCompTime   flag to overrule max_comp_time 
     *                                      (range [0, 1])
     * @param[in]     MaxCompTime           overruled value for max_comp_time (in ms)
     *                                      (range [0, 60000])
     * @param[in]     OverruleMaxStreams    flag to overrule max_streams
     *                                      (range [0, 1])
     * @param[in]     MaxStreams            overruled value for max_streams
     *                                      (range [0, 80])
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid CwgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     * @exception OutOfRange        when parameters invalid
     *
     * @version release 9.0
     **/
    void SetCwgOverrule(in unsigned long CwgId, 
        in boolean OverruleMaxCompTime, in short MaxCompTime,
        in boolean OverruleMaxStreams,  in unsigned short MaxStreams)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported, OutOfRange);

    /**
     * @brief Get CWG proxy advanced settings.
     *
     * @param[in]     CwgId                         proxy_id (range [0, 40[) of CWG proxy
     * @param[out]    OverruleMaxCompTime           flag to overrule max_comp_time
     * @param[out]    MaxCompTime                   overruled value for max_comp_time (in ms)
     * @param[out]    OverruleMaxStreams            flag to overrule max_streams
     * @param[out]    MaxStreams                    overruled value for max_streams
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception InvalidSelection  invalid CwgId
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              not yet supported on running software version
     *
     * @version release 9.0
     **/
    void GetCwgOverrule(in unsigned long CwgId, 
        out boolean OverruleMaxCompTime,          out short MaxCompTime,
        out boolean OverruleMaxStreams,           out unsigned short MaxStreams)
      raises(TimeOut, OpNotSucceeded, InvalidSelection, OpNotAllowed, OpNotSupported);

    /// @} end of scrambling 


    /**
     * @defgroup biss BISS scrambling
     * This module contains types, enums and methods related to BISS scrambling.
     * @{
     **/

    // ------------------------------------------------------------------------------------
    // BISS structures & enums
    // ------------------------------------------------------------------------------------

    /**
     * @brief Scrambling algorithm.
     *
     * @version release 8.9
     **/
    enum enEncryptionAlgorithm
    {
      eCSA_Encryption,                    ///< CSA encryption
      eDES_Encryption,                    ///< DES encryption
      eEncryptionAlgorithm_Reserved2,     ///< Reserved for future use
      eEncryptionAlgorithm_Reserved3,     ///< Reserved for future use
      eEncryptionAlgorithm_Reserved4,     ///< Reserved for future use
      eEncryptionAlgorithm_Reserved5,     ///< Reserved for future use
      eEncryptionAlgorithm_Reserved6,     ///< Reserved for future use
      eEncryptionAlgorithm_Reserved7,     ///< Reserved for future use
      eEncryptionAlgorithm_Reserved8,     ///< Reserved for future use
      eEncryptionAlgorithm_Reserved9,     ///< Reserved for future use
      eEncryptionAlgorithm_Reserved10     ///< Reserved for future use
    };

    /// Scrambling action
    enum enScramblingAction
    {
      eScrambling,                ///< Scrambling mode
      eDescrambling               ///< Descrambling mode
    };

    /// Scrambling mode
    enum enScramblingMode
    {
      eDvbScrambling,             ///< DVB Simulcrypt scrambling
      eBissScrambling             ///< BISS scrambling (BISS mode 1 and fixed CW)
    };

    /**
     * @brief Operating mode (PowerVu specific).
     *
     * @version release 8.9 - only Simulcypt mode supported
     * @version release 9.0
     **/
    enum enOperatingMode_t
    {
      ePowerVu,                   ///< PowerVu Standard (as D9140 replacement)
                                  //   (PowerVu generated CW's, only PowerVu specified components scrambled)
      ePowerVuSimulcrypt,         ///< PowerVu Simulcrypt
                                  //   (DCM generated CW's, only PowerVu specified components scrambled)
      eSimulcrypt,                ///< Simulcrypt
                                  //   (DCM generated CW's, all components scrambled)
      eOperatingMode_Reserved4,   ///< Reserved for future use
      eOperatingMode_Reserved5    ///< Reserved for future use
    };

    typedef sequence<unsigned short> PidList_t;


    // ------------------------------------------------------------------------------------
    // BISS IDL
    // ------------------------------------------------------------------------------------

    /**
     * @brief Set the encryption algorithm.
     *
     * @param[in]   BoardNr               board number on which to apply call
     * @param[in]   eEncryptionAlgorithm  encryption algorithm (firmware)
     *
     * @note A reboot is required to apply the new scrambling algorithm.
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    when a general failure occurs
     *                              - BoardNr out of range
     *                              - eEncryptionAlgorithm out of range
     * @exception OpNotAllowed      when not logged on
     * @exception OpNotSupported    when called on mainboard or
     *                              when call not yet supported on running software version
     *
     * @version release 8.9
     **/
    void SCR_SetEncryptionAlgorithm(in unsigned short BoardNr, in enEncryptionAlgorithm eEncryptionAlgorithm)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get the encryption algorithm.
     * 
     * @param[in]   BoardNr               board number on which to apply call
     * @param[out]  eEncryptionAlgorithm  encryption algorithm (firmware)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    when a general failure occurs
     *                              - BoardNr out of range [0, n]
     * @exception OpNotAllowed      when not logged on
     * @exception OpNotSupported    when called on mainboard or 
     *                              when call not supported yet on running software
     * 
     * @version release 8.9
     **/
    void SCR_GetEncryptionAlgorithm(in unsigned short BoardNr, out enEncryptionAlgorithm eEncryptionAlgorithm)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set the scrambling/descrambling mode.
     *
     * @param[in]     BoardNr           board number on which to apply call
     * @param[in]     eScramblingAction scrambling/descrambling mode
     *
     * @note Changing the scrambling/descrambling mode will release all scrambling licenses
     *       on the board and will reset the services set for BISS scrambling/descrambling.
     *       The session word and parity bit on the TS will still remain unchanged.
     *
     * @exception TimeOut         when it takes too long to handle the call
     * @exception OpNotSucceeded  when a general failure occurs
     *                            - BoardNr out of range [0, n]
     *                            - eScramblingAction out of range
     * @exception OpNotAllowed    when not logged on
     * @exception OpNotSupported  when called on mainboard or 
     *                            when call not supported yet on running software
     * 
     * @version release 8.0
     **/
    void SCR_SetScramblingAction(in unsigned short BoardNr, in enScramblingAction eScramblingAction)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /**
     * @brief Get the scrambling/descrambling mode.
     * 
     * @param[in]     BoardNr           board number on which to apply call
     * @param[out]    eScramblingAction scrambling/descrambling mode
     *
     * @exception TimeOut         when it takes too long to handle the call
     * @exception OpNotSucceeded  when a general failure occurs
     *                            - BoardNr out of range [0, n]
     * @exception OpNotAllowed    when not logged on
     * @exception OpNotSupported  when called on mainboard or 
     *                            when call not supported yet on running software
     * 
     * @version release 8.0
     **/
    void SCR_GetScramblingAction(in unsigned short BoardNr, out enScramblingAction eScramblingAction)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set the default scrambling mode.
     * 
     * @param[in]     BoardNr           board number on which to apply call
     * @param[in]     eScramblingMode   default scrambling mode on TS creation
     *
     * @exception TimeOut         when it takes too long to handle the call
     * @exception OpNotSucceeded  when a general failure occurs
     *                            - BoardNr out of range [0, n]
     *                            - eScramblingMode out of range
     * @exception OpNotAllowed    when not logged on
     * @exception OpNotSupported  when called on mainboard or 
     *                            when call not supported yet on running software
     * 
     * @version release 6.0
     **/
    void SCR_SetDefaultScramblingMode(in unsigned short BoardNr, in enScramblingMode eScramblingMode)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get the default scrambling mode.
     * 
     * @param[in]     BoardNr           board number on which to apply call
     * @param[out]    eScramblingMode   default scrambling mode on TS creation
     *
     * @exception TimeOut         when it takes too long to handle the call
     * @exception OpNotSucceeded  when a general failure occurs
     *                            - BoardNr out of range [0, n]
     * @exception OpNotAllowed    when not logged on
     * @exception OpNotSupported  when called on mainboard or 
     *                            when call not supported yet on running software
     * 
     * @version release 6.0
     **/
    void SCR_GetDefaultScramblingMode(in unsigned short BoardNr, out enScramblingMode eScramblingMode)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set the default session word.
     * 
     * @param[in]     BoardNr       board number on which to apply call
     * @param[in]     SessionWord   default session word on TS creation
     *
     * @exception TimeOut         when it takes too long to handle the call
     * @exception OpNotSucceeded  when a general failure occurs
     *                            - BoardNr out of range [0, n]
     *                            - length of SessionWord different from 6 bytes
     * @exception OpNotAllowed    when not logged on
     * @exception OpNotSupported  when called on mainboard or 
     *                            when call not supported yet on running software
     * 
     * @version release 6.0
     **/
    void SCR_SetDefaultSessionWord(in unsigned short BoardNr, in ByteStream SessionWord)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get the default session word.
     * 
     * @param[in]     BoardNr       board number on which to apply call
     * @param[out]    SessionWord   default session word on TS creation
     * @param[out]    FollowDefault indicate if factory default session word used
     *
     * @note For security reasons, the SessionWord parameter will contain
     *       the factory default session word (and not the configured one)!
     *
     * @exception TimeOut         when it takes too long to handle the call
     * @exception OpNotSucceeded  when a general failure occurs (e.g. BoardNr out of range [0, n])
     * @exception OpNotAllowed    when not logged on
     * @exception OpNotSupported  
     *                - when called on mainboard
     *                - when call not supported yet on running software
     * 
     * @version release 8.2
     **/
    void SCR_GetDefaultSessionWord(in unsigned short BoardNr, out ByteStream SessionWord,
        out boolean FollowDefault)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set the default parity bit.
     * 
     * @param[in]     BoardNr       board number on which to apply call
     * @param[in]     ParityBit     default parity bit on TS creation
     *
     * @exception TimeOut         when it takes too long to handle the call
     * @exception OpNotSucceeded  when a general failure occurs
     *                            - BoardNr out of range [0, n]
     *                            - ParityBit out of range [0, 1]
     * @exception OpNotAllowed    when not logged on
     * @exception OpNotSupported  when called on mainboard or 
     *                            when call not supported yet on running software
     * 
     * @version release 6.0
     **/
    void SCR_SetDefaultParityBit(in unsigned short BoardNr, in octet ParityBit)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get the default parity bit.
     * 
     * @param[in]     BoardNr       board number on which to apply call
     * @param[out]    ParityBit     default parity bit on TS creation
     *
     * @exception TimeOut         when it takes too long to handle the call
     * @exception OpNotSucceeded  when a general failure occurs
     *                            - BoardNr out of range [0, n]
     * @exception OpNotAllowed    when not logged on
     * @exception OpNotSupported  when called on mainboard or 
     *                            when call not supported yet on running software
     * 
     * @version release 6.0
     **/
    void SCR_GetDefaultParityBit(in unsigned short BoardNr, out octet ParityBit)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set the default operating mode.
     * 
     * @param[in]     BoardNr         board number on which to apply call
     * @param[in]     enOperatingMode default operating mode on TS creation
     *
     * @exception TimeOut         when it takes too long to handle the call
     * @exception OpNotSucceeded  when a general failure occurs
     *                            - BoardNr out of range [0, n]
     *                            - enOperatingMode out of range
     * @exception OpNotAllowed    when not logged on
     * @exception OpNotSupported  when called on mainboard or 
     *                            when call not supported yet on running software
     * 
     * @version release 8.9
     **/
    void SCR_SetDefaultOperatingMode(in unsigned short BoardNr, in enOperatingMode_t enOperatingMode)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get the default operating mode.
     * 
     * @param[in]     BoardNr         board number on which to apply call
     * @param[out]    enOperatingMode default operating mode on TS creation
     *
     * @exception TimeOut         when it takes too long to handle the call
     * @exception OpNotSucceeded  when a general failure occurs
     *                            - BoardNr out of range [0, n]
     * @exception OpNotAllowed    when not logged on
     * @exception OpNotSupported  when called on mainboard or 
     *                            when call not supported yet on running software
     * 
     * @version release 8.9
     **/
    void SCR_GetDefaultOperatingMode(in unsigned short BoardNr, out enOperatingMode_t enOperatingMode)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set the scrambling mode on TS.
     * 
     * @param[in]     RefTS             TS on which to apply call
     * @param[in]     eScramblingMode   new scrambling mode for TS
     * 
     * @note Changing the scrambling mode will release all scrambling licenses on 
     *       the TS and will reset the services set for BISS scrambling.
     *       The session word and parity bit on the TS will still remain unchanged.
     *
     * @exception TimeOut         when it takes too long to handle the call
     * @exception OpNotSucceeded  when a general failure occurs
     *                            - RefTS invalid
     *                            - eScramblingMode out of range
     * @exception OpNotAllowed    when not logged on
     * @exception OpNotSupported  when called on mainboard or 
     *                            when call not supported yet on running software
     * 
     * @version release 6.0
     * @version release 8.0   reset TS specific BISS settings
     **/
    void SCR_SetScramblingMode(in IPS_RefTS_t RefTS, in enScramblingMode eScramblingMode)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get the scrambling mode on TS.
     * 
     * @param[in]     RefTS             TS on which to apply call
     * @param[out]    eScramblingMode   scrambling mode on TS
     *
     * @exception TimeOut         when it takes too long to handle the call
     * @exception OpNotSucceeded  when a general failure occurs
     *                            - RefTS invalid
     * @exception OpNotAllowed    when not logged on
     * @exception OpNotSupported  when called on mainboard or 
     *                            when call not supported yet on running software
     * 
     * @version release 6.0
     **/
    void SCR_GetScramblingMode(in IPS_RefTS_t RefTS, out enScramblingMode eScramblingMode)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set the session word on TS.
     * 
     * @param[in]     RefTS         TS on which to apply call
     * @param[in]     SessionWord   new session word for TS
     *
     * @exception TimeOut         when it takes too long to handle the call
     * @exception OpNotSucceeded  when a general failure occurs
     *                            - RefTS invalid
     *                            - length of SessionWord different from 6 bytes
     * @exception OpNotAllowed    when not logged on
     * @exception OpNotSupported  when called on mainboard or 
     *                            when call not supported yet on running software
     * 
     * @version release 6.0
     **/
    void SCR_SetSessionWord(in IPS_RefTS_t RefTS, in ByteStream SessionWord)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get the session word on TS.
     * 
     * @param[in]     RefTS         TS on which to apply call
     * @param[out]    SessionWord   session word on TS
     * @param[out]    FollowDefault indicate if factory default session word used
     *
     * @note For security reasons, the SessionWord parameter will contain
     *       the factory default session word (and not the configured one)!
     *
     * @exception TimeOut         when it takes too long to handle the call
     * @exception OpNotSucceeded  when a general failure occurs (e.g. RefTS invalid)
     * @exception OpNotAllowed    when not logged on
     * @exception OpNotSupported  
     *                - when called on mainboard
     *                - when call not supported yet on running software
     * 
     * @version release 8.2
     **/
    void SCR_GetSessionWord(in IPS_RefTS_t RefTS, out ByteStream SessionWord,
        out boolean FollowDefault)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set the parity bit on TS.
     * 
     * @param[in]     RefTS         TS on which to apply call
     * @param[in]     ParityBit     new parity bit for TS
     *
     * @exception TimeOut         when it takes too long to handle the call
     * @exception OpNotSucceeded  when a general failure occurs
     *                            - RefTS invalid
     *                            - ParityBit out of range [0, 1]
     * @exception OpNotAllowed    when not logged on
     * @exception OpNotSupported  when called on mainboard or 
     *                            when call not supported yet on running software
     * 
     * @version release 6.0
     **/
    void SCR_SetParityBit(in IPS_RefTS_t RefTS, in octet ParityBit)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get the parity bit on TS.
     * 
     * @param[in]     RefTS         TS on which to apply call
     * @param[out]    ParityBit     parity bit on TS
     *
     * @exception TimeOut         when it takes too long to handle the call
     * @exception OpNotSucceeded  when a general failure occurs
     *                            - RefTS invalid
     * @exception OpNotAllowed    when not logged on
     * @exception OpNotSupported  when called on mainboard or 
     *                            when call not supported yet on running software
     * 
     * @version release 6.0
     **/
    void SCR_GetParityBit(in IPS_RefTS_t RefTS, out octet ParityBit)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set the operating mode on TS.
     * 
     * @param[in]     RefTS           TS on which to apply call
     * @param[in]     enOperatingMode new operating mode for TS
     * 
     * @exception TimeOut         when it takes too long to handle the call
     * @exception OpNotSucceeded  when a general failure occurs
     *                            - RefTS invalid
     *                            - enOperatingMode out of range
     * @exception OpNotAllowed    when not logged on
     * @exception OpNotSupported  when called on mainboard or 
     *                            when call not supported yet on running software
     * 
     * @version release 8.9
     **/
    void SCR_SetOperatingMode(in IPS_RefTS_t RefTS, in enOperatingMode_t enOperatingMode)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get the operating mode on TS.
     * 
     * @param[in]     RefTS           TS on which to apply call
     * @param[out]    enOperatingMode new operating mode for TS
     *
     * @exception TimeOut         when it takes too long to handle the call
     * @exception OpNotSucceeded  when a general failure occurs
     *                            - RefTS invalid
     * @exception OpNotAllowed    when not logged on
     * @exception OpNotSupported  when called on mainboard or 
     *                            when call not supported yet on running software
     * 
     * @version release 8.9
     **/
    void SCR_GetOperatingMode(in IPS_RefTS_t RefTS, out enOperatingMode_t enOperatingMode)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Start BISS scrambling/descrambling on a TS.
     * 
     * @param[in]     RefTS         TS on which to apply call
     * @param[in]     lstSIDs       list of services (SID) to start BISS scrambling for
     * @param[in]     lstPIDs       list of components (PID) to start BISS scrambling for
     *
     * Depending on the board level scrambling/descrambling mode, this will start 
     * BISS scrambling or BISS descrambling for the specified services.
     *
     * @remark - The setting (SID's to scramble) will be applied no matter what mode
     *           (DVB of BISS) the TS is configured.
     *         - The setting (SID to scramble) will be changed automatically when
     *           the SID of the corresponding service changes.
     *         - the setting (SID to scramble) will be removed automatically when
     *           the corresponding service is removed.
     *
     * @note The parameter lstPIDs is not used so far, but is just present to allow
     *       future extensions (supporting BISS-like component scrambling).
     *
     * @exception TimeOut         when it takes too long to handle the call
     * @exception OpNotSucceeded  when a general failure occurs
     *                            - RefTS invalid
     *                            - invalid SID in list (service not present on TS)
     * @exception OpNotAllowed    when not logged on
     * @exception OpNotSupported  when called on mainboard or 
     *                            when call not supported yet on running software
     * 
     * @version release 6.0
     * @version release 8.0 - action will start BISS descrambling as well
     **/
    void SCR_StartBissScrambling(in IPS_RefTS_t RefTS, in SidList_t lstSIDs, in PidList_t lstPIDs)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Stop BISS scrambling/descrambling on a TS.
     * 
     * @param[in]     RefTS         TS on which to apply call
     * @param[in]     lstSIDs       list of services (SID) to stop BISS scrambling for
     * @param[in]     lstPIDs       list of components (PID) to stop BISS scrambling for
     *
     * Depending on the board level scrambling/descrambling mode, this will stop 
     * BISS scrambling or BISS descrambling for the specified services.
     *
     * @remark An empty list (lstSIDs) will stop scrambling for all services.
     *
     * @note The parameter lstPIDs is not used so far, but is just present to allow
     *       future extensions (supporting BISS-like component scrambling).
     *
     * @exception TimeOut         when it takes too long to handle the call
     * @exception OpNotSucceeded  when a general failure occurs
     *                            - RefTS invalid
     *                            - invalid SID in list (service not present on TS)
     * @exception OpNotAllowed    when not logged on
     * @exception OpNotSupported  when called on mainboard or 
     *                            when call not supported yet on running software
     * 
     * @version release 6.0
     * @version release 8.0 - action will stop BISS descrambling as well
     **/
    void SCR_StopBissScrambling(in IPS_RefTS_t RefTS, in SidList_t lstSIDs, in PidList_t lstPIDs)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get BISS scrambled/descrambled services on a TS.
     * 
     * @param[in]     RefTS         TS on which to apply call
     * @param[out]    lstSIDs       list of services (SID) configured for BISS scrambling
     * @param[out]    lstPIDs       list of components (PID) configured for BISS scrambling
     *
     * Depending on the board level scrambling/descrambling mode, this will return
     * all BISS scrambled or BISS descrambled services.
     *
     * @note The parameter lstPIDs is not used so far, but is just present to allow
     *       future extensions (supporting BISS-like component scrambling).
     *
     * @exception TimeOut         when it takes too long to handle the call
     * @exception OpNotSucceeded  when a general failure occurs
     *                            - RefTS invalid
     * @exception OpNotAllowed    when not logged on
     * @exception OpNotSupported  when called on mainboard or 
     *                            when call not supported yet on running software
     * 
     * @version release 6.0
     * @version release 8.0 - action will return BISS descrambled services as well
     **/
    void SCR_GetBissScrambled(in IPS_RefTS_t RefTS, out SidList_t lstSIDs, out PidList_t lstPIDs)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /// @} end of biss


    /**
     * @defgroup tier_based Tier Based Scrambling
     * This module contains types, enums and methods related to tier based scrambling.
     * @{
     **/

    // ------------------------------------------------------------------------------------
    // Tier based structures & enums
    // ------------------------------------------------------------------------------------

    /// Invalid tier_id
    const unsigned long INVALID_TIER_ID = 0xffffffff;

    /// Scrambling mode
    enum enScramblingMode_V2
    {
      eDvbScrambling_V2,          ///< DVB simulcrypt scrambling
      eBissScrambling_V2,         ///< BISS scrambling (BISS mode 1 and fixed CW)
      eTierBasedScrambling_V2,    ///< Tier based scrambling (share ECM across TS's)
      eScramblingMode_V2_Reserved4,   ///< Reserved for future use
      eScramblingMode_V2_Reserved5,   ///< Reserved for future use
      eScramblingMode_V2_Reserved6    ///< Reserved for future use
    };

    /// Access Criteria
    struct AC_t
    {
      string          Name;       ///< name of AC (extension to Simulcrypt protocol)
      ByteStream      Data;       ///< buffer for AC data (a sequence of chars)
    };

    /// Access criteria for tier based scrambling
    struct TierAC_t
    {
      unsigned long SuperCasId;   ///< SuperCasId of CA system
      AC_t AC;                    ///< Access criteria
    };

    /// Tier data
    struct TierData_t
    {
      unsigned long TierId;       ///< Tier identification
      string TierName;            ///< Name for tier
      sequence<TierAC_t> TierACList;  ///< Access criteria for tier
    };

    /// Tier based settings
    struct TS_Tier_t
    {
      IPS_RefTS_t RefTS;
      unsigned long TierId;
    };

    /// A sequence of TS_Tier_t entries
    typedef sequence<TS_Tier_t> TS_Tier_List_t;

    // ------------------------------------------------------------------------------------
    // Tier based IDL
    // ------------------------------------------------------------------------------------

    /**
     * @brief Set the default scrambling mode.
     * 
     * @param[in]     BoardNr           board number on which to apply call
     * @param[in]     eScramblingMode   default scrambling mode on TS creation
     *
     * @exception TimeOut         when it takes too long to handle the call
     * @exception OpNotSucceeded  when a general failure occurs
     *                            - BoardNr out of range [0, n]
     *                            - eScramblingMode out of range
     * @exception OpNotAllowed    when not logged on
     * @exception OpNotSupported  when called on mainboard or 
     *                            when call not supported yet on running software
     * 
     * @note not implemented yet, so OpNotSupported will always be raised.
     **/
    void SCR_SetDefaultScramblingMode_V2(in unsigned short BoardNr, in enScramblingMode_V2 eScramblingMode)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get the default scrambling mode.
     * 
     * @param[in]     BoardNr           board number on which to apply call
     * @param[out]    eScramblingMode   default scrambling mode on TS creation
     *
     * @exception TimeOut         when it takes too long to handle the call
     * @exception OpNotSucceeded  when a general failure occurs
     *                            - BoardNr out of range [0, n]
     * @exception OpNotAllowed    when not logged on
     * @exception OpNotSupported  when called on mainboard or 
     *                            when call not supported yet on running software
     * 
     * @note not implemented yet, so OpNotSupported will always be raised.
     **/
    void SCR_GetDefaultScramblingMode_V2(in unsigned short BoardNr, out enScramblingMode_V2 eScramblingMode)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Default enable scrambling behavior for services.
     *
     * @param[in]   BoardNr   board number on which to apply call
     * @param[in]   bEnable   enable or disable
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    when a general failure occurs
     *                              - BoardNr out of range
     * @exception OpNotAllowed      when not logged on
     * @exception OpNotSupported    when called on mainboard or
     *                              when call not yet supported on running software version
     *
     * @note not implemented yet, so OpNotSupported will always be raised.
     **/
    void SCR_SetDefaultScramblingEnabled(in unsigned short BoardNr, in boolean bEnable)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get default enable scrambling behavior for services.
     *
     * @param[in]   BoardNr   board number on which to apply call
     * @param[out]  bEnabled  enabled or disabled
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    when a general failure occurs
     *                              - BoardNr out of range
     * @exception OpNotAllowed      when not logged on
     * @exception OpNotSupported    when called on mainboard or
     *                              when call not yet supported on running software version
     *
     * @note not implemented yet, so OpNotSupported will always be raised.
     **/
    void SCR_GetDefaultScramblingEnabled(in unsigned short BoardNr, out boolean bEnabled)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set the scrambling mode on TS.
     * 
     * @param[in]     RefTS             TS on which to apply call
     * @param[in]     eScramblingMode   new scrambling mode for TS
     * 
     * @note Changing the scrambling mode will release all scrambling licenses on 
     *       the TS and will reset the services set for BISS scrambling.
     *       The session word and parity bit on the TS will still remain unchanged.
     *
     * @exception TimeOut         when it takes too long to handle the call
     * @exception OpNotSucceeded  when a general failure occurs
     *                            - RefTS invalid
     *                            - eScramblingMode out of range
     * @exception OpNotAllowed    when not logged on
     * @exception OpNotSupported  when called on mainboard or 
     *                            when call not supported yet on running software
     * 
     * @note not implemented yet, so OpNotSupported will always be raised.
     **/
    void SCR_SetScramblingMode_V2(in IPS_RefTS_t RefTS, in enScramblingMode_V2 eScramblingMode)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get the scrambling mode on TS.
     * 
     * @param[in]     RefTS             TS on which to apply call
     * @param[out]    eScramblingMode   scrambling mode on TS
     *
     * @exception TimeOut         when it takes too long to handle the call
     * @exception OpNotSucceeded  when a general failure occurs
     *                            - RefTS invalid
     * @exception OpNotAllowed    when not logged on
     * @exception OpNotSupported  when called on mainboard or 
     *                            when call not supported yet on running software
     * 
     * @note not implemented yet, so OpNotSupported will always be raised.
     **/
    void SCR_GetScramblingMode_V2(in IPS_RefTS_t RefTS, out enScramblingMode_V2 eScramblingMode)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get list of configured tiers.
     *
     * @param[in]   BoardNr   board on which to apply call
     * @param[out]  TierIds   list of tiers (tier_id)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    when a general failure occurs
     *                              - BoardNr out of range
     * @exception OpNotAllowed      when not logged on
     * @exception OpNotSupported    when called on mainboard or
     *                              when call not yet supported on running software version
     *
     * @note not implemented yet, so OpNotSupported will always be raised.
     **/
    void SCR_GetTierList(in unsigned short BoardNr, out IdList TierIds)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Create tier.
     *
     * @param[in]   BoardNr   board on which to apply call
     * @param[out]  TierId    tier_id (unique identifier) for newly create tier
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    when a general failure occurs
     *                              - BoardNr out of range
     *                              - Maximum number of tiers reached
     * @exception OpNotAllowed      when not logged on
     * @exception OpNotSupported    when called on mainboard or
     *                              when call not yet supported on running software version
     *
     * @note not implemented yet, so OpNotSupported will always be raised.
     **/
    void SCR_CreateTier(in unsigned short BoardNr, out unsigned long TierId)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Delete tier.
     *
     * @param[in]   BoardNr   board on which to apply call
     * @param[in]   TierId    tier_id (unique identifier) of tier to remove
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    when a general failure occurs
     *                              - BoardNr out of range
     *                              - Invalid TierId
     * @exception OpNotAllowed      when not logged on
     * @exception OpNotSupported    when called on mainboard or
     *                              when call not yet supported on running software version
     *
     * @note not implemented yet, so OpNotSupported will always be raised.
     **/
    void SCR_DeleteTier(in unsigned short BoardNr, in unsigned long TierId)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Configure access criteria for tier.
     *
     * @param[in]   BoardNr     board on which to apply call
     * @param[in]   TierData    tier configuration
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    when a general failure occurs
     *                              - BoardNr out of range
     *                              - Invalid TierId
     * @exception OpNotAllowed      when not logged on
     * @exception OpNotSupported    when called on mainboard or
     *                              when call not yet supported on running software version
     *
     * @note not implemented yet, so OpNotSupported will always be raised.
     **/
    void SCR_SetTierData(in unsigned short BoardNr, in TierData_t TierData)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get configured access criteria for tier.
     *
     * @param[in]   BoardNr     board on which to apply call
     * @param[in]   TierId      tier to get configuration for
     * @param[out]  TierData    tier configuration
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    when a general failure occurs
     *                              - BoardNr out of range
     *                              - Invalid TierId
     * @exception OpNotAllowed      when not logged on
     * @exception OpNotSupported    when called on mainboard or
     *                              when call not yet supported on running software version
     *
     * @note not implemented yet, so OpNotSupported will always be raised.
     **/
    void SCR_GetTierData(in unsigned short BoardNr, in unsigned long TierId,
        out TierData_t TierData)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set the default tier.
     *
     * @param[in]   BoardNr   board on which to apply call
     * @param[in]   TierId    default tier on TS creation
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    when a general failure occurs
     *                              - BoardNr out of range
     *                              - Invalid TierId
     * @exception OpNotAllowed      when not logged on
     * @exception OpNotSupported    when called on mainboard or
     *                              when call not yet supported on running software version
     *
     * @note not implemented yet, so OpNotSupported will always be raised.
     **/
    void SCR_SetDefaultTier(in unsigned short BoardNr, in unsigned long TierId)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get the default tier.
     *
     * @param[in]   BoardNr   board on which to apply call
     * @param[out]  TierId    default tier on TS creation (invalid if no tier configured)
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    when a general failure occurs
     *                              - BoardNr out of range
     * @exception OpNotAllowed      when not logged on
     * @exception OpNotSupported    when called on mainboard or
     *                              when call not yet supported on running software version
     *
     * @note not implemented yet, so OpNotSupported will always be raised.
     **/
    void SCR_GetDefaultTier(in unsigned short BoardNr, out unsigned long TierId)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Set tier for TS.
     *
     * @param[in]   RefTS     TS on which to apply call
     * @param[in]   TierId    tier to be applied
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    when a general failure occurs
     *                              - BoardNr out of range
     *                              - Invalid RefTS
     *                              - Invalid TierId
     * @exception OpNotAllowed      when not logged on
     * @exception OpNotSupported    when called on mainboard or
     *                              when call not yet supported on running software version
     *
     * @note not implemented yet, so OpNotSupported will always be raised.
     **/
    void SCR_SetTier(in IPS_RefTS_t RefTS, in unsigned long TierId)
    //void SCR_SetTier(in IPS_Ref_t RefPhys, in TS_Tier_List_t TS_Tier_List)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get tier for TS.
     *
     * @param[in]   RefTS     TS on which to apply call
     * @param[out]  TierId    tier that TS belongs to
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    when a general failure occurs
     *                              - BoardNr out of range
     *                              - Invalid RefTS
     * @exception OpNotAllowed      when not logged on
     * @exception OpNotSupported    when called on mainboard or
     *                              when call not yet supported on running software version
     *
     * @note not implemented yet, so OpNotSupported will always be raised.
     **/
    void SCR_GetTier(in IPS_RefTS_t RefTS, out unsigned long TierId)
    //void SCR_GetTier(in IPS_Ref_t RefPhys, out TS_Tier_List_t TS_Tier_List)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Enable scrambling for service.
     *
     * @param[in]   RefSvc    service to enable/disable scrambling for
     * @param[in]   bEnable   enable or disable
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    when a general failure occurs
     *                              - BoardNr out of range
     *                              - Invalid RefSvc
     * @exception OpNotAllowed      when not logged on
     * @exception OpNotSupported    when called on mainboard or
     *                              when call not yet supported on running software version
     *
     * @note not implemented yet, so OpNotSupported will always be raised.
     **/
    void SCR_SetScramblingEnabled(in IPS_Service_t RefSvc, in boolean bEnable)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /**
     * @brief Get scrambling enabled status for service.
     *
     * @param[in]   RefSvc    service to enable/disable scrambling for
     * @param[out]  bEnabled  enabled or disabled
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    when a general failure occurs
     *                              - BoardNr out of range
     *                              - Invalid RefSvc
     * @exception OpNotAllowed      when not logged on
     * @exception OpNotSupported    when called on mainboard or
     *                              when call not yet supported on running software version
     *
     * @note not implemented yet, so OpNotSupported will always be raised.
     **/
    void SCR_GetScramblingEnabled(in IPS_Service_t RefSvc, out boolean bEnabled)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /// @} end of tier_based


   /** 
    * @defgroup descrambling Descrambling
    * This module contains types, enums and methods related to descrambling on a DRD DVB S2 board.
    * @{
    **/
    
    // ----------------------------------------------
    // ---- Descrambling resource identification ----
    // ----------------------------------------------
    
    /** Identifies a descrambling resource on a board. This id is used to pass services, TS,
     *  EMM's to a descrambling resource. 
     */
    typedef unsigned short DescrId_t; 
    
    /** A list of descrambling resource id's. */
    typedef sequence<DescrId_t> DescrId_List_t;
    
    /** The different descrambling resource types. */
    enum eDescrType_t
    {
      eDescrType_CAM,       ///< DVB descrambling via CAM
      eDescrType_BISS,      ///< BISS descrambling. Usually only one per board.
      eDescrType_Reserved1,
      eDescrType_Reserved2,
      eDescrType_Reserved3
    };
    
    /** Structure containing identification information about the descrambling resource. 
     * All fields are read-only except the Name field.
     */
    struct DescrResource_t
    {
      DescrId_t    DescrId;    ///< "port number" of the descrambler.
      IPS_Ref_t    Ref;        ///< identification of descrambler in all other functions.
      eDescrType_t eDescrType; ///< type of descrambler
      string       Name;       ///< user friendly name of the descrambling resource. Default 
                               ///  names are assigned by the DCM, e.g. 'CAM 1', 'BISS'.
    };
    
    /** A list of DescrResource_t. */
    typedef sequence<DescrResource_t> DescrResource_List_t;
    
    /** Retrieve the list of available descrambling resources for a given board.
     * 
     * @param[in] BoardNr identifies the board.
     * @param[out] DescrResourceList list of availabe descrambling resources.
     * 
     * @exception TimeOut IDL request timed out
     * @exception OpNotAllowed Not logged in.
     * @exception OpNotSupported Board does not support this operation.
     * @exception OpNotSucceeded Processing error.
     *
     * @version Release 9.0 
     */
    void DescrResourceGetL(in unsigned short BoardNr, 
                           out DescrResource_List_t DescrResourceList)
      raises (TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
      
    /** Configure the name of one or more descrambling resources. When an empty string is
     * provided as name, the name will be reverted to the default value.
     *
     * @param[in] BoardNr identifies the board.
     * @param[out] ConfigList list containing the names of the descrambling resources. Only
     *                        the Name field in DescrResource_t is used.
     * 
     * @exception TimeOut IDL request timed out.
     * @exception OpNotAllowed Not logged in.
     * @exception OpNotSupported Board does not support this operation.
     * @exception OpNotSucceeded - Names are not unique across the board.
     *                           - Mismatch between DescrId and Ref.
     *                           - Invalid DescrId or Ref.
     *
     * @version Release 9.0 
     */
    void DescrResourceSetL(in unsigned short BoardNr, in DescrResource_List_t ConfigList)
      raises (TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    // ---------------------------------------------------------
    // ---- Passing Service/TS/EMM to descrambling resource ----
    // ---------------------------------------------------------
     
    /** A structure with attributes of the service routed to the descrambler. */
    struct DescrServiceData_t
    {
      IPS_RefSvc_t  RefSvc;   ///< identifies the service on the descrambler
      ServiceId_t   ServiceID;///< service ID (for future use)
      DvbString_t   UserTag;  ///< a human readible user tag for the service. By default 
                              ///  equal to the name of the input service, but made unique
                              ///  if necessary by @ref DescrServiceAddL(). 
      unsigned long Property; ///< Read only Bitmap used by GUI to display
                              ///< Bit 0: Service present at input (true) or not (false).
                              ///< Bit 1: TRUE if service can't be deleted
                              ///< Bit 2: TRUE if service is scrambled (before descrambling)
                              ///< Bit 3: TRUE if service is being descrambled by descrambler.
                              ///< Bit 4: TRUE if service is in backup
                              ///< Bit 5: TRUE if Service Loss Alarm is active.
                              ///< Bit 6: TRUE if not-descrambled alarm is active.
                              ///< Bit 7: TRUE if service is part of a TS in SFN or TS mode.
                              ///< Other bits for future use. 
      IPS_Service_In_V2_t MainInputService;   ///< main input service
      IPS_Service_In_V2_t ActiveInputService; ///< active input service, e.g. when in backup
    };
    
    /** A list of DescrServiceData_t. */
    typedef sequence<DescrServiceData_t> DescrServiceData_List_t;
    
    /** Add a list of services to a descrambling resource. In case of an error the created 
     *  services list can contain a partial result, e.g. a number of services has been 
     *  created. It is up to the client to implement a roll-back and delete the services if
     *  necessary.
     *
     * @param[in]  DescramblerRef   identifies the descrambling resource.
     * @param[in]  InputRefSvcList  list of RefSvc of the (IO board) input services.
     * @param[out] CreatedServicesL list of created services.
     *
     * @exception TimeOut        a timeout occurred during IIOP processing
     * @exception OpNotSucceeded - invalid references are used
     *                           - one of the input services already has been added.
     *                           - a TS in SFN/TS mode already is added to a CAM descrambling resource.
     *                           - invalid DescrId is provided.
     * @exception OpNotAllowed   not logged in
     * @exception OpNotSupported if board does not support this function.
     *
     * @version Release 9.0 
     */
    void DescrServiceAddL(in IPS_Ref_t DescramblerRef, 
                          in IPS_RefSvc_List_t InputRefSvcList,
                          out IPS_RefSvc_List_t CreatedServicesL)
      raises (TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Removes a list of services from a descrambling resource. 
     *  There can be conditions preventing deletion of the service, such as passed to output,
     *  being part of a TS in SFN/TS mode (and present at the input PAT)...
     *  A property bit in struct DescrServiceData_t indicates whether the service can be deleted.  
     *  This function is executed in a best effort way: services might be deleted partially
     *  in case an error occurs.
     *
     * @param[in] BoardNr    identifies the board.
     * @param[in] RefSvcList a list of services to delete. Use the RefSvc field of the 
     *                       DescrServiceData_t for this purpose.
     *
     * @exception TimeOut        a timeout occurred during IIOP processing
     * @exception OpNotSucceeded - Invalid references are used (RefSvcList).
     *                           - Inconsistency between BoardNr & 
     *                             RefSvcList[x].Ref.PhysRef.BoardNr.
     *                           - The service cannot be deleted, e.g. passed to output.
     * @exception OpNotAllowed   not logged in
     * @exception OpNotSupported if board does not support this function.
     *
     * @version Release 9.0 
     */
    void DescrServiceDeleteL(in unsigned short BoardNr, in IPS_RefSvc_List_t RefSvcList)
      raises (TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get the list of services on a descrambling resource. If a wildcard is used for 
     *  DescramblerRef.PortNr, the RefSvcList should be empty.
     *
     * @param[in] DescramblerRef identifies the descrambling resource. Wildcard allowed.
     * @param[in] RefSvcList     list of RefSvc of the descrambler services for which to 
     *                           return the service data. For an empty list, data of all 
     *                           services are returned. 
     * @param[out] ServiceList   List of ProcServiceDataDescrServiceData_t entries
     *
     * @exception TimeOut        A timeout occurred during IIOP processing
     * @exception OpNotAllowed   not logged in
     * @exception OpNotSupported if board does not support this function.
     * @exception OpNotSucceeded - invalid or inconsistent references are used in RefSvcList.
     *                           - wildcard used for PortNr and RefSvcList is not empty.
     *                           - inconsistency in BoardNr or PortNr between DescramblerRef
     *                             and one of the elements in RefSvcList.
     *
     * @version Release 9.0
     */
    void DescrServiceGetL(in IPS_Ref_t DescramblerRef, in IPS_RefSvc_List_t RefSvcList,
                          out DescrServiceData_List_t ServiceList)
      raises (TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Set service details of services on a descrambler. Only the UserTag is currently 
     *  settable.
     *
     * @param[in] BoardNr         identifies the board.
     * @param[in] ServiceDataList list of DescrServiceData_t specifying the service data
     *                            details for modification.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing
     * @exception OpNotAllowed   not logged in
     * @exception OpNotSupported if board does not support this function.
     * @exception OpNotSucceeded - invalid references are used, UserTag already used,
     *                           - inconsistency between BoardNr and BoardNr in one of the elements 
     *                             of ServiceDataList.
     *
     * @version Release 9.0
     */
    void DescrServiceSetL(in unsigned short BoardNr, 
                          in DescrServiceData_List_t ServiceDataList)
      raises (TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    
    /** Structure with data of a TS added to a descrambler. */
    struct DescrTS_Data_t
    {
      IPS_RefTS_t RefTs;      ///< the TS reference assigned by @ref DescrTS_Add()
      unsigned long Property; ///< Read only Bitmap used by GUI to display
                              ///< Bit 0: TS present at input (true) or not (false).
                              ///< Bit 1: TRUE if TS can't be deleted
                              ///< Bit 2: at least one of the source input PIDs of this
                              ///<        TS is scrambled
                              ///< Bit 3: TRUE if TS Loss Alarm is active.
                              ///< Other bits for future use.
      IPS_RefTS_t RefInputTs; ///< Read only : Reference to the input TS that was used to 
                              ///  create the TS on the descrambler.
      IPS_RefTS_t RefActiveTS;///< Read only : Reference of the active input TS (for TS backup).
      DvbString_t UserTag;    ///< A human readible user tag for the TS. DescrTS_Add will
                              ///  assign a unique default value.
    };

    /** A sequence of DescrTS_Data_t entries. */
    typedef sequence<DescrTS_Data_t> DescrTS_Data_List_t;
    
    /** Structure with data of a TS added to a descrambler.
     *
     * @version Release 12.0
     */
    struct DescrTS_Data_V2_t
    {
      IPS_RefTS_t RefTs;      ///< the TS reference assigned by @ref DescrTS_Add()
      unsigned long Property; ///< Read only Bitmap used by GUI to display
                              ///< Bit 0: TS present at input (true) or not (false).
                              ///< Bit 1: TRUE if TS can't be deleted
                              ///< Bit 2: at least one of the source input PIDs of this
                              ///<        TS is scrambled
                              ///< Bit 3: TRUE if TS Loss Alarm is active.
                              ///< Other bits for future use.
      IPS_RefTS_t RefInputTs; ///< Read only : Reference to the input TS that was used to 
                              ///  create the TS on the descrambler.
      IPS_RefTS_t RefActiveTS;///< Read only : Reference of the active input TS (for TS backup).
      DvbString_t UserTag;    ///< A human readible user tag for the TS. DescrTS_Add will
                              ///  assign a unique default value.
      boolean TransparentSI;  /**< true: pass SI transparently (aka SFN mode)
                                   false: update SI (PMT, SDT, EIT) if descrambled (aka SI mode)
                                   default value is true */
    };
    
    /** A sequence of DescrTS_Data_V2_t entries. */
    typedef sequence<DescrTS_Data_V2_t> DescrTS_Data_List_V2_t;
    
    /** Add a TS to a descrambler. 
     *
     * @param[in]  DescramblerRef  identifies the descrambling resource.
     * @param[in]  RefTsIn         reference of input TS to pass.
     * @param[out] CreatedTs       reference of the created TS.
     *
     * @exception TimeOut        a timeout occurred during IIOP processing
     * @exception OpNotSucceeded - invalid DescramlberRef or RefTsIn.
     *                           - other TS, service or EMM already passed to a CAM.
     *                           - same input TS already passed to the given descrambler.
     * @exception OpNotAllowed   not logged in
     * @exception OpNotSupported if board does not support this function.
     *
     * @version Release 9.10
     */
    void DescrTS_Add(in IPS_Ref_t DescramblerRef,  
                     in IPS_RefTS_t RefTsIn, out IPS_RefTS_t CreatedTs)
      raises (TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Remove one or more TS's from a descrambler. 
     *  The TS can only be deleted if the TS (or part of it) is not passed to an IO board.
     *  This function is executed in a best effort way, meaning that possibly not all 
     *  TS are deleted.
     *
     * @param[in] BoardNr   identifies the board.
     * @param[in] RefTsList list of TS references, as assigned by @ref DescrTS_Add().
     *
     * @exception OpNotSucceeded - Invalid TS reference, TS reference not found.
     *                           - passed to an IO board.
     * @exception OpNotAllowed   not logged in.
     * @exception OpNotSupported if board does not support this function.
     *
     * @version Release 9.10 
     */
    void DescrTS_DeleteL(in unsigned short BoardNr, in IPS_RefTS_List_t RefTsList)
      raises (TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** Get the list of transport streams passed to a descrambler board.
     *
     * @param[in] BoardNr     number of the board.
     * @param[in] RefTsList   list of RefTs of the descrambler services for which to 
     *                        return the TS data. For an empty list, data of all TS's 
     *                        are returned. 
     * @param[out] TsDataList list of DescrTS_Data_t entries.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing
     * @exception OpNotAllowed   not logged in
     * @exception OpNotSupported if board does not support this function.
     * @exception OpNotSucceeded invalid references are used
     *
     * @version Release 9.10
     * @deprecated Since Release 12.0, use DescrTS_GetL_V2 instead
     */
    void DescrTS_GetL(in unsigned short BoardNr, in IPS_RefTS_List_t RefTsList,
                      out DescrTS_Data_List_t TsDataList)
      raises (TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
      
    /** Get the list of transport streams passed to a descrambler board.
     *
     * @param[in] BoardNr     number of the board.
     * @param[in] RefTsList   list of RefTs of the descrambler services for which to 
     *                        return the TS data. For an empty list, data of all TS's 
     *                        are returned. Wildcard is allowed for TS ref.
     * @param[out] TsDataList list of DescrTS_Data_V2_t entries.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing
     * @exception OpNotAllowed   not logged in
     * @exception OpNotSupported if board does not support this function.
     * @exception OperationFailed in case invalid references are used
     *
     * @note 
     * - An empty RefList means all refs.
     * 
     * @version Release 12.0
     */
    void DescrTS_GetL_V2(in unsigned short BoardNr, in IPS_RefTS_List_t RefTsList,
                         out DescrTS_Data_List_V2_t TsDataList)
      raises (TimeOut, OperationFailed, OpNotAllowed, OpNotSupported);
      
    /** Set TS details of one or more TS's on a descrambler. Only the UserTag is currently 
     *  settable.
     *
     * @param[in] BoardNr    identifies the board.
     * @param[in] TsDataList list of TS configuration data.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing
     * @exception OpNotAllowed   not logged in
     * @exception OpNotSupported if board does not support this function.
     * @exception OpNotSucceeded invalid references are used, duplicate UserTags.
     *
     * @version Release 9.10
     * @deprecated Since Release 12.0, user DescrTS_SetL_V2 instead
     */
    void DescrTS_SetL(in unsigned short BoardNr, in DescrTS_Data_List_t TsDataList) 
      raises (TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
      
    /** Set TS details of one or more TS's on a descrambler. 
     *  Only the UserTag and TransparentSI flag are currently settable.
     *
     * @param[in] BoardNr    identifies the board.
     * @param[in] TsDataList list of TS configuration data.
     *
     * @exception TimeOut        A timeout occurred during IIOP processing
     * @exception OpNotAllowed   not logged in
     * @exception OpNotSupported if board does not support this function.
     * @exception OperationFailed invalid references are used, duplicate UserTags.
     *
     * @version Release 12.0
     */
    void DescrTS_SetL_V2(in unsigned short BoardNr, in DescrTS_Data_List_V2_t TsDataList) 
      raises (TimeOut, OperationFailed, OpNotAllowed, OpNotSupported);
      
    
    /** Add one or more EMM to a descrambler. Only CAMs support adding EMMs.
     *
     * @param[in]  DescramblerRef Identifies the descrambler (should be a CAM).
     * @param[in]  EmmList        References of the input EMMs to pass.
     *
     * @exception TimeOut        a timeout occurred during IIOP processing
     * @exception OpNotAllowed   not logged in
     * @exception OpNotSupported if board does not support this function.
     * @exception OpNotSucceeded - invalid references are used.
     *                           - EmmList is empty.
     *                           - DescramblerRef does not correspond to a CAM.
     *                           - EMM already added to CAM.
     *
     * @version Release 9.0 
     */
    void DescrEMM_AddL(in IPS_Ref_t DescramblerRef, in IPS_RefPidList_t EmmList)
      raises (TimeOut, OpNotSucceeded, OpNotSupported, OpNotAllowed);
    
    /** Deletes one or more EMMs routed to a CAM. The EMMs in the list can belong to
     *  different CAMs.
     *  
     *  @param[in] BoardNr identifies the board
     *  @param[in] EmmList references of EMMs to be deleted
     *
     * @exception TimeOut        a timeout occurred during IIOP processing
     * @exception OpNotAllowed   not logged in
     * @exception OpNotSupported if board does not support this function.
     * @exception OpNotSucceeded one of the EMMs was not found, invalid board ref.
     *
     * @version Release 9.0 
     */
    void DescrEMM_DeleteL(in unsigned short BoardNr, in IPS_RefPidList_t EmmList)
      raises (TimeOut, OpNotSucceeded, OpNotSupported, OpNotAllowed);
    
    /** Retrieve the list of EMMs routed to a CAM. 
     *  
     * @param[in]  DescramblerRef identifies the descrambler. Wildcard is allowed.
     * @param[out] EmmList        list of references of found EMMs.
     *
     * @exception TimeOut        a timeout occurred during IIOP processing
     * @exception OpNotAllowed   not logged in
     * @exception OpNotSupported if board does not support this function.
     * @exception OpNotSucceeded - invalid DescramblerRef or not matching descrambler found.
     *
     * @version Release 9.0 
     */
    void DescrEMM_GetL(in IPS_Ref_t DescramblerRef, out IPS_RefPidList_t EmmList)
      raises (TimeOut, OpNotSucceeded, OpNotSupported, OpNotAllowed);
    
    
    // ------------------------------------
    // ---- Descrambling configuration ----
    // ------------------------------------
  
    /** Defines a tracking rule for descrambling, including the BISS session word.
     * The BISS session word is optional, e.g. can be left empty for configuration of 
     * descrambling on a CAM. The session word also can be left empty if the session word
     * is configured on a higher level, e.g. service or TS level. A session word configured
     * on component level overrules any session word on service level or TS level for that
     * specific component.
     */
    struct DescrTrackingRule_t
    {
      TrackingCriterium_t TrackingCriterium; // tracking criterium
      ByteStream EvenSessionWord; ///< session word for BISS descrambling with even parity.
      ByteStream OddSessionWord;  ///< session word for BISS descrambling with odd parity.  
    };

    /** A sequence of DescrTrackingRule_t. */
    typedef sequence<DescrTrackingRule_t> DescrTrackingRuleList_t;
    
    /** Represents how a service needs to be descambled. */
    enum eDescrEnabledMode_t
    {
      eDescrEnabledMode_Disabled, ///< Descrambling disabled
      eDescrEnabledMode_Service,  ///< Service level descrambling enabled
      eDescrEnabledMode_Component,///< Component level descrambling enabled
      eDescrEnabledMode_Reserved1,
      eDescrEnabledMode_Reserved2,
      eDescrEnabledMode_Reserved3
    };
    
    /** Defines how the service is descrambled. The session words are only required for
     * BISS descrambling and when the session word is configured on service level. The
     * session word on service level overrules the session word on TS level, but only 
     * for the service (identified by RefSvc).
     */
    struct DescrSvcConfig_t
    {
      IPS_RefSvc_t            RefSvc;   ///< identifies the virtual service
      eDescrEnabledMode_t     eEnabled; ///< identifies if and how descrambling must be done
      boolean                 bCamBuTrigger; ///< true: when not descrambled, this service
                                             //   triggers CAM backup (if CAM backup enabled).
      ByteStream              EvenSessionWord; ///< session word for BISS with even parity.
      ByteStream              OddSessionWord;  ///< session word for BISS with odd parity.  
      DescrTrackingRuleList_t Components; ///< non-empty if component level descrambling
    };
    
    typedef sequence<DescrSvcConfig_t> DescrSvcConfig_List_t;
    
    /** Start descrambling on services / components on the specified virtual TS.
     * 
     * @param[in] BoardNr    identifies the board
     * @param[in] ConfigList list of descrambling configurations per service
     *
     * @exception TimeOut        request timed out.
     * @exception OpNotAllowed   not logged on.
     * @exception OpNotSupported board does not support the operation.
     * @exception OpNotSucceeded - if ConfigList contains invalid reference or Pid.
     *                           - if an error occurred during configuration of descrambling.
     *                           - if comp. level descrambling is configured with empty list.
     *                           - if invalid or unsupported tracking criterium is provided.
     *
     * @version Release 9.0 
     */
    void DescrSvcConfigSetL(in unsigned short BoardNr, in DescrSvcConfig_List_t ConfigList)
      raises (TimeOut, OpNotAllowed, OpNotSupported, OpNotSucceeded);
    
    /** Returns the services / PIDs for which descrambling is configured. If a wildcard is
     *  used for DescramblerRef.PortNr, the SvcFilter should be empty.
     * 
     * @param[in]  DescramblerRef identifies the descrambler. Wildcard allowed.
     * @param[in]  SvcFilter      if non-empty, limit result to services in this list. 
     * @param[out] ConfigList     list of descrambling configurations per service.
     *
     * @exception TimeOut        request timed out.
     * @exception OpNotAllowed   not logged in
     * @exception OpNotSupported if board does not support this function.
     * @exception OpNotSucceeded - invalid DescramblerRef or no matching descrambler found.
     *                           - invalid reference in SvcFilter.
     *                           - inconsistency in PortNr between DescramblerRef and 
     *                             element in SvcFilter.
     *                           - wildcard for DescramblerRef.PortNr & SvcFilter not empty. 
     *
     * @version Release 9.0 
     */
    void DescrSvcConfigGetL(in IPS_Ref_t DescramblerRef,  
                            in IPS_RefSvc_List_t SvcFilter, 
                            out DescrSvcConfig_List_t ConfigList)
      raises (TimeOut, OpNotAllowed, OpNotSupported, OpNotSucceeded);
    
    
    
    // ---------------------------
    // ---- CAM configuration ----
    // ---------------------------
    
    /** Defines the configuration of the CAM itself. 
     */
    struct DescrCAM_Cfg_t
    {
      IPS_Ref_t      CamRef;          ///< CAM identification
      boolean        bEnabledSetting; ///< true: enable CAM. requires a license to enable.
      boolean        bEnabledStatus;  ///< readonly enabled status. Can be different from 
                                      ///  enabled setting if e.g. after reboot the necessary
                                      ///  licenses are missing.
      boolean        bResetOnFailure; ///< true: reset CAM if descrambling fails on all services
                                      ///  False: do not reset. Default value is true.
      unsigned short MaxBitRate;      ///< In Mbps. Range: 72 .. 200. Default: 72
    };
    
    typedef sequence<DescrCAM_Cfg_t> DescrCAM_Cfg_List_t;

    /** Represents how CA PMT lists need to be updated towards the CAM. */
    enum eCaPmtListManagement_t
    {
      eCaPmtListManagement_AddDelete, ///< Update (add/delete) single CA PMT only
      eCaPmtListManagement_UpdateAll, ///< Update all CA PMT's
      eCaPmtListManagement_Reserved1,
      eCaPmtListManagement_Reserved2,
      eCaPmtListManagement_Reserved3
    };
    
    /** Defines the configuration of the CAM itself. 
     */
    struct DescrCAM_Cfg_V2_t
    {
      IPS_Ref_t      CamRef;          ///< CAM identification
      boolean        bEnabledSetting; ///< true: enable CAM. requires a license to enable.
      boolean        bEnabledStatus;  ///< readonly enabled status. Can be different from 
                                      ///  enabled setting if e.g. after reboot the necessary
                                      ///  licenses are missing.
      boolean        bResetOnFailure; ///< true: reset CAM if descrambling fails on all services
                                      ///  False: do not reset. Default value is true.
      unsigned short MaxBitRate;      ///< In Mbps. Range: 72 .. 200. Default: 72
      eCaPmtListManagement_t CaPmtListManagement; ///< CA PMT list menagement for updates towards CAM
    };
    
    typedef sequence<DescrCAM_Cfg_V2_t> DescrCAM_Cfg_List_V2_t;

    /** Configures one or more CAMs. Enabling a CAM requires a license. If the license is
     *  not available, a LicenseError is returned and the CAM setting stays disabled.
     *  Note: when licenses are reduced and the DCM is rebooted, only CAMs for which a
     *  license is available will be enabled. The enabled setting is still enabled in that
     *  case but the enabled status will be disabled and a license alarm is triggered. 
     *  Disabling the CAM will clear the license alarm.
     *  This function is executed in a best-effort way (up to the first encountered error). 
     * 
     * @param[in] BoardNr    identifies the board
     * @param[in] ConfigList list of CAM configurations
     *
     * @exception TimeOut        request timed out.
     * @exception OpNotAllowed   not logged in
     * @exception OpNotSupported if board does not support this function.
     * @exception OpNotSucceeded - invalid parameters in ConfigList.
     *                           - invalid CamRef in ConfigList.
     * @exception LicenseError   CAM license not available.
     *
     * @version Release 9.0 
     * @deprecated Since release 12.0, use DescrCAM_CfgSetL_V2 instead
     */
    void DescrCAM_CfgSetL(in unsigned short BoardNr, in DescrCAM_Cfg_List_t ConfigList)
      raises (TimeOut, OpNotAllowed, OpNotSupported, OpNotSucceeded, LicenseError);

    /** Configures one or more CAMs. Enabling a CAM requires a license. If the license is
     *  not available, a LicenseError is returned and the CAM setting stays disabled.
     *  Note: when licenses are reduced and the DCM is rebooted, only CAMs for which a
     *  license is available will be enabled. The enabled setting is still enabled in that
     *  case but the enabled status will be disabled and a license alarm is triggered. 
     *  Disabling the CAM will clear the license alarm.
     *  This function is executed in a best-effort way (up to the first encountered error). 
     * 
     * @param[in] BoardNr    identifies the board
     * @param[in] ConfigList list of CAM configurations
     *
     * @exception TimeOut        request timed out.
     * @exception OpNotAllowed   not logged in
     * @exception OpNotSupported if board does not support this function.
     * @exception OpNotSucceeded - invalid parameters in ConfigList.
     *                           - invalid CamRef in ConfigList.
     * @exception LicenseError   CAM license not available.
     *
     * @version Release 12.0 
     */
    void DescrCAM_CfgSetL_V2(in unsigned short BoardNr, in DescrCAM_Cfg_List_V2_t ConfigList)
      raises (TimeOut, OpNotAllowed, OpNotSupported, OpNotSucceeded, LicenseError);

    /** Retrieves the configuration of one or more CAMs.
     * 
     * @param[in]  CamRef      identifies the CAM. Wildcard is allowed.
     * @param[out] ConfigList  CAM configuration list (only CAMs included).
     *
     * @exception TimeOut        request timed out.
     * @exception OpNotAllowed   not logged in
     * @exception OpNotSupported if board does not support this function.
     * @exception OpNotSucceeded - invalid CamRef.
     *                           - no CAM found for given CamRef.
     *
     * @version Release 9.0 
     * @deprecated Since release 12.0, use DescrCAM_CfgGetL_V2 instead
     */
    void DescrCAM_CfgGetL(in IPS_Ref_t CamRef, out DescrCAM_Cfg_List_t ConfigList)
      raises (TimeOut, OpNotAllowed, OpNotSupported, OpNotSucceeded);
    
    /** Retrieves the configuration of one or more CAMs.
     * 
     * @param[in]  CamRef      identifies the CAM. Wildcard is allowed.
     * @param[out] ConfigList  CAM configuration list (only CAMs included).
     *
     * @exception TimeOut        request timed out.
     * @exception OpNotAllowed   not logged in
     * @exception OpNotSupported if board does not support this function.
     * @exception OpNotSucceeded - invalid CamRef.
     *                           - no CAM found for given CamRef.
     *
     * @version Release 12.0 
     */
    void DescrCAM_CfgGetL_V2(in IPS_Ref_t CamRef, out DescrCAM_Cfg_List_V2_t ConfigList)
      raises (TimeOut, OpNotAllowed, OpNotSupported, OpNotSucceeded);
    
    
    /** Structure used to configure CAM backup.
     * Currently the backup trigger is not configurable. Service not descrambled condition
     * is used to trigger CAM backup. Which services can trigger CAM backup is configured
     * in DescrSvcConfig_t. 
     */
    struct DescrCAM_BackupCfg_t
    {
      IPS_Ref_t      MainCAM;     ///< reference of the main CAM
      boolean        bEnabled;    ///< true: backup enabled, false: backup disabled
      IPS_Ref_t      BackupCAM;   ///< reference of the backup CAM
      IPS_Ref_t      ActiveCAM;   ///< active CAM (can also be used to revert to MAIN CAM)
      unsigned long  BackupDelay; ///< delay to switch from a failing CAM to the backup
      unsigned long  BackupTrigger; ///< bitmap containing the backup triggers.
                                    ///  Bit0: service not descrambled.
                                    ///  other bits for future use.
    };
    
    /** A sequence of DescrCAM_BackupCfg_t. */
    typedef sequence<DescrCAM_BackupCfg_t> DescrCAM_BackupCfg_List_t;
    
    /** Set backup configuration for one or more CAM pairs. If backup is enabled, the main 
     *  and backup CAM function effectively as a CAM pair. The main CAM is used to pass
     *  TS, services and EMMs to. 
     *  Main and backup CAM reside on the same front-end. The first CAM is the main CAM and
     *  the second CAM is the backup CAM, similar to GbE port pairs. 
     *  Backup will always be done in a non-revertive way: once switched to the backup CAM,
     *  the main CAM can only be activated manually.
     *  Disabling CAM backup lets each CAM work individually again, hence disables the pair
     *  mode.
     *  
     * @param[in] BoardNr       identifies the board.
     * @param[in] BackupConfigL list of backup configurations.
     *
     * @exception TimeOut        request timed out.
     * @exception OpNotAllowed   not logged on.
     * @exception OpNotSucceeded - if wrong or an invalid combination of CAMs are provided.
     *                           - if backup CAM already has TS, services, EMMs routed to it.
     *                           - if MainCAM is not the first CAM on the front-end.
     * @exception OpNotSupported board does not support the operation.
     *
     * @version Release 9.0 
     */
    void DescrCAM_BackupCfg_SetL(in unsigned short BoardNr, 
                                 in DescrCAM_BackupCfg_List_t BackupConfigL)
      raises (TimeOut, OpNotAllowed, OpNotSupported, OpNotSucceeded);
    
    /** Retrieve the CAM backup configuration for the given board.
     *
     * @param[in]  BoardNr       identifies the board.
     * @param[out] BackupConfigL list of configuration of CAM pairs.
     *
     * @exception TimeOut        request timed out.
     * @exception OpNotAllowed   not logged on.
     * @exception OpNotSupported board does not support the operation.
     * @exception OpNotSucceeded An error occurred.
     *
     * @version Release 9.0 
     */
    void DescrCAM_BackupCfg_GetL(in unsigned short BoardNr, 
                                 out DescrCAM_BackupCfg_List_t BackupConfigL)
      raises (TimeOut, OpNotAllowed, OpNotSupported, OpNotSucceeded);
    
    /** Structure containing information about a CAM. */
    struct DescrCAM_Status_t
    {
      IPS_Ref_t        CamRef;          ///< CAM identification
      boolean          bReady;          ///< initialized and ready for descrambling
      string           SystemName;      ///< system name
      unsigned short   ManufacturerId;  ///< manufacturer id
      unsigned short   ManufactureCode; ///< manufacture code
      string           CamSerialNr;     ///< CAM serial number
      sequence<string> CaSystemId;      ///< supported CA System Ids
      string           HwVersion;       ///< CAM hardware version
      string           AppVersion;      ///< CAM software version
      string           CompanyName;     ///< CAM company name
      string           ProductName;     ///< CAM product name
    };
    
    /** A sequence of DescrCAM_Status_t. */
    typedef sequence<DescrCAM_Status_t> DescrCAM_Status_List_t;
    
    /** Retrieves the CAM status and other information.
     * 
     * @param[in]  CamRef     identifies the CAM. Wildcard is allowed.
     * @param[out] StatusList list of status information.
     *
     * @exception TimeOut        request timed out.
     * @exception OpNotAllowed   not logged in
     * @exception OpNotSupported if board does not support this function.
     * @exception OpNotSucceeded invalid CamRef provided or no matching CAM found.
     *
     * @version Release 9.0 
     */
    void DescrCAM_Status_GetL(in IPS_Ref_t CamRef, out DescrCAM_Status_List_t StatusList)
      raises (TimeOut, OpNotAllowed, OpNotSupported, OpNotSucceeded);
    
    /** Sends a command to the command line interface of a CAM. Commands are CAM specific.
     *  Request is string where command and parameters are separated by SPACE.
     *  Response is a string, including in EOL markers.
     *  Supported commands:
     *  - menu            description : open a menu on a CAM
     *  - choice [param]  description : make a menu choice
     *  - close           description : close the menu
     * 
     * @param[in]  CamRef   Identifies the CAM.
     * @param[in]  Request  The request string to send to the CAM.
     * @param[out] Response The response of the CAM.
     * 
     * @exception TimeOut        request timed out.
     * @exception OpNotAllowed   not logged in.
     * @exception OpNotSupported if board does not support this function.
     * @exception OpNotSucceeded invalid CamRef provided or no matching CAM found.
     *
     * @version Release 9.10 
     */
    void DescrCAM_CI_MMI_CLI_Cmd(in IPS_Ref_t CamRef, in string Request, out string Response)
      raises (TimeOut, OpNotAllowed, OpNotSupported, OpNotSucceeded);

    /** Resets the CAM.
     * 
     * @param[in] CamRef Identifies the CAM.
     * 
     * @exception TimeOut        request timed out.
     * @exception OpNotAllowed   not logged in.
     * @exception OpNotSupported if board does not support this function.
     * @exception OpNotSucceeded invalid CamRef provided or no matching CAM found.
     *
     * @version Release 9.0
     */
    void DescrCAM_Reset(in IPS_Ref_t CamRef)
      raises (TimeOut, OpNotAllowed, OpNotSupported, OpNotSucceeded);
    
    // ----------------------------
    // ---- BISS configuration ----
    // ----------------------------
    
    /** Configuration of BISS descrambling. Currently either an even or add session word
     *  can be provided (BISS-1 has a fixed parity). The unused parity is determined by
     *  leaving the session word for that parity empty. This structure only can be used
     *  to set the BISS session word on TS level. Configuration of session words on 
     *  service level or component level is done via @ref DescrSvcConfigSetL(). 
     */
    struct DescrBISS_Cfg_t
    {
      IPS_RefTS_t RefTS;       ///< reference of the TS on the BISS descrambler.
      ByteStream  EvenSessionWord; ///< session word for BISS descrambling with even parity.
      ByteStream  OddSessionWord;  ///< session word for BISS descrambling with odd parity.
    };
        
    /** A sequence of DescrBISS_Cfg_t. */
    typedef sequence<DescrBISS_Cfg_t> DescrBISS_Cfg_List_t;
    
    /** Configure BISS descrambling on the DRD board. This consists of defining the session
     *  word for BISS descrambling. Currently the session word can only be set per TS.
     * 
     * @param[in] BoardNr        identifies the board
     * @param[in] BissConfigList list of configuration data
     *
     * @exception TimeOut        request timed out.
     * @exception OpNotAllowed   not logged on.
     * @exception OpNotSupported board does not support the operation.
     * @exception OpNotSucceeded - invalid RefTS provided in BissConfigList (e.g. not BISS).
     *                           - invalid SessionWord in BissConfigList (e.g. wrong length).
     *
     * @version Release 9.10 
     */
    void DescrBISS_CfgSetL(in unsigned short BoardNr, in DescrBISS_Cfg_List_t BissConfigList)
      raises (TimeOut, OpNotAllowed, OpNotSupported, OpNotSucceeded);
    
    /** Retrieve BISS descrambling configuration on the DRD board for one or more transport
     *  streams. If a wildcard is used for BissRef, the RefTsFilter should be empty.
     * 
     * @param[in]  BissRef        identifies the BISS descrambler. Wildcard is allowed.
     * @param[in]  RefTsFilter    if not empty, filter result on list of TS references.
     * @param[out] BissConfigList list of configuration data
     *
     * @exception TimeOut        request timed out.
     * @exception OpNotAllowed   not logged on.
     * @exception OpNotSupported board does not support the operation.
     * @exception OpNotSucceeded - invalid reference in RefTsFilter.
     *                           - TS ref in RefTsFilter not consistent with BissRef.
     *                           - Wildcard used in BissRef but RefTsFilter not empty.
     *
     * @version Release 9.10
     */
    void DescrBISS_CfgGetL(in IPS_Ref_t BissRef, 
                           in IPS_RefTS_List_t RefTsFilter,
                           out DescrBISS_Cfg_List_t BissConfigList)
      raises (TimeOut, OpNotAllowed, OpNotSupported, OpNotSucceeded);
    

    /// @} end of descrambling
   
   
    /**
     * @defgroup sub_table_passing SI sub table passing
     * This module contains types, enums and methods related to SI sub table passing.
     * @{
     **/

    /**
     * @brief Create a list of OutputSiSubTables on one OutTs.
     *
     * @param[in] OutTs specifies BoardNr, PortNr.and TS
     * @param[in] TableGenerationDataList: list of output table settings
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when call not yet supported on running software version
	 * @exception LicenseError      when the appropriate license is not installed
     *
     * @version release 6.0
	 * @version release 7.1 	support for EITpfa to EITpfo conversion
     **/
    void CreateOutputSI_Tables(in IPS_RefTS_t OutTs, in TableGenerationDataList_t TableGenerationDataList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);


    /**
     * @brief delete a list of OutputSiSubTable on one OutTs.
     *
     * @param[in] OutTs specifies BoardNr, PortNr.and TS
     * @param[in] TableRefList: list of output TableRefs to be deleted
     *
     * @exception TimeOut           a timeout occurred during IIOP processing
     * @exception OpNotSucceeded    internal error only
     * @exception OpNotAllowed      not logged on
     * @exception OpNotSupported    when call not yet supported on running software version
     *
     * @version release 6.0
     **/
    void DeleteOutputSI_Tables(in IPS_RefTS_t OutTs, in TableKeys_List_t TableRefList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /// @} end of sub_table_passing 


   
    // MUX
    // ------------------------------------------------------------------------------------

    /** @addtogroup mux Multiplexing
     * This contains types, enums and methods to configure the multiplexer part of the device.
     * @{
     */

    /** @addtogroup ts TS
     * This contains types, enums and methods to configure the TSs of the multiplexer part in the device.
     * @{
     */
    
    typedef sequence<enOperatingMode_t> OperatingMode_List_t;

    /**
     * @brief Get a filtered list of outgoing transport streams and theis parameters.
     *
     * @param[in] RefPhys The BoardNr and PortNr you want information about.
     * @param[in] RefList A sequence of Ref's you want info about.
     * @param[in] ScrambledOnly Return only TS's where scrambling of services can be done
     * @param[in] OperatingModes Return only TS's with provided operating mode
     * @return An IPS_OutputTS_List_V2_t list, a sequence of IPS_OutputTS_V2_t entries.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case invalid references (RefPhys, RefList) are used.
     * @exception OpNotSupported In case invalid enumeration value is used
     *
     * @note
     * - A value of 0xFFFF for port means all ports.
     * - An empty list means all refs.
     * - An empty OperatingModes list means all operating modes
     *
     * @version  Release 8.9
     **/
    IPS_OutputTS_List_V2_t IPS_OutTS_GetFilteredL_V3(in IPS_Ref_t RefPhys, in Ref_List_t RefList, in boolean ScrambledOnly, in OperatingMode_List_t OperatingModes)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /// @} end of ts

    /// @} end of mux
   

    // EAS
    // ------------------------------------------------------------------------------------

    /** 
    * @defgroup eas EAS
    * This module contains types, enums and methods related to the EAS module.
    * @{
    **/
    
    /**
     * @brief Create an EAS proxy.
     *
     * @param[out] EasId  proxy_id of newly created EAS proxy
     *
     * @exception TimeOut           a timeout occurred during IIOP processing.
     * @exception OpNotSucceeded    internal error, such as max. number of proxies reached.
     * @exception OpNotAllowed      not logged on.
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version.
     *
     * @version release 8.5
     **/
    void CreateEas(out unsigned long EasId)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /**
     * @brief Delete an EAS proxy. En EAS proxy can only be deleted if it is not used by any of the 
     * output transport streams.
     *
     * @param[in] EasId  proxy_id of EAS proxy to delete
     *
     * @exception TimeOut           a timeout occurred during IIOP processing.
     * @exception OpNotSucceeded    EAS proxy still in use, no EAS proxy found matching the EasId.
     * @exception OpNotAllowed      not logged on.
     * @exception OpNotSupported    when called on other board than the mainboard or
     *                              when call not yet supported on running software version.
     *
     * @version release 8.5
     **/
    void DeleteEas(in unsigned long EasId)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
    
    /** 
     * @brief Represents the protocol used by the EAS proxy.
     */
    enum enumEasProtocol_t
    {
      eEasProtocol_SCTE18,     ///< protocol = SCTE18 CEAM section.
      eEasProtocol_CAP12,      ///< protocol = CAP1.2 XML (not yet supported).
      eEasProtocol_Reserved1,  ///< for future use 
      eEasProtocol_Reserved2,  ///< for future use
      eEasProtocol_Reserved3,  ///< for future use
      eEasProtocol_Reserved4,  ///< for future use
      eEasProtocol_Reserved5   ///< for future use
    };

    /**
     * @brief Represents the socket type.
     */
    enum enumEasSocketType_t
    {
      eEasSocketType_UDP_Unicast,   ///< Unicast UDP
      eEasSocketType_UDP_Multicast, ///< Multicast UDP
      eEasSocketType_UDP_Broadcast, ///< Broadcast UDP
      eEasSocketType_Reserved1,     ///< for future use 
      eEasSocketType_Reserved2,     ///< for future use 
      eEasSocketType_Reserved3,     ///< for future use 
      eEasSocketType_Reserved4,     ///< for future use 
      eEasSocketType_Reserved5      ///< for future use 
    };
    
    /**
     * @brief Represents the configuration of an EAS proxy.
     */
    struct EasConfig_t 
    {
      unsigned long       EasId; ///< Identifies the EAS proxy.
      IPS_Ref_t           NetworkInterface; ///< Specify BoardNr = 0 and PortNr = 0 for the 10/100 management network interface 
                                            ///  and PortNr = 1 for the GbE CA network interface.
      unsigned short      UdpPort; ///< UDP port number the EAS proxy is listening on. When not yet
                                   ///  yet configured UdpPort will be 0, meaning that the EAS proxy is 
                                   ///  not listening on a socket. UdpPorts are unique per network interface.
      string              Name;  ///< a user friendly name identifying the proxy. Names must be unique. 
                                 ///  Upper/lower case and white space are ignored in the uniqueness check.
      IPS_RefTS_t         RefTs; ///< (Read-only) TS reference assigned to the newly created EAS proxy.
                                 ///  This TS reference is to be used in the the SetSI_Generation call.
                                 ///  Note: the client SW should not make any assumptions on how the RefTs
                                 ///  is generated. The only assurance is that the same RefTs will be
                                 ///  assigned after a reboot.
      enumEasProtocol_t   Protocol;      ///< protocol used by EAS proxy.
      boolean             bTextCrawl;    ///< enable participation of the proxy in text crawl generation.
      enumEasSocketType_t eSocketType;   ///< the type of socket. In case of multicast, also the IP_Addr field must be filled in.
      string              IP_Addr;       ///< IP address in case of multicast. 
      unsigned short      UsageBitmap;   ///< (Read-only) bitmap showing the I/O boards using the proxy.
                                         ///  bit0 = main board, bit1 = I/O board 1, bit2 = I/O board 2, etc.
    };
    
    /// A sequence of EAS proxy configurations.
    typedef sequence<EasConfig_t> EasConfigList_t;
    
    /**
     * @brief Set EAS proxy configuration settings for one EAS proxy. The EasId field in the EasConfig
     * structure will be used to lookup the EAS proxy. 
     * 
     * @param[in] EasConfig       contains the EasId and the settings of the EAS proxy.
     *
     * @exception TimeOut         a timeout occurred during IIOP processing.
     * @exception OpNotSucceeded  invalid parameters, eg. No EAS proxy for given EAS id, duplicate name,
     *                            invalid IP_Addr, invalid udp port, specified udp port in use, etc. 
     * @exception OpNotAllowed    not logged on.
     * @exception OpNotSupported  when called on other board than the mainboard or
     *                            when call not yet supported on running software version.
     *
     * @version release 8.5
     **/
    void SetEasConfig(in EasConfig_t EasConfig)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    
    /**
     * @brief Get EAS proxy configuration settings.
     *
     * @param[in]  EasIds        Identifies which EAS proxies to retrieve. If the provided list is empty,
     *                           all EAS proxies are retrieved.
     * @param[out] EasConfigList List of EAS proxy configurations. This list can be empty if no EAS
     *                           proxies are created all proxies are requested. If a specific EAS proxy 
     *                           is requested but not found, the function returns OpNotSucceeded.
     *
     * @exception TimeOut         a timeout occurred during IIOP processing.
     * @exception OpNotSucceeded  invalid EasId, no EAS proxy for given (specific) EasId.
     * @exception OpNotAllowed    not logged on.
     * @exception OpNotSupported  when called on other board than the main board.
     *
     * @version release 8.5
     **/
    void GetEasConfigL(in IdList EasIds, 
                       out EasConfigList_t EasConfigList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /// @} end of EAS
#endif // DISABLE_SCR
#ifndef DISABLE_SFN

    /** @defgroup asi_sfn ASI-SFN
     * This contains types, enums and methods to configure SFN specific functionality of an ASI-SFN board.
     * @{
     */

    enum enGPS_ClockImpedance
    {
      eHighImpedant,
      e50Ohm
    };

    enum enGPS_1PPS_SliceLevel
    {
      eAutomaticDetection,
      eManualSetting
    };

    enum enGPS_1PPS_Edge
    {
      eRisingEdge,
      eFallingEdge
    };

    enum enGPS_10MHz_Invert
    {
      eNotInverted,
      eInverted
    };

    enum enGPS_LED
    {
      eLED_Off,
      eLED_On
    };
    
    struct GPS_Settings_t
    {
      enGPS_ClockImpedance    eGPS_1PPS_Impedance;
      enGPS_ClockImpedance    eGPS_10MHz_Impedance;
      enGPS_1PPS_SliceLevel   eGPS_1PPS_SliceLevel;
      unsigned long           ui1PPS_SliceLevel;     ///< value in mV, range 0..5000mV, steps of 50mV
      enGPS_1PPS_Edge         eGPS_1PPS_Edge;
      enGPS_10MHz_Invert      eGPS_10MHz_Invert;
      // enGPS_LED               eGPS_LED_1PPS;
      // enGPS_LED               eGPS_LED_10MHz;
    };    
    
    enum enSFN_Mode
    {
      eSFN_Disable,
      eSFN_Enable
    };

    enum enConstellation
    {
      eQPSK,
      e16_QAM,
      e64_QAM
    };
    
    enum enHierarchyAndInterleaving
    {
      eNonHierarchical,
      eAlpha1,
      eAlpha2,
      eAlpha4
    };
    
    enum enCodeRate
    {
      e1_Over_2,
      e2_Over_3,
      e3_Over_4,
      e5_Over_6,
      e7_Over_8
    };
    
    enum enGuardInterval
    {
      e1_Over_32,
      e1_Over_16,
      e1_Over_8,
      e1_Over_4
    };
    
    enum enFFT_Mode
    {
      e2K_Mode,
      e8K_Mode
    };
    
    enum enChannelBandwidth
    {
      e7_MHz,
      e8_MHz,
      e6_MHz
    };
    
    enum enTS_Priority
    {
      eLowPriorityTS,
      eNonHierarchicalOrHighPriorityTS
    };
    
    enum enDVB_H_Timeslicing
    {
      eNoTimeSlicing,
      eTimeSlicing          ///< used by at least one elementary stream
    };
    
    enum enDVB_H_MPE_FEC
    {
      eMPE_FEC_NotUsed,
      eMPE_FEC_Used         ///< used by at least one elementary stream
    };
    
    struct MIP_Settings_t
    {
      unsigned long               uiMaximumDelay;              ///< value in 100ns, range 0..1s
      enConstellation             eConstellation;
      enHierarchyAndInterleaving  eHierarchyAndInterleaving;
      enCodeRate                  eCodeRate;
      enGuardInterval             eGuardInterval;
      enFFT_Mode                  eFFT_Mode;
      enChannelBandwidth          eChannelBandwidth;
      enTS_Priority               eTS_Priority;
      enDVB_H_Timeslicing         eDVB_H_Timeslicing;
      enDVB_H_MPE_FEC             eDVB_H_MPE_FEC;
    };
    
    struct GPS_Status_t
    {
      boolean                     bStatus10MHz;
      boolean                     bStatus1PPS;
      unsigned short              us1PpsLevelMin;       //< Minimum 1PPS level, averaged over 8 seconds
      unsigned short              us1PpsLevelMax;       //< Maximum 1PPS level, averaged over 8 seconds
      unsigned short              us1PpsLevelSlice;     //< Slice level as applied to the DA-converter
    };

    // ASI IDLs
    // ------------------------------------------------------------------------------------

    /** Get the configuration of the GPS ports (10MHz and 1PPS)
     *
     * @param[in] BoardNr Specifies the BoardNr
     * @param[out] GpsSettings Configuration of the GPS ports
     *
     * @exception OpNotSupported When called for non-ASI-SFN boards
     *
     * @version Release 6.9
     */
    void ASI_SFN_GetGpsSettings(in unsigned short BoardNr, out GPS_Settings_t GpsSettings)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the configuration of the GPS ports (10MHz and 1PPS)
     *
     * @param[in] BoardNr Specifies the BoardNr
     * @param[in] GpsSettings Configuration of the GPS ports
     *
     * @exception OpNotSupported When called for non-ASI-SFN boards
     *
     * @version Release 6.9     
     */
    void ASI_SFN_SetGpsSettings(in unsigned short BoardNr, in GPS_Settings_t GpsSettings)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
        
    /** Get the status of the GPS ports (10MHz and 1PPS)
     *
     * @param[in] BoardNr Specifies the BoardNr
     * @param[out] GpsStatus Status of 10MHz and 1PPS clock and values of 1PPS Level (min/max/slice)
     *
     * @remark Should only be used for testing purposes. It may influence mechanism to detect GPS status changes! 
     *
     * @exception OpNotSupported When called for non-ASI-SFN boards
     *
     * @version Release 6.9     
     */
    void ASI_SFN_GetGpsStatus(in unsigned short BoardNr, out GPS_Status_t GpsStatus)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);    

    /** Get the parameters of a MIP packet
     *
     * @param[in] RefTsOut The output TS
     * @param[out] MipSettings Parameters of a MIP packet
     *
     * @exception OpNotSupported When called for non-ASI-SFN boards
     *
     * @version Release 6.9
     */
    void ASI_SFN_GetMipSettings(in IPS_RefTS_t RefTsOut, out MIP_Settings_t MipSettings)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the parameters of a MIP packet
     *
     * @param[in] RefTsOut The output TS
     * @param[in] MipSettings Parameters of a MIP packet
     *
     * @exception OpNotSupported When called for non-ASI-SFN boards
     *
     * @version Release 6.9     
     */
    void ASI_SFN_SetMipSettings(in IPS_RefTS_t RefTsOut, in MIP_Settings_t MipSettings)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Get the SFN mode (SFN enabled/disabled)
     *
     * @param[in] RefTsOut The output TS
     * @param[out] eSFN_Mode SFN mode (SFN enabled/disabled)
     *
     * @exception OpNotSupported When called for non-ASI-SFN boards
     *
     * @version Release 6.9
     */
    void ASI_SFN_GetSfnMode(in IPS_RefTS_t RefTsOut, out enSFN_Mode eSFN_Mode)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Set the SFN mode (Enable/disable SFN)
     *
     * @param[in] RefTsOut The output TS
     * @param[in] eSFN_Mode SFN mode (SFN enabled/disabled)
     *
     * @exception OpNotSupported When called for non-ASI-SFN boards
     * @exception LicenseError   When there are insufficient licenses.     
     *
     * @version Release 6.9     
     */
    void ASI_SFN_SetSfnMode(in IPS_RefTS_t RefTsOut, in enSFN_Mode eSFN_Mode)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError);
    
    /// @} end of group asi_sfn    

    /** @defgroup packet_indexer PacketIndexer
     * This contains types, enums and methods to configure PacketIndexer functionality.
     * @{
     */

    struct PacketIndexerSettings_t
    {
      boolean PI_Enabled;
      unsigned short PI_MaxInterval;  ///< range 100..1000ms, in steps of 10ms
    };

    // PacketIndexer IDLs
    // ------------------------------------------------------------------------------------

    /** Get the Packet Indexer Settings of an output TS
     *
     * @param[in] RefTsOut The output TS
     * @param[out] PacketIndexerSettings settings of Packet Indexer
     *
     * @exception OpNotSupported:
     *  - When called for non-ASI boards
     * @exception OpNotSucceeded:
     *  - When parse errors occur
     * @exception OperationFailed:
     *  - When invalid references are passed
     *
     * @version Release 9.0
     */
    void GetPacketIndexerSettings(in IPS_RefTS_t RefTsOut, out PacketIndexerSettings_t PacketIndexerSettings)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Set the Packet Indexer Settings of an output TS
     *
     * @param[in] RefTsOut The output TS
     * @param[in] PacketIndexerSettings settings of Packet Indexer
     *
     * @exception OpNotSupported:
     *  - When called for non-ASI boards
     * @exception OpNotSucceeded:
     *  - When parse errors occur
     * @exception OperationFailed:
     *  - When invalid references are passed
     *  - When invalid settings are passed
     *  - When writing to FW failed
     *
     * @version Release 9.0
     */
    void SetPacketIndexerSettings(in IPS_RefTS_t RefTsOut, in PacketIndexerSettings_t PacketIndexerSettings)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Get the Packet Indexer Id of an ASI board
     *
     * @param[in] BoardNr            The asi board number
     * @param[out] PacketIndexerId   The Packet Indexer Id
     *
     * @exception OpNotSupported:
     *  - When called for non-ASI boards
     * @exception OpNotSucceeded:
     *  - When parse errors occur
     * @exception OperationFailed:
     *  - When writing to FW failed
     *
     * @version Release 9.0
     */
    void GetPacketIndexerId (in unsigned short BoardNr, out unsigned short PacketIndexerId)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Set the Packet Indexer Id of an ASI board
     *
     * @param[in] BoardNr            The asi board number
     * @param[in] PacketIndexerId    The Packet Indexer Id
     *
     * @exception OpNotSupported:
     *  - When called for non-ASI boards
     * @exception OpNotSucceeded:
     *  - When parse errors occur
     * @exception OperationFailed:
     *  - When writing to FW failed
     *
     * @version Release 9.0
     */
    void SetPacketIndexerId (in unsigned short BoardNr, in unsigned short PacketIndexerId)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /// @} end of group packet_indexer    

    /** @defgroup index_packet_interpreter IndexPacketInterpreter
     * This contains types, enums and methods to configure IndexPacketInterpreter functionality.
     * @{
     */

    struct IPI_Settings_t
    {
      boolean IPI_Enabled;
      boolean FollowDefaultRule; ///< readonly flag indicating if default priority bit settings are used
    };

    /** Information to change the IndexPacketInterpreter settings of an incoming TS.
     */
    struct InTS_IPI_Settings_t
    {
      IPS_RefTS_t    RefTsIn;
      IPI_Settings_t IPI_Settings;
    };

    /// A sequence of InTS_IndexPacketInterpreterSettings_t _t entries.
    typedef sequence<InTS_IPI_Settings_t> InTS_IPI_Settings_List_t;

    struct TsPacketIndexerID_Data_t
    {
      boolean        TsPacketIndexerID_Valid;
      unsigned short TsPacketIndexerID;
    };

    // IndexPacketInterpreter IDLs
    // ------------------------------------------------------------------------------------

    /** Get the IndexPacketInterpreter settings of one or more input TS
     *
     * @param[in] RefPhys    The port of which you want the information.
     * @param[in] RefTsList  A Ref_List_t, sequence of TS Ref's you want info about.
     *
     * @return InTS_IPI_Settings_List_t  A sequence of ChangePrioBitInputTS_t entries.
     *
     * @exception OpNotSupported:
     *  - When called for non-ASI/non-ASI-SFN/non-ASI-SFN-MkII boards
     * @exception OpNotSucceeded:
     *  - When parse errors occur
     * @exception OperationFailed:
     *  - When invalid references are passed
     *
     * - An empty ReTsfList means all TS refs.
     * @version Release 9.0
     */
    InTS_IPI_Settings_List_t InTS_IPI_SettingsGetL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Change the IndexPacketInterpreter settings for one or more existing incoming TS.
     *
     * @param[in] RefPhys                   The port for which parameters need to be changed.
     * @param[in] InTS_IPI_Settings_List  List of InTS_IPI_Settings_t entries.
     *
     * @exception OpNotSupported:
     *  - When called for non-ASI/non-ASI-SFN/non-ASI-SFN-MkII boards
     * @exception OpNotSucceeded:
     *  - When parse errors occur
     * @exception OperationFailed:
     *  - When invalid references are passed
     *  - When writing to FW failed
     *
     * @version Release 9.0
     */
    void InTS_IPI_SettingsSetL(in IPS_Ref_t RefPhys, in InTS_IPI_Settings_List_t InTS_IPI_Settings_List)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Revert the IndexPacketInterpreter setting to default for a list of input TSs.
     *
     * @param[in] RefPhys    The port for which to change to settings
     * @param[in] RefTsList  List of TSs for which to delete the settings
     *
     * @exception OpNotSupported:
     *  - When called for non-ASI/non-ASI-SFN/non-ASI-SFN-MkII boards
     * @exception OpNotSucceeded:
     *  - When parse errors occur
     * @exception OperationFailed:
     *  - When invalid references are passed
     *
     * @version Release 9.0
     */
    void InTS_IPI_SettingsDelL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefTsList)
      raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Set default IndexPacketInterpreter setting for new input TS.
     * 
     * @param[in] SlotNbr     Specifies the BoardNr on which to apply these defaults.
     * @param[in] IPI_Enabled boolean setting for new input TSs.
     * 
     * @exception OpNotSupported:
     *  - When called for non-ASI/non-ASI-SFN/non-ASI-SFN-MkII boards
     * @exception OpNotSucceeded:
     *  - When parse errors occur
     * @exception OperationFailed:
     *  - When invalid references are passed
     *
     * @version Release 9.0
     */
    void SetDefaultIPI_Settings(in unsigned short SlotNbr, in boolean IPI_Enabled)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Get current default IndexPacketInterpreter setting.
     * 
     * @param[in]  SlotNbr      BoardNr of which we want the information.
     * @param[out] IPI_Enabled  boolean setting for new input TSs.
     * 
     * @exception OpNotSupported:
     *  - When called for non-ASI/non-ASI-SFN/non-ASI-SFN-MkII boards
     * @exception OpNotSucceeded:
     *  - When parse errors occur
     * @exception OperationFailed:
     *  - When invalid references are passed
     *
     * @version Release 9.0
     */
    void GetDefaultIPI_Settings(in unsigned short SlotNbr, out boolean IPI_Enabled)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Get the Packet Indexer Id of an input TS
     *
     * @param[in] RefTsIn The input TS
     * @param[out] TsPacketIndexerID_Data   The Packet Indexer Id and validity indicator
     *
     * @exception OpNotSupported:
     *  - When called for non-ASI/non-ASI-SFN/non-ASI-SFN-MkII boards
     * @exception OpNotSucceeded:
     *  - When parse errors occur
     * @exception OperationFailed:
     *  - When invalid references are passed
     *
     * @version Release 9.0
     */
    void GetTsPacketIndexerId (in IPS_RefTS_t RefTsIn, out TsPacketIndexerID_Data_t TsPacketIndexerID_Data)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /// @} end of group index_packet_interpreter    



    /** @defgroup DetMux Deterministic Remux
     * This contains types, enums and methods to configure Deterministic Remultiplexing functionality.
     * @{
     */

    enum enASI_SFN_MKII_BoardMode
    {
      eASI_SFN_MKII_Regular,                     ///< Generic ASI SFN mode
      eASI_SFN_MKII_DeterministicRemultiplexing  ///< Deterministic Re-multiplexing mode
    };

    enum enASI_SFN_MKII_TS_Output_Mode
    {
      eASI_SFN_MKII_TS_Output_Main,        ///< Main SFN TS
      eASI_SFN_MKII_TS_Output_RDCS,        ///< RDCS TS of configured TS
      eASI_SFN_MKII_TS_Output_MainandRDCS  ///< Main SFN TS and RDCS TS
    };

    struct ASI_SFN_MKII_MDP_MultiplicationSettings_t
    {
      unsigned short MDP_MultiplicationFactor;  ///< Range 1..4, in steps of 1
      unsigned short MDP_MultiplicationDelay;   ///< Range 1--100 ms, in steps of 1
    };

    struct ASI_SFN_MKII_RDCS_Settings_t
    {
      unsigned short Delay;                             ///< Range 10--100 ms, in steps of 1
      unsigned short MDP_ExtensionInterval;             ///< Range 10--1000 ms, in steps of 1
      unsigned short MDP_DiscontinuityDetectionTimeout; ///< Range 10--1000 ms, in steps of 1
      ASI_SFN_MKII_MDP_MultiplicationSettings_t MDP_MultiplicationSettings;
      unsigned short CRSP_Interval;                     ///< Range 10--1000 ms, in steps of 1
      unsigned short CYTS_Delay;                         ///< Range 5--100 ms, in steps of 1
    };

    struct ASI_SFN_MKII_TS_Output_Mode_t
    {
      enASI_SFN_MKII_TS_Output_Mode eTS_Output_Mode;    ///< Type of TS
      unsigned short uTS_Output_RDCS;                   ///< RDCS TS number if eTS_Output_Mode is eTS_Output_MainandRDCS
                                                        ///< Range 0..7, in steps of 1
    };

    // RDCS IDLs
    // ------------------------------------------------------------------------------------

    /** Get ASI SFN MKII board mode
     *
     * @param[in] BoardNr
     * @param[out] BoardMode
     *
     * @exception OpNotSupported:
     *  - When called for non-ASI-SFN-MkII boards
     * @exception OpNotSucceeded:
     *  - When parse errors occur
     * @exception OperationFailed:
     *  - When invalid references are passed
     *
     * @version Release 9.0
     */
    void ASI_SFN_MKII_GetBoardMode(in unsigned short BoardNr, out enASI_SFN_MKII_BoardMode BoardMode)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Set ASI SFN MKII board mode
     *
     * @param[in] BoardNr
     * @param[in] BoardMode
     *
     * @exception OpNotSupported:
     *  - When called for non-ASI-SFN-MkII boards
     * @exception OpNotSucceeded:
     *  - When parse errors occur
     * @exception OperationFailed:
     *  - When invalid references are passed
     *
     * @version Release 9.0
     */
    void ASI_SFN_MKII_SetBoardMode(in unsigned short BoardNr, in enASI_SFN_MKII_BoardMode BoardMode)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Get the TS output mode
     *
     * @param[in] RefTsOut The output TS
     * @param[out] TS_Mode
     *
     * @exception OpNotSupported:
     *  - When called for non-ASI-SFN-MkII boards
     * @exception OpNotSucceeded:
     *  - When parse errors occur
     * @exception OperationFailed:
     *  - When board is not in Deterministic Re-multiplexing mode
     *  - When invalid references are passed
     *
     * @version Release 9.0
     */
    void ASI_SFN_MKII_GetTsOutputMode(in IPS_RefTS_t RefTsOut, out ASI_SFN_MKII_TS_Output_Mode_t TS_Mode)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Set the TS output mode
     *
     * @param[in] RefTsOut The output TS
     * @param[in] TS_Mode
     *
     * @exception OpNotSupported:
     *  - When called for non-ASI-SFN-MkII boards
     * @exception OpNotSucceeded:
     *  - When parse errors occur
     * @exception OperationFailed:
     *  - When board is not in Deterministic Re-multiplexing mode
     *  - When invalid references are passed
     *  - When invalid output mode is given
     *  - When writing to FW failed
     *
     * @version Release 9.0
     */
    void ASI_SFN_MKII_SetTsOutputMode(in IPS_RefTS_t RefTsOut, in ASI_SFN_MKII_TS_Output_Mode_t TS_Mode)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Get the MasterMux ID of an ASI SFN MKII board
     *
     * @param[in] BoardNr
     * @param[out] MasterMuxId MasterMux ID(range 0..65535)
     *
     * @exception OpNotSupported:
     *  - When called for non-ASI-SFN-MkII boards
     * @exception OpNotSucceeded:
     *  - When parse errors occur
     * @exception OperationFailed:
     *  - When invalid references are passed
     *
     * @version Release 9.0
     */
    void ASI_SFN_MKII_GetMasterMuxId(in unsigned short BoardNr, out unsigned short MasterMuxId)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Set the MasterMux ID of an ASI SFN MKII board
     *
     * @param[in] BoardNr
     * @param[in] MasterMuxId MasterMux ID(range 0..65535)
     *
     * @exception OpNotSupported:
     *  - When called for non-ASI-SFN-MkII boards
     * @exception OpNotSucceeded:
     *  - When parse errors occur
     * @exception OperationFailed:
     *  - When board is not in Deterministic Re-multiplexing mode
     *  - When invalid references are passed
     *  - When invalid output mode is given
     *  - When writing to FW failed
     *
     * @version Release 9.0
     */
    void ASI_SFN_MKII_SetMasterMuxId(in unsigned short BoardNr, in unsigned short MasterMuxId)
        raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Get the RDCS Settings of an output TS
     *
     * @param[in] RefTsOut The output TS
     * @param[out] RDCS_Settings settings of a RDCS TS Out
     *
     * @exception OpNotSupported:
     *  - When called for non-ASI-SFN-MkII boards
     * @exception OpNotSucceeded:
     *  - When parse errors occur
     * @exception OperationFailed:
     *  - When board is not in Deterministic Re-multiplexing mode
     *  - When invalid references are passed
     *
     * @version Release 9.0
     */
    void ASI_SFN_MKII_GetRDCS_Settings(in IPS_RefTS_t RefTsOut, out ASI_SFN_MKII_RDCS_Settings_t RDCS_Settings)
        raises(TimeOut, OperationFailed, OpNotAllowed, OpNotSupported);

    /** Set the RDCS Settings of an output TS
     *
     * @param[in] RefTsOut The output TS
     * @param[in] RDCS_Settings settings of a RDCS TS Out
     *
     * @exception OpNotSupported:
     *  - When called for non-ASI-SFN-MkII boards
     * @exception OpNotSucceeded:
     *  - When parse errors occur
     * @exception OperationFailed:
     *  - When board is not in Deterministic Re-multiplexing mode
     *  - When invalid references are passed
     *  - When invalid RDCS settings are passed
     *  - When writing to FW failed
     *
     * @version Release 9.0
     */
    void ASI_SFN_MKII_SetRDCS_Settings(in IPS_RefTS_t RefTsOut, in ASI_SFN_MKII_RDCS_Settings_t RDCS_Settings)
        raises(TimeOut, OperationFailed, OpNotAllowed, OpNotSupported);

    /// @} end of group DetMux

#endif // DISABLE_SFN
#ifndef DISABLE_IPGW
    ///////////////////////////////////////////////////////////////////////////////////////  
    // IP Gateway or IP Adapter
    ///////////////////////////////////////////////////////////////////////////////////////  
    //
    /** @defgroup ipa IP Adapter
     * This contains types, enums and methods to configure the IP Gateway.
     * @{
     */

    
    enum eGbeSpeedMode_t
    {
      e1Gbps, ///< Configures the Gbe port pair to work at a speed of 1 Gbps
      e10Gbps, ///< Configures the Gbe port pair to work at a speed of 10 Gbps
      eGbeSpeed_Reserved1, ///< Future use
      eGbeSpeed_Reserved2  ///< Future use    
    };
    
    enum eSDI_NoStreamMode_t
    {
      eBlackFrame,         ///< For video: Black frames. For audio: Silence.
      e0Vdc,               ///< No signal.
      eNoStream_Reserved1, ///< Future use  
      eNoStream_Reserved2, ///< Future use   
      eNoStream_Reserved3, ///< Future use   
      eNoStream_Reserved4, ///< Future use   
      eNoStream_Reserved5  ///< Future use         
    };

    enum enDCG_BoardMode_t //  @deprecated Since version 12.0, use BoardCfg_V2_t.IOInterfaceType instead.
                           //              Reason: The two IP- and ASI Gateway modes became
                           //              a Port-property, instead of a Board-property.
    {
      eDCG_BoardMode_IP_GW, ///< IP Gateway
      eDCG_BoardMode_ASI_GW, ///< ASI Gateway
      eDCG_BoardMode_Reserved_1, ///< not supported yet
      eDCG_BoardMode_Reserved_2, ///< not supported yet
      eDCG_BoardMode_Reserved_3, ///< not supported yet
      eDCG_BoardMode_Reserved_4, ///< not supported yet
      eDCG_BoardMode_Reserved_5  ///< not supported yet
    };

    enum enMValue_t
    {
      eM1_000, ///< Choose 25 or 30 or 60 for 1080i or 1080p
      eM1_001  ///< Choose 25 or 29.97 or 59.94 for 1080i or 1080p
    };


    // Board wide IDLs
    // ------------------------------------------------------------------------------------
    
     /** Set Gbe port pair speed to be used
      *
      * @param[in] SlotNumber   Slot number
      * @param[in] SpeedMode    SpeedMode  ///< The actual speed that the Gbe port pair should work in.
      *
      * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway.
      * @exception OpNotSucceeded In case of
      *
      * @note 
      * - Switching speed mode will cause a  firmware reset and thus is service affecting !!
     * @version Release 7.0      
      */
     void BoardCfgSetSpeedMode(in unsigned short SlotNumber, in eGbeSpeedMode_t SpeedMode) 
         raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError, OperationFailed);

     /** Get the Gbe port pair speed that is currently used
      *
      * @param[in]  SlotNumber  Slot number
      * @param[out] SpeedMode   SpeedMode  ///< The actual speed that the Gbe port pair  works in.
      *
      * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway.
      * @exception OpNotSucceeded In case of
      *
      * @version Release 7.0
      */
     void BoardCfgGetSpeedMode(in unsigned short SlotNumber, out eGbeSpeedMode_t SpeedMode) 
         raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);
              
    /** Prepare a board for hot swap.
     * 
     * @param[in] BoardNr  Board number
     *
     * @exception OpNotSucceeded Never thrown.
     * @exception OpNotAllowed   Never thrown.
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway or an IP Audio Gateway.
     * @version Release 7.0     
     */
    void HotSwapIO_Board(in unsigned short BoardNr)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);    
    
    /** Mirror an (SDI) port, so that it can be monitored.
     *
     * @param[in] SlotNumber  Slot number
     * @param[in] SdiPortNbr  The SDI port  to be mirrored or monitored
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway or an IP Audio Gateway.
     * @exception OpNotSucceeded In case of
     * - Invalid references like a port number that is not an SDI port nbr
     * @version Release 7.0     
     */  
    void SetMonitoredPort(in unsigned short SlotNumber, in unsigned short SdiPortNbr)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Get Mirror an (SDI) port, so that it can be monitored.
     *
     * @param[in]  SlotNumber  Slot number
     * @param[out] PortNbr     The port  being mirrored or monitored
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway or an IP Audio Gateway.
     * @exception OpNotSucceeded In case of
     * @version Release 7.0     
     */  
    void GetMonitoredPort(in unsigned short SlotNumber, out unsigned short PortNbr)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);
    
    
    /** Indicate if the external clock reference input should be used or not
     *    to synchronize the output video or audio signals on
     *
     * @param[in] SlotNumber  Slot number     
     * @param[in] bUseExtRef  True means the external clock reference input should be used
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway or an IP Audio Gateway.
     * @exception OpNotSucceeded In case of
     * @version Release 7.0
     * @deprecated
     * - 
     */  
    void SetVideoClockSync(in unsigned short SlotNumber, in boolean bUseExtRef)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Check if the external clock reference input is used or not
     *    to synchronize the output video or audio signals on
     *
     * @param[in]  SlotNumber  Slot number                
     * @param[out] bUseExtRef  True means the external clock reference input is used
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway or an IP Audio Gateway.
     * @exception OpNotSucceeded In case of
     *   - 
     * @version Release 7.0     
     * @deprecated
     */  
    void GetVideoClockSync(in unsigned short SlotNumber, out boolean bUseExtRef)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);
    
    /** Indicate if the external clock reference input should be used or not
     *    to synchronize the output video or audio signals on
     *
     * @param[in] SlotNumber  Slot number     
     * @param[in] bUseExtRef  True means the external clock reference input should be used
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway or an IP Audio Gateway.
     * @exception OpNotSucceeded In case of
     * @version Release 11.10     
     * - 
     */  
    void SetStreamClockSync(in unsigned short SlotNumber, in boolean bUseExtRef)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Check if the external clock reference input is used or not
     *    to synchronize the output video or audio signals on
     *
     * @param[in]  SlotNumber  Slot number                
     * @param[out] bUseExtRef  True means the external clock reference input is used
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway or an IP Audio Gateway.
     * @exception OpNotSucceeded In case of
     *   - 
     * @version Release 11.10     
     */  
    void GetStreamClockSync(in unsigned short SlotNumber, out boolean bUseExtRef)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);
    
    
    /** Specifiy output SDI or AES no stream mode
     *
     * @param[in] SlotNumber  Slot number      
     * @param[in] Mode        Specifies what the signal should look like when SDI or AES output
     *                        is "not streaming": either black frame for video / silence for audio or else 0 V dc
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway or an IP Audio Gateway.
     * @exception OpNotSucceeded In case of illegal  mode
     * - 
     * @version Release 7.0     
     */  
    void SetSDI_NoStreamMode(in unsigned short SlotNumber, in eSDI_NoStreamMode_t Mode)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);
    
    /** Gets the output SDI no stream mode
     *
     * @param[in]   SlotNumber  Slot number      
     * @param[out]  Mode        Specifies what the signal should will look like when SDI or AES output
     *                          is "not streaming": either black frame for video / silence for audio or else 0 V dc
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway or an IP Audio Gateway.
     * @exception OpNotSucceeded In case of 
     * - 
     * @version Release 7.0     
     */  
    void GetSDI_NoStreamMode(in unsigned short SlotNumber, out eSDI_NoStreamMode_t Mode)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);    
   
    /** Get the Gateway board mode.
     *
     * @param[in]  BoardNr      The gateway board number
     * @param[out] enBoardMode  Requested board mode
     *
     * @return Always returns eDCG_BoardMode_IP_GW
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not an
     *                           IP Video Gateway board.
     * @version Release 8.2
     *
     * @deprecated Since version 12.0, use BoardCfg_V2_t.IOInterfaceType and BoardCfg_V2_GetL instead.
     *             Reason: The two IP- and ASI Gateway modes became a Port-property, instead
     *             of a Board-property.
     **/
    void DCG_GetBoardMode(in unsigned short BoardNr, out enDCG_BoardMode_t enBoardMode)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);
 
    /** Set the gateway board mode.
     *
     * @param[in] BoardNr      The gateway board number
     * @param[in] enBoardMode  Board mode to set
     *
     * @exception OpNotSupported Calling this method always throws this execption.
     *
     * @version Release 8.2
     *
     * @deprecated Since version 12.0, use BoardCfg_V2_t.IOInterfaceType and BoardCfg_V2_Set instead.
     *             Reason: The two IP- and ASI Gateway modes became a Port-property, instead
     *             of a Board-property.
     **/
    void DCG_SetBoardMode(in unsigned short BoardNr, in enDCG_BoardMode_t enBoardMode)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /**
     * @param[in] BoardNr      The gateway board number
     * @param[in] enMValue     Board mode to set
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not an IP Video
     *                           Gateway board.
     *
     * @version Release 8.9
     **/
    void DCG_SetMValue(in unsigned short BoardNr, in enMValue_t enMValue)
      raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    /**
     * @param[in] BoardNr      The gateway board number
     *
     * @exception OpNotSupported When BoardNr = 0 = Main or the board is not an IP Video
     *                           Gateway board.
     *
     * @version Release 8.9
     **/
     enMValue_t DCG_GetMValue(in unsigned short BoardNr)
      raises(TimeOut, OpNotSucceeded, OperationFailed, OpNotAllowed, OpNotSupported);

    // General IP Adapter structures and enums
    // ------------------------------------------------------------------------------------

    /** @defgroup ipa_stream IP Adapter SDI and RTP streams
     * This contains types, enums and methods to configure the TSs of the multiplexer part in the device.
     * @{
     */
   enum eVideoFormat_t
    {
      eSD,
      eHD,
      e3G,
      eAES, // For Audio GW
      eVideoFormat_Reserved1, ///< Future use  
      eVideoFormat_Reserved2, ///< Future use  
      eVideoFormat_Reserved3  ///< Future use        
    };
     
    /** Information of an incoming TS.
     */
    struct DCG_InputTS_t
    {
      IPS_RefTS_t     RefIn;          ///< The location of the TS (Board, Port and Ref).
      /** Read only Bitmap used by GUI to display specific icons
       * - Bit 3: TRUE if RTP is streamed (reserved for future use)
       * - Bit 4: TRUE if VLAN is used (reserved for future use)
       * - Bit 5: TRUE if VBR is used (reserved for future use)
       * - Bit 6: TRUE if Stream is routed
       * - Bit 7: TRUE if Stream is present at the input
       * - Bit 8: TRUE if UDP Stream Loss/SDI  Sync Loss/ASI Sync Loss/AES Sync Loss alarm is active.
       * - Bit 9: TRUE if FEC column stream is present.
       * - Bit10: TRUE if FEC row stream is present.
       * - Bit11: TRUE if Stream is in Backup.
       */ 
      unsigned long   TS_InProperty;    
      eVideoFormat_t  ExpectedVideoFormat; // The expected format can be Audio (= AES) too: Will be checked by FW,
                            //if the detected signal type consumes more bandwidth than defined, input stream will be dropped.
                            // For Audio GW, this is read only.
      string          UserName;
    };

    /// A sequence of DCG_InputTS_t entries.
    typedef sequence<DCG_InputTS_t> DCG_InputTS_List_t;
    
    struct DCG_InputRTP_Stream_t
    {
      DCG_InputTS_t Common;
      IPS_UDP_Socket_t Socket;        ///< Unique IP-Address and UDP port combination.
      short           VideoLineOffset;      ///< between plus and minus 10 (default = 0)
      short           VideoPixelOffset;     ///< between plus and minus 432(SD)/1320(HD) (default =  0)
      unsigned short  DejitterBufferSize;   ///< in ms
                                            ///< For uncompressed: Between 7 and 200 (default 25)
                                            ///< For compressed: Between 1 and 200 (default 25)
                                            ///< Prior to version 10.10: Between 10 and 200 (default 25)
    };                                      ///< Prior to version 9.10: Between 10 and 100 (default 60)      
    /// A sequence of DCG_InputTS_t entries.
    typedef sequence<DCG_InputRTP_Stream_t> DCG_InputRTP_StreamList_t;

     /// Describes the output clocking mode when RTP is routed to SDI.
    enum eTxClockingMode_t
    {
      eFreeRunning,         // Future
      eAdaptiveRecovery,    // Regenerate clock from RTP input
      eGenLocked            // Regenerate clock from Reference input
    };
 
    struct DCG_InputRTP_Stream_V2_t
    {
      DCG_InputTS_t Common;
      IPS_UDP_Socket_t Socket;        ///< Unique IP-Address and UDP port combination.
      eTxClockingMode_t TxClockMode;
      short           VideoLineOffset;      // between plus and minus 10 (default = 0)
      short           VideoPixelOffset;     // between plus and minus 432(SD)/1320(HD) (default =  0)
      unsigned short  DejitterBufferSize;   ///< in ms
                                            ///< For uncompressed: Between 7 and 200 (default 25)
                                            ///< For compressed: Between 1 and 200 (default 25)
                                            ///< Prior to version 10.10: Between 10 and 200 (default 25)
    };                                      ///< Prior to version 9.10: Between 10 and 100 (default 60)

    /// A sequence of DCG_InputTS_t entries.
    typedef sequence<DCG_InputRTP_Stream_V2_t> DCG_InputRTP_StreamList_V2_t;

    struct DCG_InputRTP_Stream_V3_t
    {
      DCG_InputTS_t Common;
      IPS_UDP_Socket_t Socket;              ///< Unique IP-Address and UDP port combination.
      eTxClockingMode_t TxClockMode;
      long            VideoOffsetDelay;     ///< For Video Gateway: Unit is nanos,  ranging from -10000000 to  10000000 in increments of 5 ns.
                                            ///< For Audio Gateway: Unit is frames, ranging from         0 to       191 in increments of 1 frame.
      unsigned short  DejitterBufferSize;   ///< in ms
                                            ///< For Audio Gateway: Between 10 and 200 (default 25)
                                            ///< For uncompressed: Between 7 and 200 (default 25)
                                            ///< For compressed: Between 1 and 200 (default 25)
                                            ///< Prior to version 10.10: Between 10 and 200 (default 25)
    };                                      ///< Prior to version 9.10: Between 10 and 100 (default 60)

    /// A sequence of DCG_InputTS_t entries.
    typedef sequence<DCG_InputRTP_Stream_V3_t> DCG_InputRTP_StreamList_V3_t;


     /// Describes if the TS is streaming or not.
    enum eDCG_StreamingState
    {
      DCG_Streaming_Active,
      DCG_Streaming_Paused,
      eDCG_Streaming_Reserved1, ///< Future use   
      eDCG_Streaming_Reserved2, ///< Future use   
      eDCG_Streaming_Reserved3  ///< Future use         
    };

    
    const unsigned long DCG_BITMAP_OUTPUT_TS_RTP_ON              = 0x8;
    const unsigned long DCG_BITMAP_OUTPUT_TS_VLAN_ON             = 0x10;
    const unsigned long DCG_BITMAP_OUTPUT_TS_VBR_ON              = 0x20;
    const unsigned long DCG_BITMAP_OUTPUT_TS_FEC_COL_PRESENT     = 0x200; ///< Will be set when FEC column stream is enabled
    const unsigned long DCG_BITMAP_OUTPUT_TS_FEC_ROW_PRESENT     = 0x400; ///< Will be set when FEC row stream is enabled
    
    /** Information-Settings of an outgoing TS.
     */
    struct DCG_OutputTS_t
    {
      IPS_RefTS_t Ref;              ///< The location of the TS (Board, Port and Ref).
      unsigned long       Bitrate; /**< Bitrate of the outgoing TS (in bps).  */
      ///< in IP Video Gatewae, the only supported bitrates are 270Mbps (SD) (default), 1.5Gbps (HD) or 3Gbps (3G) or Unchecked  (0xFFFFFFFF)
      ///< in IP audio Gateway, the only supported bitrates are 3.072 Mbps (48 kHz) or Unchecked (0xFFFFFFFF)
      eDCG_StreamingState State;
      unsigned long       TS_OutProperty; ///< Read only Bitmap used by GUI to display specific icons 
                                    ///< Bit  3: TRUE if RTP is streamed
                                    ///< Bit  4: TRUE if VLAN is enabled
                                    ///< Bit  5: TRUE if VBR is enabled
                                    ///< Bit  6: TRUE if Stream is routed
                                    ///< Bit  7: TRUE if Stream is present at input
                                    ///< Bit  9: TRUE if FEC column stream is enabled
                                    ///< Bit 10: TRUE if FEC row stream is enabled
                                    ///< Bit 11: TRUE if Stream is in Backup.

      boolean             FollowUserNameOfInputStream;
	    string              UserName;
      IPS_RefTS_t         ConfiguredRefIn; // Source of the routing. If set to invalid (board, port and ref all 0xFFFF) then no routing is active
      IPS_RefTS_t         ActiveRefIn;   // Can be different then ConfiguredRefIn due to backup
    };

    /// A sequence of DCG_OutputTS_t entries.
    typedef sequence<DCG_OutputTS_t> DCG_OutputTS_List_t;
    
    struct DCG_OutputRTP_Stream_t
    {
      DCG_OutputTS_t Common;
      IPS_UDP_Socket_t  Socket;      ///< Unique destination IP-Address and UDP port combination.
    };

    /// A sequence of DCG_OutputTS_t entries.
    typedef sequence<DCG_OutputRTP_Stream_t> DCG_OutputRTP_StreamList_t;    


    enum eGbePortType_t {
      eGbePort_PairType,       ///< All configuration values like:
                               ///  TTL, TOS, VLAN, srcAddr (source socket) and destination socket
                               ///  are the same for the two GbE ports. Values configured for GbE0
                               ///  are also used for GbE1
      eGbePort_IndividualType  ///< All configuration values as mentioned above are individual for
                               ///  for each GbE port.
    };

    struct DCG_OutputRTP_V2_Stream_t
    {
      DCG_OutputTS_t Common;
      eGbePortType_t GbePortType;
    };

    /// A sequence of DCG_OutputRTP_V2_t entries.
    typedef sequence<DCG_OutputRTP_V2_Stream_t> DCG_OutputRTP_V2_StreamList_t;    


    struct DCG_OutputGBE_t {
      IPS_RefTS_t RefTs;
      unsigned long Property;   ///< Bit 0: if VLAN enabled
                                ///< Bit 1: if stream is present at output
      IPS_UDP_Socket_t  Socket; ///< Destination UDP socket
    };

    /// A sequence of DCG_OutputGBE_t entries.
    typedef sequence<DCG_OutputGBE_t> DCG_OutputGBE_List_t;    

    struct DCG_OutputFecGBE_t {
      IPS_RefTS_t RefTS;
      IPS_UDP_Socket_t  row; ///< Destination UDP socket for FEC ROW
      IPS_UDP_Socket_t  col; ///< Destination UDP socket for FEC COL
    };

    /// A sequence of DCG_OutputFecGBE_t entries.
    typedef sequence<DCG_OutputFecGBE_t> DCG_OutputFecGBE_List_t;    

   struct RoutingData_t
    {
      IPS_RefTS_t RefOut;   // Destination of the routing
      IPS_RefTS_t RefIn;    // Source of the routing. If set to invalid (board, port and ref all 0xFFFF) then any active routing will be cleared.
    };
  
    /// A sequence of IPS_OutPID_Data_t.
    typedef sequence<RoutingData_t> RoutingDataList_t;
    
    enum eFrameRate_t
    {
      e24fps,
      e25fps,
      e30fps,
      e50fps,
      e60fps,
      e29_97fps,
      e59_94fps,
      eDCG_FramerRate_Reserved1, ///< Future use        
      eDCG_FramerRate_Reserved2, ///< Future use     
      eDCG_FramerRate_Reserved3, ///< Future use     
      eDCG_FramerRate_Reserved4, ///< Future use     
      eDCG_FramerRate_Reserved5 ///< Future use           
    };    
    
    enum eAspectRatio_t
    {
      e4_3,
      e16_9,
      e14_9,
      eNot_Available,
      eAspectRatio_Reserved2, ///< Future use 
      eAspectRatio_Reserved3, ///< Future use 
      eAspectRatio_Reserved4, ///< Future use 
      eAspectRatio_Reserved5  ///< Future use       
    };
    
    enum eFrameBuildUp_t
    {
      eProgressive,
      eInterlaced,
      eFrameBuildUp_Reserved1, ///< Future use    
      eFrameBuildUp_Reserved2, ///< Future use  
      eFrameBuildUp_Reserved3  ///< Future use        
    };
      
    struct VideoSignalInfo_t
    {
      IPS_RefTS_t     RefIn; // Reference of input stream
      eFrameRate_t    FrameRate;
      unsigned long   SignalRate;
      unsigned long   VideoBitrate; // future ?!
      unsigned short  NbrOfAudios; // future !
      boolean         bJPEG2000; // future !
      eVideoFormat_t  VideoFormat;
      eAspectRatio_t  AspectRatio;
      unsigned long   NbrOfLinesPerFrame;
      eFrameBuildUp_t FrameBuildUp;
    };
          
    typedef sequence<VideoSignalInfo_t> VideoSignalInfoList_t;
    
    struct End2End_Delay_t
    {
      IPS_RefTS_t     RefOut; // Reference of output stream
      unsigned long   Delay; // in ms
    };
    
    typedef sequence<End2End_Delay_t> End2End_DelayList_t;
    
    struct DCG_3D_pair_t {
      IPS_RefTS_t     left;
      IPS_RefTS_t     right;
    };

    typedef sequence<DCG_3D_pair_t> DCG_3D_pair_List_t;

    // TS IDLs
    // ------------------------------------------------------------------------------------
    
    /** Change the parameters of one or more existing outgoing SDI or AES streams.
     *
     * @param[in] RefPhys The SlotNumber and PortNr of which parameters need to be changed.
     * @param[in] OutputTSList List of DCG_OutputTS_t entries.
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway or an IP Audio Gateway.
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys).
     * - Inconsistency between RefPhys.BoardNr & OutputTSList[x].Ref.BoardNr.
     * - Inconsistency between RefPhys.PortNr & OutputTSList[x].Ref.PortNr in case RefPhys.PortNr != 0xFFFF.
     * - Out of range values (Bitrate, UDPPort).
     * - Invalid enum value (State).
     *
     * @version Release 7.0
     */
    void SDI_OutTS_ChangeL(in IPS_Ref_t RefPhys, in DCG_OutputTS_List_t OutputTSList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError, OperationFailed);
     
    /** Get a list of outgoing SDI or AES streams and their parameters.
     * 
     * @param[in] RefPhys The BoardNr and PortNr you want information about.
     * 
     * @return DCG_OutputTS_List_t, a sequence of DCG_OutputTS_t entries.
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway or an IP Audio Gateway.
     * @exception OpNotSucceeded In case invalid references (RefPhys) are used.
     * @note 
     * - A value of 0xFFFF for port means all SDI output ports.
     * @version Release 7.0     
     */
    DCG_OutputTS_List_t SDI_OutTS_GetL(in IPS_Ref_t RefPhys)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);    
    
    /** Create a number of output RTP streams on given Slot and Port based on the defined defaults (DCG_OutDefaultsSet(), DCG_OutDefaultsGet()).
     *          Only meant to be used on an output Gbe port.
     * @param[in] RefPhys The SlotNumber and PortNr on which Streams need to be added.
     * @param[in] NbrOutTS The number of streams to create.
     * @param[out] OutputStreamList A list tih NbrOutTS elements that contains info on the created streams.
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway or an IP Audio Gateway.
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys).
     * - Maximum number of supported streams is reached.
     *
     * @version Release 7.0     
     */
    void OutputRTP_StreamAddL(in IPS_Ref_t RefPhys, in unsigned long NbrOutTS, out DCG_OutputRTP_StreamList_t OutputStreamList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

        
    /** Change the parameters of one or more existing outgoing RTP streams.
     *  Note that an outgoing RTP stream co-exists with an output TS.
     * Only when an output TS is created, an output stream is available.
     * @param[in] RefPhys The SlotNumber and PortNr of which parameters need to be changed.
     * @param[in] OutputStreamList List of DCG_OutputRTP_Stream_t entries.
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway or an IP Audio Gateway.
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys).
     * - Inconsistency between RefPhys.BoardNr & OutputTSList[x].Ref.BoardNr.
     * - Inconsistency between RefPhys.PortNr & OutputTSList[x].Ref.PortNr in case RefPhys.PortNr != 0xFFFF.
     *
     * @version Release 7.0     
     */
    void OutputRTP_StreamChangeL(in IPS_Ref_t RefPhys, in DCG_OutputRTP_StreamList_t OutputStreamList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError, OperationFailed);


    /** This function is similar to OutputRTP_StreamChangeL() above, except for the list of elements
     *   returned is not a list of DCG_OutputRTP_Stream_t but a list of DCG_OutputRTP_V2_Stream_t
     *   which differs in that the latter does not contail the destination UDP socket, but a
     *   contain an enum saying whether the associated GbE ports with this OutRTP is a pair or
     *   individual port. 
     *  Except for this all other things are equal.
     *
     * @version Release 8.7
     */
    void OutputRTP_V2_StreamChangeL(in IPS_Ref_t RefPhys, in DCG_OutputRTP_V2_StreamList_t OutputStreamList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError, OperationFailed);

     
    /** Get a list of outgoing RTP streams and their parameters.
     * 
     * @param[in] RefPhys The BoardNr and PortNr you want information about.
     * @param[in] RefList A sequence of Ref's you want info about.
     * 
     * @return DCG_OutputRTP_StreamList_t, a sequence of DCG_OutputRTP_Stream_t entries.
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway or an IP Audio Gateway.
     * @exception OpNotSucceeded In case invalid references (RefPhys, RefList) are used.
     * @note 
     * - A value of 0xFFFF for port means all ports.
     * - An empty list means all refs.
     * @version Release 7.0     
     */
    DCG_OutputRTP_StreamList_t OutputRTP_StreamGetL(in IPS_Ref_t RefPhys, in Ref_List_t RefList )
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);    


    /** Get a list of outgoing RTP streams and their parameters.
     * 
     * @param[in] RefPhys The BoardNr and PortNr you want information about.
     * @param[in] RefList A sequence of Ref's you want info about.
     * 
     * @return DCG_OutputRTP_V2_StreamList_t, a sequence of DCG_OutputRTP_V2_Stream_t entries.
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway or an IP Audio Gateway.
     * @exception OpNotSucceeded In case invalid references (RefPhys, RefList) are used.
     * @note 
     * - A value of 0xFFFF for port means all ports.
     * - An empty list means all refs.
     *
     * @version Release 8.7
     */
    DCG_OutputRTP_V2_StreamList_t OutputRTP_V2_StreamGetL(in IPS_Ref_t RefPhys, in Ref_List_t RefList )
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);    


    /** Change the parameters of one or more existing outgoing GBE streams.
     *
     * @param[in] Board The BoardNr for which parameters need to be changed.
     * @param[in] OutputGBE_List List of DCG_OutputGBE_t entries. Each entry configure the
     *            destination UDP socket on a (stream,GbE port) basis. This is for hitless
     *            unicast.
     * Note: The destination UDP socket value set by this function for GbE0, i.e. port=0 and
     *       in OutputRTP_StreamChangeL() is two ways of doing the same thing.
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway or an IP Audio Gateway.
     * @exception OpNotSucceeded In case of
     * - Invalid references OutputGBE_List[].RefTS
     *
     * @version Release 8.7
     */
    void OutputGBE_ChangeL(in unsigned short Board, in DCG_OutputGBE_List_t OutputGBE_List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError, OperationFailed);


    /** Get a list of outgoing GBE streams and their parameters.
     * 
     * @param[in] Board
     * @param[in] RefTsList A sequence of RefTS's you want info about.
     * 
     * @return DCG_OutputGBE_List_t, a sequence of DCG_OutputGBE_t entries.
     *
     * Note: For each element in 'RefList' there will be two values in the returned list,
     *       one for each GbE port.
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway or an IP Audio Gateway.
     * @exception OpNotSucceeded In case invalid references RefList are used.
     * @note 
     * - An empty list means all refs.
     *
     * @version Release 8.7     
     */
    DCG_OutputGBE_List_t OutputGBE_GetL(in unsigned short Board, in IPS_RefTS_List_t RefTsList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);    

    /** Change the parameters of one or more existing outgoing FEC GBE streams.
     *
     * @param[in] Board The BoardNr for which parameters need to be changed.
     * @param[in] OutputFecGBE_List List of DCG_OutputFecGBE_t entries. Each entry configure the
     *            destination UDP socket on a (stream,GbE port) basis.
     * Note: The destination UDP socket value set by this function for GbE0, i.e. port=0 and
     *       in OutputFEC_StreamChangeL() is two ways of doing the same thing.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board or when board is not an IP Video Gateway board.
     * @exception OpNotSucceeded In case of
     * - Invalid references OutputFecGBE_List[].RefTS
     *
     * @version Release 8.9
     */
    void OutputFecGBE_ChangeL(in unsigned short Board, in DCG_OutputFecGBE_List_t OutputFecGBE_List)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError, OperationFailed);

    /** Get a list of outgoing GBE streams and their parameters.
     * 
     * @param[in] Board
     * @param[in] RefTsList A sequence of RefTS's you want info about.
     * 
     * @return DCG_OutputFecGBE_List_t, a sequence of DCG_OutputFecGBE_t entries.
     *
     * Note: For each element in 'RefList' there will be two values in the returned list,
     *       one for each GbE port.
     * 
     * @exception OpNotSupported When BoardNr = 0 = Main board or when board is not an IP Video Gateway board.
     * @exception OpNotSucceeded In case invalid references RefList are used.
     * @note 
     * - An empty list means all refs.
     *
     * @version Release 8.9
     */
    DCG_OutputFecGBE_List_t OutputFecGBE_GetL(in unsigned short Board, in IPS_RefTS_List_t RefTsList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);    

        
   /** Get a list of incoming streams at an SDI, ASI, or AES port.
     *
     * @param[in] PhysRef The BoardNr and PortNr of which you want the information.     
     *
     * @return DCG_InputTS_List_t A sequence of DCG_InputTS_t entries.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board or when board is not an IP Video Gateway or IP Audio Gateway board.
     * @exception OpNotSucceeded In case invalid references( PhysRef, RefList) are used.
     *
     * @note 
     * - A value of 0xFFFF for port means all ports.
     * - An empty RefList means all refs.
     * @version Release 7.0     
     */
    DCG_InputTS_List_t SDI_InTS_GetL(in IPS_Ref_t PhysRef) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);
        
    /** Change the parameters of one or more existing input streams at an SDI, ASI, or AES port.
     *
     * @param[in] RefPhys The BoardNr and PortNr of which parameters need to be changed.
     * @param[in] InputTSList List of DCG_InputTS_t entries.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board or when board is not an IP Video Gateway or IP Audio Gateway board.
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys).
     * - Inconsistency between RefPhys.BoardNr & InputTSList[x].Ref.BoardNr.
     * - Inconsistency between RefPhys.PortNr & InputTSList[x].Ref.PortNr in case RefPhys.PortNr != 0xFFFF.
     * - Out of range values (DejitterBufferSize).
     *
     * @version Release 7.0                 
     */
	  void SDI_InTS_ChangeL(in IPS_Ref_t RefPhys, in DCG_InputTS_List_t InputTSList) 
          raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    
    /** Change the parameters of one or more existing input RTP streams.
     *  Note that an input RTP stream co-exists with an input TS.
     * Only when an input TS is created, an input stream is available.
     * @param[in] RefPhys The SlotNumber and PortNr of which parameters need to be changed.
     * @param[in] InputStreamList List of DCG_InputRTP_Stream_V2_t entries.
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway or an IP Audio Gateway.
     * @exception OpNotSucceeded In case of
     * - Invalid references (RefPhys).
     * - Inconsistency between RefPhys.BoardNr & InputTSList[x].Ref.BoardNr.
     * - Inconsistency between RefPhys.PortNr & InputTSList[x].Ref.PortNr in case RefPhys.PortNr != 0xFFFF.
     *
     * @version Release 7.0     
     */
    void InputRTP_StreamChangeL(in IPS_Ref_t RefPhys, in DCG_InputRTP_StreamList_t InputStreamList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError, OperationFailed);
     
    void InputRTP_StreamChangeL_V2(in IPS_Ref_t RefPhys, in DCG_InputRTP_StreamList_V2_t InputStreamList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError, OperationFailed);

    /**
     *  Similar to the above, except the genlock value is specified in units of time
     *
     * @version Release 8.7     
     */
    void InputRTP_StreamChangeL_V3(in IPS_Ref_t RefPhys, in DCG_InputRTP_StreamList_V3_t InputStreamList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError, OperationFailed);

    /** Get a list of input RTP streams and their parameters.
     * 
     * @param[in] RefPhys The BoardNr and PortNr you want information about.
     * @param[in] RefList A sequence of Ref's you want info about.
     * 
     * @return DCG_InputRTP_StreamList_V2_t, a sequence of DCG_InputRTP_Stream_V2_t entries.
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway or an IP Audio Gateway.
     * @exception OpNotSucceeded In case invalid references (RefPhys, RefList) are used.
     * @note 
     * - A value of 0xFFFF for port means all ports.
     * - An empty list means all refs.
     * @version Release 7.0     
     */
    DCG_InputRTP_StreamList_t InputRTP_StreamGetL(in IPS_Ref_t RefPhys, in Ref_List_t RefList )
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);    

    DCG_InputRTP_StreamList_V2_t InputRTP_StreamGetL_V2(in IPS_Ref_t RefPhys, in Ref_List_t RefList )
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);    

    /**
     *  Similar to the above, except the genlock value is specified in units of time
     *
     * @version Release 8.7     
     */
    DCG_InputRTP_StreamList_V3_t InputRTP_StreamGetL_V3(in IPS_Ref_t RefPhys, in Ref_List_t RefList )
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);    
        
        
        
    
    /** Add a routing source to a number of output transport streams.
     *
     * @param[in] SlotNumber  The SlotNumber  of which parameters need to be changed.
     * @param[in] RoutingDataList  List of RoutingData_t entries.
     *
     * @exception TimeOut         A timeout occurred during IIOP processing
     * @exception OpNotSupported  When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway or an IP Audio Gateway.
     * @exception OpNotAllowed    Not logged in
     * @exception OpNotSucceeded  In case of
     *                            - Invalid references for output or input references
     *                            - Inconsistency between SlotNumber & RoutingDataList SlotNumber.
     * @exception LicenseError    If there are insufficient licenses.
     * @exception OutOfRange      Not enough output bandwidth to complete routing.
     * @version Release 7.0
     */  
    void DCG_ApplyRoutings(in unsigned short SlotNumber, in  RoutingDataList_t RoutingDataList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError, OutOfRange, OperationFailed);
 

    /** Delete a list of input TSs
     * 
     * @param[in] RefPhys BoardNr & PortNr where TSs need to be deleted.
     * @param[in] RefList list of IPS_RefTS_t, references to the TSs that need to be deleted.
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway or an IP Audio Gateway.
     * @exception OpNotSucceeded In case
     * - Invalid references are used (RefPhys, RefList).
     * - Inconsistency between RefPhys.BoardNr & RefList[x].BoardNr.
     * - Inconsistency between RefPhys.PortNr & RefList[x].PortNr in case RefPhys.PortNr != 0xFFFF.
     * - The requested TS has a route to an output TS
     * @note
     * - When called on an SDI board, a new TS is created for the ports where the TS is deleted
     * @version Release 7.0     
     */
    void DCG_InTS_DeleteL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);
        
     /** Delete a list of output TSs
     * 
     * @param[in] RefPhys BoardNr & PortNr where TSs need to be deleted.
     * @param[in] RefList list of IPS_RefTS_t, references to the TSs that need to be deleted.
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway or an IP Audio Gateway.
     * @exception OpNotSucceeded In case
     * - Invalid references are used (RefPhys, RefList).
     * - Inconsistency between RefPhys.BoardNr & RefList[x].BoardNr.
     * - Inconsistency between RefPhys.PortNr & RefList[x].PortNr in case RefPhys.PortNr != 0xFFFF.
     * - The requested TS has a route to an input TS
     * @note
     * - When called on an SDI board, a new TS is created for the ports where the TS is deleted
     * @version Release 7.0     
     */
    void DCG_OutTS_DeleteL(in IPS_Ref_t RefPhys, in IPS_RefTS_List_t RefList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);
    
  /** Gets the (video) signal information from an input SDI signal or from an input RTP transport stream
   *
   * @param[in]  SlotNumber specifies slot number
   * @param[in]  RefList  when empty, the video signal info for ALL valid SDI inputs's are given.
   * @param[out] SignalInfoList  The returned video signal information
   *
   * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway board.
   * @exception OpNotSucceeded In case of
   * - Invalid references for input references
   * - The RefList is specifying an SDI stream that is not valid
   * @version Release 7.0  
   */  
  void GetVideoSignalInfos(in unsigned short SlotNumber, in IPS_RefTS_List_t RefList, out VideoSignalInfoList_t SignalInfoList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

  /** Gets the end to end delay that was introduced for an output transport stream
   *
   * @param[in]  SlotNumber specifies slot number
   * @param[in]  RefList when empty, the end2end delays for ALL TS's are given.
   * @param[out] DelayList  The returned end to end delays
   *
   * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway or an IP Audio Gateway.
   * @exception OpNotSucceeded In case of
   * - Invalid references for output transport streams
     * @version Release 7.0   
   */  
  void GetEndToEndDelaysL(in unsigned short SlotNumber, in IPS_RefTS_List_t RefList, out End2End_DelayList_t DelayList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

  /** Add 3D pairs, given in a list.
   * 
   * @param[in] Board
   * @param[in] l a sequence of DCG_3D_pair_t entries.
   *
   * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway board.
   * @exception OpNotAllowed   When stream that can not be paired is tried to.
   *                           Only InSDI streams can be paired to each other,
   *                           and similar to OutSDI.
   * @exception OpNotAllowed   When some streams become member of more than one pair.
   * @exception OpNotSucceeded When some in streams does not have there expected video type
   *                           set to HD.
   * @exception OpNotSucceeded When some out streams that is ready route, is routen from a source
   *                           streams which does not have there expected video type set to HD.
   *
   * @version Release 8.7     
   */
  void Pair3D_AddL(in unsigned short Board, in DCG_3D_pair_List_t l)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);    

  void Out_Pair3D_AddL(in unsigned short Board, in DCG_3D_pair_List_t l)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);    

  void In_Pair3D_AddL(in unsigned short Board, in DCG_3D_pair_List_t l)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);    

  /** Delete 3D pairs, given in a list.
   * 
   * @param[in] Board
   * @param[in] l a sequence of DCG_3D_pair_t entries.
   *
   * @exception OpNotSupported When BoardNr = 0 = Main board.
   * @exception OpNotAllowed When trying to delere pairs that do not exist.
   *
   * @version Release 8.7     
   */
  void Pair3D_DeleteL(in unsigned short Board, in DCG_3D_pair_List_t l)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OperationFailed);    

  void Out_Pair3D_DeleteL(in unsigned short Board, in DCG_3D_pair_List_t l)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OperationFailed);    

  void In_Pair3D_DeleteL(in unsigned short Board, in DCG_3D_pair_List_t l)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OperationFailed);    

  /** Get a list of 3d paired SDI streams input or output.
   * 
   * @param[in] Board
   * 
   * @return DCG_3D_pair_List_t, a sequence of DCG_3D_pair_t entries.
   *
   * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway board.
   *
   * @version Release 8.7     
   */
  DCG_3D_pair_List_t Pair3D_GetL(in unsigned short Board)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);    

  DCG_3D_pair_List_t Out_Pair3D_GetL(in unsigned short Board)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);    

  DCG_3D_pair_List_t In_Pair3D_GetL(in unsigned short Board)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);    


  /** Set stream 1 and 2 to 3D paired on an ASI board.
   *  This is a board level configuration
   * 
   * @param[in] Board
   * @param[in] enabled boolean
   * 
   * @return
   *
   * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway board.
   *
   * @version Release 8.7     
   *
   * @deprecated Since version 12.0, use the Pair3D_AddL-series of methods instead.
   */
   void DCG_ASIG_Set_3D(in unsigned short Board, in boolean enabled)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);    


  /** Get whether stream 1 and 2 is 3D paired on an ASI board.
   *  This is a board level configuration
   * 
   * @param[in] Board
   * 
   * @return boolean
   *
   * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway board.
   *
   * @version Release 8.7     
   *
   * @deprecated Since version 12.0, use the Pair3D_AddL-series of methods instead.
   */
   boolean DCG_ASIG_Get_3D(in unsigned short Board)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);    


    // IP Video Gateway: SDI Generator IDLs
    // ------------------------------------------------------------------------------------
    enum eSDI_GeneratorMode_t
    {
      e3G_1080P_60,
      e3G_1080P_59_94,
      e3G_1080P_50, 
      eHD_1080P_30,
      eHD_1080P_29_97,
      eHD_1080P_25,
      eHD_720P_60,
      eHD_720P_59_94,
      eHD_720P_50,
      eHD_1080I_30,
      eHD_1080I_29_97,
      eHD_1080I_25,
      eSD_525I_29_97,
      eSD_625I_25,      ///< (default)
      eSDI_GeneratorMode_Reserved1, ///< Future use        
      eSDI_GeneratorMode_Reserved2, ///< Future use        
      eSDI_GeneratorMode_Reserved3  ///< Future use        
    };  
  
    enum eSDI_ColorOutputMode_t
    {
      eOM_Static,
      eOM_RGB_Cycling,
      eOM_Reserved1, ///< Future use 
      eOM_Reserved2, ///< Future use 
      eOM_Reserved3  ///< Future use 
    };

    struct DCG_GeneratorConfig_t
    {
      IPS_RefTS_t            GeneratorRef; // Reference of SDI generator - readonly !
      boolean                GenEnabled;
      eSDI_GeneratorMode_t   Mode;
      eSDI_ColorOutputMode_t ColorOutputMode; ///< only Static mode supported 
      unsigned long          GenPropertyBits; ///< Future use
      octet                  RedColorValue;    // R: range between 0 and 255 (default 0)
      octet                  GreenColorValue;  // G: range between 0 and 255 (default 0)
      octet                  BlueColorValue;   // B: range between 0 and 255 (default 0)
    };
    
    typedef sequence<DCG_GeneratorConfig_t> DCG_GeneratorConfigList_t;

   /** Gets the list of available SDI test signal generators and their configuration
     * Also returns the references for the SDI generators. These should be used to configure and route them later !!
     * To route a generator signal, the DCG_ApplyRoutings call should be used just as for any other routing.
     * @param[in]  BoardNbr specifies slot number
     * @param[in]  RefList when empty, configuration info for ALL generators are given. (first call when you don't know the references yet.
     * @param[out] ConfigList  The returned list of the SDI test sigal generators and their configurations.
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway board.
     * @exception OpNotSucceeded In case of
     * - Invalid references for generators
     * @version Release 7.0   
     */      
    void GetSDI_GeneratorConfigs(in unsigned short BoardNbr, in IPS_RefTS_List_t RefList, out DCG_GeneratorConfigList_t ConfigList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Configure a number of SDI test signal generators
     * @param[in] BoardNbr specifies slot number
     * @param[in] ConfigList  The list of the SDI test sigal generators and their configurations that need to be set.
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway board.
     * @exception OpNotSucceeded In case of
     * - Invalid references for generators
     * - invalid enum values
     * @version Release 7.0   
     */          
    void SetSDI_GeneratorConfigs(in unsigned short BoardNbr, in DCG_GeneratorConfigList_t ConfigList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);


    // IP Audio Gateway: AES Generator IDLs
    // ------------------------------------------------------------------------------------
    enum eAES_SampleRate_t
    {
      eAES_SampleRate_48kHz,
      eAES_SampleRate_Reserved1, ///< Future use        
      eAES_SampleRate_Reserved2, ///< Future use        
      eAES_SampleRate_Reserved3  ///< Future use        
    };
  
    enum eAES_WaveMode_t
    {
      eAES_WaveMode_PureTone,
      eAES_WaveMode_Reserved1, ///< Future use 
      eAES_WaveMode_Reserved2, ///< Future use 
      eAES_WaveMode_Reserved3  ///< Future use 
    };

    enum eAES_WaveModeDetail_t
    {
      eAES_PureTone_Silence,
      eAES_PureTone_100Hz,
      eAES_PureTone_500Hz,
      eAES_WaveModeDetail_Reserved1, ///< Future use 
      eAES_WaveModeDetail_Reserved2, ///< Future use 
      eAES_WaveModeDetail_Reserved3  ///< Future use 
    };

    struct DCG_AES_GeneratorConfig_t
    {
      IPS_RefTS_t           GeneratorRef; // Reference of AES generator - readonly !
      boolean               bGenEnabled;
      eAES_SampleRate_t     eSampleRate;
      eAES_WaveMode_t       eWaveMode; // Only wave mode 'ePureTone' is supported.
      eAES_WaveModeDetail_t eWaveModeDetail; // eSilence, 100Hz, or 500Hz.
      unsigned long         iGenPropertyBits; ///< Future use
    };
    
    typedef sequence<DCG_AES_GeneratorConfig_t> DCG_AES_GeneratorConfigList_t;

   /** Gets the list of available AES test signal generators and their configuration
     * Also returns the references for the AES generators. These should be used to configure and route them later !!
     * To route a generator signal, the DCG_ApplyRoutings call should be used just as for any other routing.
     * @param[in]  BoardNbr specifies slot number
     * @param[in]  RefList when empty, configuration info for ALL generators are given. (first call when you don't know the references yet.
     * @param[out] ConfigList  The returned list of the AES test sigal generators and their configurations.
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Audio Gateway board.
     * @exception OpNotSucceeded In case of
     * - Invalid references for generators
     * @version Release 11.10 
     */      
    void GetAES_GeneratorConfigs(in unsigned short BoardNbr, in IPS_RefTS_List_t RefList, out DCG_AES_GeneratorConfigList_t ConfigList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Configure a number of AES test signal generators
     * @param[in] BoardNbr specifies slot number
     * @param[in] ConfigList  The list of the AES test sigal generators and their configurations that need to be set.
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Audio Gateway board.
     * @exception OpNotSucceeded In case of
     * - Invalid references for generators
     * - invalid enum values
     *
     * @version Release 11.10 
     */          
    void SetAES_GeneratorConfigs(in unsigned short BoardNbr, in DCG_AES_GeneratorConfigList_t ConfigList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);


    // ------------------------------------------------------------------------------------


    enum eNegotiatedGbePortSpeed_t 
    {
      ePortSpeed_NotAvailable, // Link down, or AutoNegotiation is DISABLED
      ePortSpeed_10Mbs,
      ePortSpeed_100Mbs,
      ePortSpeed_1Gbps,
      ePortSpeed_10Gbps,
      ePortSpeed_Reserved1, //< Future use
      ePortSpeed_Reserved2  //< Future use
    };

    struct NegotiatedGbePortSpeed_t
    {
      IPS_Ref_t                 RefPhys; ///< port identifier
      eNegotiatedGbePortSpeed_t ePortSpeed;
    };

    typedef sequence<NegotiatedGbePortSpeed_t> NegotiatedGbePortSpeed_List_t;

    /** Retrieves the negotiated GbE port speeds for each GbE port.
     *
     * This method should be called whenever the 'Link Status' of a GbE port
     * has changed, because that is the only occasion when the negotiated speed
     * can change. The speed is 'ePortSpeed_NotAvailable' when autonegotiation
     * is set to DISABLED.
     *
     * @param[in] BoardNumber
     * @param[out] NegotiatedGbePortSpeedList The negotiated speed for
     *             each GbE port. The first item in the list applies to
     *             the first GbE port.
     *
     * @exception OpNotSupported When the specified board is not an IP Audio Gateway board.
     * @exception OperationFailed
     *
     * @version Release 11.10
     */
    void NegotiatedGbePortSpeed_GetL(in unsigned short BoardNumber, out NegotiatedGbePortSpeed_List_t NegotiatedGbePortSpeedList)
        raises(TimeOut, OpNotAllowed, OpNotSupported, OperationFailed);


    // ------------------------------------------------------------------------------------


    struct InTS_Statistic_t
    {
      IPS_RefTS_t     RefIn; // Reference of input
      unsigned long   crc_edh_1min;   // The counter saturate at 0xFFFF_FFFF
      unsigned long   crc_edh_1hour;  // -||-
      unsigned long   crc_edh_1day;   // -||-
    };

    typedef sequence<InTS_Statistic_t> InTS_Statistic_List_t;

    /** Applicable for release 7.5
     *
     * Get the statistics for the RefTS given in RefList.
     *
     * @param[in] SlotNumber which specifies the board to access
     * @param[in] RefList : The list for which to get statistics for - or ALL if empty.
     * @param[out] StatisticList : The list of statistic structures for the TS's specified in RefList.
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway.
     */
    void InTS_Statistic_GetL(in unsigned short SlotNumber,
			     in IPS_RefTS_List_t RefList,
			     out InTS_Statistic_List_t StatisticList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Applicable for release 7.5
     *
     * Reset statistics which can be retrieved by InTS_Statistic_GetL().
     *
     * @param[in] SlotNumber which specifies the board to access
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway.
     */
    void InTS_Statistic_Reset(in unsigned short SlotNumber)
      raises(TimeOut, OpNotAllowed, OpNotSupported, OperationFailed);

    struct InTS_AES_Statistic_t
    {
      IPS_RefTS_t     RefIn;                   ///< Reference of input
      unsigned long   pb_1min;                 ///< AES parity errors over the last minute
      unsigned long   pb_1hour;                ///< AES parity errors over the last hour
      unsigned long   pb_1day;                 ///< AES parity errors over the last day
      unsigned long   crc_ch_status_ch0_1min;  ///< AES channel 0 channel status CRC errors over the last minute
      unsigned long   crc_ch_status_ch0_1hour; ///< AES channel 0 channel status CRC errors over the last hour
      unsigned long   crc_ch_status_ch0_1day;  ///< AES channel 0 channel status CRC errors over the last day
      unsigned long   crc_ch_status_ch1_1min;  ///< AES channel 0 channel status CRC errors over the last minute
      unsigned long   crc_ch_status_ch1_1hour; ///< AES channel 0 channel status CRC errors over the last hour
      unsigned long   crc_ch_status_ch1_1day;  ///< AES channel 0 channel status CRC errors over the last day
    };

    typedef sequence<InTS_AES_Statistic_t> InTS_AES_Statistic_List_t;

    /** Applicable for release 11.10
     *
     * Get the parity and CRC error statistics for the RefTS given in RefList.
     *
     * @param[in] SlotNumber which specifies the board to access
     * @param[in] RefList : The list for which to get statistics for - or ALL if empty.
     * @param[out] StatisticList : The list of statistic structures for the TS's specified in RefList.
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Audio Gateway board.
     */
    void InTS_AES_Statistic_GetL(in unsigned short SlotNumber,
			     in IPS_RefTS_List_t RefList,
			     out InTS_AES_Statistic_List_t StatisticList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Applicable for release 11.10
     *
     * Reset statistics which can be retrieved by InTS_AES_Statistic_GetL().
     *
     * @param[in] SlotNumber which specifies the board to access
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Audio Gateway board.
     */
    void InTS_AES_Statistic_Reset(in unsigned short SlotNumber)
      raises(TimeOut, OpNotAllowed, OpNotSupported, OperationFailed);

    /**
     * IDLs for imlementing Stream backup on the IP Adapter
     **/
    
    
    /******************** BU Params ***************************/
    
    enum eDCG_StreamBackupMode_t
    {
        eNonRevertive,  // Switch to backup when main fails. Do not switch back.
        eRevertive,     // Switch to backup when main fails. Switch back when main is OK (after delay).
        eFloating,      // Switch to backup when main fails. Switch back when backup fails.
        eReserved1,     // future use
        eReserved2,     // future use
        eReserved3,     // future use
        eReserved4,     // future use
        eReserved5      // future use
    };
    
    struct DCG_StreamBackupParams_t
    {
      IPS_RefTS_t Ref;                       // Reference to output stream for which the parameters should be set
      eDCG_StreamBackupMode_t  BU_Mode;
      unsigned long HighToLowPriorityDelay;  // time in seconds to wait before switching to backup
      unsigned long LowToHighPriorityDelay;  // time in seconds to wait before switching back to main input
    };
    
    typedef sequence<DCG_StreamBackupParams_t> DCG_StreamBackupParamsList_t;
    
    /** Sets the StreamBackup parameters for an output service.
     * 
     * @param[in] RefPhys specifies BoardNr and PortNr
     * @param[in] StreamBackupParamsList specifies BU-parameters for the referenced output stream (Ref)
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway board.
     * @exception OpNotSucceeded in case of
     * - Invalid OutStream reference (BoardNr, PortNr, TS)
     * - Invalid mode specified in the StreamBackupParams
     * 
     * @version Release 8.0
     */
    void DCG_SetStreamBU_Params(in IPS_Ref_t RefPhys, in DCG_StreamBackupParamsList_t StreamBackupParamsList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);
    
    /** Get the StreamBackup parameters for an output service.
     * 
     * @param[in] RefPhys specifies BoardNr and PortNr
     *                      - wildcard for port allowed with empty RefList
     * @param[in] RefList List of (output) references for which to get the parameters
     * 
     * @return DCG_StreamBackupParamsList_t, a sequence of DCG_StreamBackupParams_t entries as specified in RefList.
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway board.
     * @exception OpNotSucceeded in case of
     * - Invalid OutStream reference (BoardNr, PortNr, TS)
     * 
     * @version Release 7.5
     */
    DCG_StreamBackupParamsList_t DCG_GetStreamBU_Params(in IPS_Ref_t RefPhys, in Ref_List_t RefList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);
    
    
    /******************** BU Source ***************************/
    
    struct DCG_BackupStream_t
    {
      IPS_RefTS_t OutRef;
      IPS_RefTS_t BackupStream; // Ref = 0xFFFF = No backup stream configured
    };
    
    typedef sequence<DCG_BackupStream_t> DCG_BackupStreamList_t;
    
    /** Sets the backup streams for each output stream.
     * 
     * @param[in] RefPhys specifies BoardNr and PortNr
     * @param[in] BU_StreamList specifies pairs of Main and Backup streams
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway board.
     * @exception OpNotSucceeded in case of
     * - Invalid OutStream reference (BoardNr, PortNr, TS)
     * 
     * @version Release 7.5
     */
    void DCG_SetBU_Streams(in IPS_Ref_t RefPhys, in DCG_BackupStreamList_t BU_StreamList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);
    
    /** Get the configured main/backup pairs for the requested reference.
     * 
     * @param[in] RefPhys specifies BoardNr and PortNr
     *                      - wildcard for port allowed with empty RefList
     * @param[in] RefList List of (output) references for which to get the backup streams
     * 
     * @return DCG_BackupStreamList_t, a sequence of DCG_BackupStream_t entries holding main/backup pairs as specified in RefList.
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway board.
     * @exception OpNotSucceeded in case of
     * - Invalid OutStream reference (BoardNr, PortNr, TS)
     * 
     * @version Release 7.5
     */
    DCG_BackupStreamList_t DCG_GetBU_Streams(in IPS_Ref_t RefPhys, in Ref_List_t RefList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);
    
    
    /** Sets the active stream for the specified output.
     * 
     * @param[in] OutStream         Output stream for which to set the active input stream    
     * @param[in] ActiveInStream    Input stream to activate
     * 
     * Note: if SwitchToGoodSrcOnly is True then the active input is not switched if the selected input is in error.
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway board.
     * @exception OpNotSucceeded in case of
     * - Invalid OutStream reference (BoardNr, PortNr, TS)
     * - Invalid ActiveInStream reference (BoardNr, PortNr, TS)
     * 
     * @version Release 7.5
     */
    void DCG_SetActiveInputStream(in IPS_RefTS_t OutStream, in IPS_RefTS_t ActiveInStream)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);
    
    /** Get the active stream for the specified output.
     * 
     * @param[in] OutStream         Output stream for which to set the active input stream    
     * @param[out] ActiveInStream   Active input stream
     * 
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway board.
     * @exception OpNotSucceeded in case of
     * - Invalid OutStream reference (BoardNr, PortNr, TS)
     * - Invalid ActiveInStream reference (BoardNr, PortNr, TS)
     * 
     * @version Release 7.5
     */
    void DCG_GetActiveInputStream(in IPS_RefTS_t OutStream, out IPS_RefTS_t ActiveInStream)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);
    
    enum enDCG_3G_Topology_t
    {
      eNo3G,            // 6 SD/HD Streams Only
      eOne3G,           // 4 SD/HD + 1 3G Streams
      eTwo3G,           // 2 SD/HD + 2 3G Streams
      eThree3G,         // 3G Streams Only
      eReserved_DCG_3G_1, //reserved for future use
      eReserved_DCG_3G_2, //reserved for future use
      eReserved_DCG_3G_3  //reserved for future use
    };

    struct DCG_Possible3GBoardCfg_t
    {
      boolean               isPossible;  ///< Is it possible to apply this board configuration
      enDCG_3G_Topology_t   Cfg_3G;
    };
    typedef sequence<DCG_Possible3GBoardCfg_t> DCG_Possible3GBoardCfgList_t;

    /** Set IPGW board configuration for 3G streams
     *
     * @param[in] SlotNumber   Slot number
     * @param[in] BoardCfg_3G  Specifies the allowed number of 3G streams on the board.
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway board.
     * @exception OpNotSucceeded In case of
     *
     * @note 
     * - Switching speed mode will cause a  firmware reset and thus is service affecting !!
    * @version Release 8.1      
     */
    void BoardCfgSet3GTopology(in unsigned short SlotNumber, in enDCG_3G_Topology_t BoardCfg_3G) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Get IPGW board configuration for 3G streams
     *
     * @param[in]  SlotNumber  Slot number
     * @param[out] BoardCfg_3G The allowed number of 3G streams on the board.
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway board.
     * @exception OpNotSucceeded In case of
     *
     * @version Release 8.1
     */
    void BoardCfgGet3GTopology(in unsigned short SlotNumber, out enDCG_3G_Topology_t BoardCfg_3G) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);


    /** Get a list of all board configurations and whether they can be applied or not.
     *
     * @param[in]  SlotNumber               The IPGW board to retrieve the settings from.
     * @param[out] BoardCfgList_3G          A list of all board configurations.
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway board.
     * 
     * @version Release 8.1
     **/
    void GetPossible3GTopology(in unsigned short SlotNumber, out DCG_Possible3GBoardCfgList_t BoardCfgList_3G) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);


    /**
     * IDLs for imlementing JPEG2000 functionality on the IP Gateway
     **/
    /********************************************
     * Audio
     *******************************************/
    typedef unsigned long DCG_AudioID_t;

     /// Describes Status of an audio channel (left or right).
    enum enDCG_AudioStatus_t
    {
      eAudioSt_NotPresent,      // No Audio channel present
      eAudioSt_Present,         // Audio channel present
      eAudioSt_Error            // Audio channel has error
    };

    enum enDCG_AudioResolution_t
    {
      eDCG_AudioResolution_20bit,
      eDCG_AudioResolution_24bit,
      eDCG_AudioResolution_Invalid,
      eReserved_AudioResolution1 // For future use
    };
 
    struct DCG_AudioPairInfo_t
    {
        DCG_AudioID_t       AudioPairId;        // 1 = Pair 1-1, 2 = pair 1-2, 3 = pair 2-1, ...etc
        boolean             AudioPairEnable;    // Enable Audio pair on JP2K output
        boolean             AudioPairPresent;   // This audio pair is present at the input
        enDCG_AudioResolution_t AudioResolution;
        unsigned long       AudioSampleRate;
        unsigned long       AudioBitRate;
        enDCG_AudioStatus_t StatusRightCh;      // Input status for right channel. Optional: not for R8.1
        enDCG_AudioStatus_t StatusLeftCh;       // Input status for left channel. Optional: not for R8.1
    };

    typedef sequence<DCG_AudioPairInfo_t> DCG_AudioPairInfo_List_t;

    /// Describes the audio signal information
    struct DCG_AudioSignalInfo_t
    {
      IPS_RefTS_t     RefIn;                  ///< Reference of input stream
      boolean         Valid;                  ///< Valid status
      unsigned long   SampleRate;             ///< Sample rate (Hz)
      unsigned long   Bitrate;                ///< Bitrate of audio signal (bit/s), future!
      enDCG_AudioResolution_t LeftChCoding;   ///< Resolution of audio left channel
      enDCG_AudioResolution_t RightChCoding;  ///< Resolution of audio right channel
    };

    typedef sequence<DCG_AudioSignalInfo_t> DCG_AudioSignalInfoList_t;

    /**
     * Gets the (audio) signal information from an input AES signal.
     *
     * @param[in]  BoardNr  specifies slot number
     * @param[in]  RefList  when empty, the audio signal info for ALL valid inputs's are given.
     * @param[out] SignalInfoList the returned audio signal information
     *
     * @exception OpNotSupported When BoardNr is not an IP Audio Gateway board
     * @exception OpNotSucceeded In case of invalid input references
     * @exception OperationFailed
     *
     * @version Release 11.10
     **/
    void DCG_GetAudioSignalInfo(in unsigned short BoardNr, in IPS_RefTS_List_t RefList, out DCG_AudioSignalInfoList_t SignalInfoList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);
 
    /********************************************
     * JPEG2000 Parameters
     *******************************************/

    enum enDCG_CompressionMode_t
    {
      eUncompressed,    // Disable compression (RTP only)
      eEnableJP2K,      // Enable JPEG2000 compression
      eCompressionEnable_Reserved1,  // For future use
      eCompressionEnable_Reserved2,  // For future use
      eCompressionEnable_Reserved3,  // For future use
      eCompressionEnable_Reserved4   // For future use
    };

    struct DCG_CompressionEnable_t
    {
      IPS_RefTS_t              VideoRef;       // Reference of the video stream
      enDCG_CompressionMode_t  CompressMode;   // Enable compression and set the type of compression
    };

    typedef sequence<DCG_CompressionEnable_t> DCG_CompressionEnableList_t;

    /** Gets the Compression setting for RTP streams
    *
    * @param[in]  RefPhys specifies slot number
    * @param[in]  RefList  when empty, the compression setting for all streams are given.
    * @param[out] CompressionEnableList  The returned compression setting
    *
    * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway board.
    * @exception OpNotSucceeded In case of invalid references for RTP stream
    * @version Release 8.1  
    */  
    void DCG_GetCompressionMode(in IPS_Ref_t RefPhys, in Ref_List_t RefList, out DCG_CompressionEnableList_t CompressionEnableList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Sets the compression setting for RTP streams
    * This function can be used for input as well as output streams.
    * For input streams, when enabling compression, if the dejitter buffer was
    * set to less than 7. it will be changed to 7.
    *
    * @param[in]  RefPhys  Specifies slot number
    * @param[out] CompressionEnableList  List of compression settings to set
    *
    * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway board.
    * @exception OpNotSucceeded In case of invalid references for RTP streams
    * @version Release 8.1  
    */
    void DCG_SetCompressionMode(in IPS_Ref_t RefPhys, in DCG_CompressionEnableList_t CompressionEnableList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);


    enum enDCG_JP2K_EncapsulationType_t
    {
      eDCG_JP2K_EncapsulationType_MXF,
      eDCG_JP2K_EncapsulationType_Mpeg2,
      eDCG_JP2K_EncapsulationType_Reserved1, // For future use
      eDCG_JP2K_EncapsulationType_Reserved2, // For future use
      eDCG_JP2K_EncapsulationType_Reserved3, // For future use
      eDCG_JP2K_EncapsulationType_Reserved4, // For future use
      eDCG_JP2K_EncapsulationType_Reserved5  // For future use
    };

    typedef sequence<enDCG_JP2K_EncapsulationType_t> DCG_JP2K_EncapsulationTypeList_t;

    /** Gets the auto-detected encapsulation type per RTP stream.
    *
    * @param[in]  RefPhys specifies slot number
    * @param[in]  RefList  when empty, the compression setting for all streams are given.
    * @param[out] EncapsulationTypeList  The returned encapsulation types.
    *
    * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway board.
    * @exception OpNotSucceeded In case of invalid references for RTP stream
    * @version Release 12.0
    */  
    void DCG_GetJP2K_EncapsulationType(in IPS_Ref_t RefPhys, in Ref_List_t RefList, out DCG_JP2K_EncapsulationTypeList_t EncapsulationTypeList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);


    enum enDCG_JP2K_CompressionMode_t
    {
      e9_7,      // Irreversible 9/7
      e5_3,      // Reversible 5/3 (For future use)
      eJP2K_CompressionMode_Reserved  // For future use
    };

    typedef sequence<unsigned short> DCG_VBI_Lines_t;

    struct DCG_VBI_Defs_t
    {
      DCG_VBI_Lines_t           TransperentLines525f1;  // 525 field1 Range 10..19
      DCG_VBI_Lines_t           TransperentLines525f2;  // 525: field2 Range 10..18
      DCG_VBI_Lines_t           TransperentLines625f1;  // 625: field1 Range 6..23
      DCG_VBI_Lines_t           TransperentLines625f2;  // 625: field2 Range 319..335
    };

    struct DCG_JP2K_params_t
    {
      IPS_RefTS_t                   VideoRef;       // Reference of the video stream
      enDCG_JP2K_CompressionMode_t  CompressMode;   // Enable compression and set the type of compression
      unsigned long                 VideoRate;      // Actual encoded rate [bps]. Read only.
      unsigned short                ChromaWeight;   // Percentage of compressed bit rate used for chroma data. Range: 5-30 % 
      unsigned long                 MaxStreamBitRate; // Maximum bit rate of an JP2K output stream incl. audio, MXF, and RTP overhead [bps]
                                                      // ASI range [10-213 Mbps], GbE range [10-900 Mbps]
      DCG_AudioPairInfo_List_t      AudioSettings;
      boolean                       bEnableVITC;
      boolean                       bEnableVII;
      boolean                       bEnableAFD;
      boolean                       bEnableTeleText;
      boolean                       bEnableClosedCaption;
      DCG_VBI_Defs_t                VBISettings;    // Disable = No lines defined (VBI_Lines_t are empty).
    };

    typedef sequence<DCG_JP2K_params_t> DCG_JP2K_paramsList_t;


    struct DCG_JP2K_params_V2_t
    {
      IPS_RefTS_t                   VideoRef;       // Reference of the video stream
      enDCG_JP2K_CompressionMode_t  CompressMode;   // Enable compression and set the type of compression
      unsigned long                 VideoRate;      // Actual encoded rate [bps]. Read only.
      unsigned short                ChromaWeight;   // Percentage of compressed bit rate used for chroma data. Range: 5-30 % 
      unsigned long                 MaxStreamBitRate; // Maximum bit rate of an JP2K output stream incl. audio, MXF, and RTP overhead [bps]
                                                      // ASI range [10-213 Mbps], GbE range [10-900 Mbps]
      DCG_AudioPairInfo_List_t      AudioSettings;
      boolean                       bEnableVITC;
      boolean                       bEnableVII;
      boolean                       bEnableAFD;
      boolean                       bEnableTeleText;
      boolean                       bEnableClosedCaption;
      DCG_VBI_Defs_t                VBISettings;    // Disable = No lines defined (VBI_Lines_t are empty).
      boolean                       bEnableVPS;
    };

    typedef sequence<DCG_JP2K_params_V2_t> DCG_JP2K_paramsList_V2_t;


    struct DCG_JP2K_params_V3_t
    {
      IPS_RefTS_t                   VideoRef;       // Reference of the video stream
      enDCG_JP2K_CompressionMode_t  CompressMode;   // Enable compression and set the type of compression
      unsigned long                 VideoRate;      // Actual encoded rate [bps]. Read only.
      unsigned short                ChromaWeight;   // Percentage of compressed bit rate used for chroma data. Range: 5-30 % 
      unsigned long                 MaxStreamBitRate; // Maximum bit rate of an JP2K output stream incl. audio, MXF, and RTP overhead [bps]
                                                      // ASI range [10-213 Mbps], GbE range [10-900 Mbps]
      DCG_AudioPairInfo_List_t      AudioSettings;
      boolean                       bEnableVITC;
      boolean                       bEnableVII;
      boolean                       bEnableAFD;
      boolean                       bEnableTeleText;
      boolean                       bEnableClosedCaption;
      DCG_VBI_Defs_t                VBISettings;    // Disable = No lines defined (VBI_Lines_t are empty).
      boolean                       bEnableVPS;
      boolean                       bSDI20BitAudio; // Force 20-bit Audio Resolution Mode for SDI 
    };

    typedef sequence<DCG_JP2K_params_V3_t> DCG_JP2K_paramsList_V3_t;


    struct DCG_JP2K_params_V4_t
    {
      IPS_RefTS_t                    VideoRef;       // Reference of the video stream
      enDCG_JP2K_CompressionMode_t   CompressMode;   // Enable compression and set the type of compression
      unsigned long                  VideoRate;      // Actual encoded rate [bps]. Read only.
      unsigned short                 ChromaWeight;   // Percentage of compressed bit rate used for chroma data. Range: 5-30 % 
      unsigned long                  MaxStreamBitRate; // Maximum bit rate of an JP2K output stream incl. audio, MXF, and RTP overhead [bps]
                                                       // ASI range [10-213 Mbps], GbE range [10-900 Mbps]
      DCG_AudioPairInfo_List_t       AudioSettings;
      boolean                        bEnableVITC;
      boolean                        bEnableVII;
      boolean                        bEnableAFD;
      boolean                        bEnableTeleText;
      boolean                        bEnableClosedCaption;
      DCG_VBI_Defs_t                 VBISettings;    // Disable = No lines defined (VBI_Lines_t are empty).
      boolean                        bEnableVPS;
      boolean                        bSDI20BitAudio; // Force 20-bit Audio Resolution Mode for SDI 
      enDCG_JP2K_EncapsulationType_t EncapsulationType;
    };

    typedef sequence<DCG_JP2K_params_V4_t> DCG_JP2K_paramsList_V4_t;


    /** Gets the JPEG2000 settings from an output JP2K stream
    *
    * @param[in]  RefPhys specifies slot number
    * @param[in]  RefList  when empty, the JPEG2000 settings for ALL JP2K output streams are given.
    * @param[out] JP2K_paramsList  The returned JPEG2000 settings
    *
    * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway board.
    * @exception OpNotSucceeded In case of Invalid references for JP2K stream
    * @version Release 8.1  
    */  
    void DCG_GetJP2K_Params(in IPS_Ref_t RefPhys, in Ref_List_t RefList, out DCG_JP2K_paramsList_t JP2K_paramsList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** This function is similar to DCG_GetJP2K_Params() above, except for the list of elements
    *   returned is not a list of DCG_JP2K_paramsList_t but a list of DCG_JP2K_paramsList_V2_t
    *   which differs in that the latter has the extra 'bEnableVPS' property.
    *  Except for this all other things are equal.
    *
    * @version Release 8.7
    */
    void DCG_GetJP2K_Params_V2(in IPS_Ref_t RefPhys, in Ref_List_t RefList, out DCG_JP2K_paramsList_V2_t JP2K_paramsList)
       raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** This function is similar to DCG_GetJP2K_Params_V2() above, except for the list of elements
    *  returned is not a list of DCG_JP2K_paramsList_V2_t but a list of DCG_JP2K_paramsList_V3_t
    *  which differs in that the latter has the extra 'bSDI20BitAudio' property.
    *  Except for this all other things are equal.
    *
    * @param[in]  RefPhys specifies slot number
    * @param[in]  RefList  when empty, the JPEG2000 settings for ALL JP2K output streams are given.
    * @param[out] JP2K_paramsList  The returned JPEG2000 settings
    *
    * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway board.
    * @exception OpNotSucceeded In case of Invalid references for JP2K stream
    * @version Release 11.10
    *
    * @deprecated Since version 12.0, use DCG_GetJP2K_Params_V4 instead.
    */
    void DCG_GetJP2K_Params_V3(in IPS_Ref_t RefPhys, in Ref_List_t RefList, out DCG_JP2K_paramsList_V3_t JP2K_paramsList)
       raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** This function is similar to DCG_GetJP2K_Params_V3() above, except for the list of elements
    *  returned is not a list of DCG_JP2K_paramsList_V3_t but a list of DCG_JP2K_paramsList_V4_t
    *  which differs in that the latter has the extra 'EncapsulationType' property.
    *  Except for this all other things are equal.
    *
    * @param[in]  RefPhys specifies slot number
    * @param[in]  RefList  when empty, the JPEG2000 settings for ALL JP2K output streams are given.
    * @param[out] JP2K_paramsList  The returned JPEG2000 settings
    *
    * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway board.
    * @exception OpNotSucceeded In case of Invalid references for JP2K stream
    *
    * @version Release 12.00
    */
    void DCG_GetJP2K_Params_V4(in IPS_Ref_t RefPhys, in Ref_List_t RefList, out DCG_JP2K_paramsList_V4_t JP2K_paramsList)
       raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Sets the JPEG200 parameters for an output JP2K stream
    *
    * @param[in]  RefPhys  Specifies slot number
    * @param[out] JP2K_paramsList  List of JPEG2000 settings to set
    *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway board.
    * @exception OpNotSucceeded In case of Invalid references for JP2K streams
    * @version Release 8.1  
    */
    void DCG_SetJP2K_Params(in IPS_Ref_t RefPhys, in DCG_JP2K_paramsList_t JP2K_paramsList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);


    /** This function is similar to DCG_SetJP2K_Params() above, except for the list of elements
    *   returned is not a list of DCG_JP2K_paramsList_t but a list of DCG_JP2K_paramsList_V2_t
    *   which differs in that the latter have an extra tributriy, bEnableVPS.
    *  Except for this all other things are equal.
    *
    * @version Release 8.7
    */
    void DCG_SetJP2K_Params_V2(in IPS_Ref_t RefPhys, in DCG_JP2K_paramsList_V2_t JP2K_paramsList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** This function is similar to DCG_SetJP2K_Params_V2() above, except for the list of elements
    *   input is not a list of DCG_JP2K_paramsList_V2_t but a list of DCG_JP2K_paramsList_V3_t
    *   which differs in that the latter have an extra element, bSDI20BitAudio.
    *  Except for this all other things are equal.
    *
    * @version Release 11.10
    *
    * @deprecated Since version 12.0, use DCG_SetJP2K_Params_V4 instead.
    */
    void DCG_SetJP2K_Params_V3(in IPS_Ref_t RefPhys, in DCG_JP2K_paramsList_V3_t JP2K_paramsList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** This function is similar to DCG_SetJP2K_Params_V3() above, except for the list of elements
    *   input is not a list of DCG_JP2K_paramsList_V3_t but a list of DCG_JP2K_paramsList_V4_t
    *   which differs in that the latter has the extra 'EncapsulationType' property.
    *  Except for this all other things are equal.
    *
    * @version Release 12.00
    */
    void DCG_SetJP2K_Params_V4(in IPS_Ref_t RefPhys, in DCG_JP2K_paramsList_V4_t JP2K_paramsList)
      raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);


    /********************************************
     * JPEG2000 Board Setup
     *******************************************/

    enum enDCG_JP2K_Topology_t
    {
      e3Dec_3Enc, // 3 encoding engines + 3 decoding engines. For future use
      e3Dec,      // 3 decoding engines
      e3Enc,      // 3 encoding engines (Default)
      e6Dec,      // For future use
      e6Enc,      // For future use
      eTopology_JP2K_Reserved1,   // For future use
      eTopology_JP2K_Reserved2,   // For future use
      eTopology_JP2K_Reserved3,   // For future use
      eTopology_JP2K_Reserved4,   // For future use
      eTopology_JP2K_Reserved5,   // For future use
      eTopology_JP2K_Reserved6   // For future use
    };

    /** Set JPEG 2000 board configuration
     *
     * @param[in] SlotNumber   Slot number
     * @param[in] JP2K_Topology  Specifies the topology of the JPEG 2000 board.
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway board.
     * @exception OpNotSucceeded In case of
     *
     * @note 
     * - Switching speed mode will cause a  firmware reset and thus is service affecting !!
    * @version Release 8.1      
     */
    void BoardCfgSetJP2KTopology(in unsigned short SlotNumber, in enDCG_JP2K_Topology_t JP2K_Topology) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /** Get JPEG 2000 board configuration
     *
     * @param[in]  SlotNumber  Slot number
     * @param[out] JP2K_BoardCfg  The topology of the JPEG 2000 board.
     *
     * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Gateway board.
     * @exception OpNotSucceeded In case of
     *
     * @version Release 8.1
     */
    void BoardCfgGetJP2KTopology(in unsigned short SlotNumber, out enDCG_JP2K_Topology_t JP2K_BoardCfg) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

    /********************************************
     * Hitless Switch Over Parameters
     *******************************************/

    enum enDCG_HitlessSwitchOverMode_t
    {
      eDisableHitlessSwitchOver,  // Disable HitlessSwitchOver (RTP only)
      eEnableHitlessSwitchOver,   // Enable HitlessSwitchOver
      eHitlessReserved1,          // Reserved for future used
      eHitlessReserved2,          // Reserved for future used
      eHitlessReserved3,          // Reserved for future used
      eHitlessReserved4           // Reserved for future used
    };
    

 

    struct DCG_HitlessSwitchOverEnable_t
    {
      IPS_RefTS_t              VideoRef;       // Reference of the video stream
      enDCG_HitlessSwitchOverMode_t  hitlessSwitchOverMode;   // Enable HitlessSwitchOver 
      unsigned long  RtpPacketsWindow;    // Rtp Packets Window. Write only
      unsigned long  delay;               //Delay in ms corresponding to RTP packet window. Read only
    };

 

    typedef sequence<DCG_HitlessSwitchOverEnable_t> DCG_HitlessSwitchOverEnable_List_t;

 

    /** Gets the HitlessSwitchOver setting for RTP streams
    *
    * @param[in]  RefPhys specifies slot number
    * @param[in]  RefList  when empty, the HitlessSwitchOver setting for all streams are given.
    * @param[out] HitlessSwitchOverEnableList  returns HitlessSwitchOver settings
    *
    * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Adapter or IP Audio Gateway.
    * @exception OpNotSucceeded In case of Invalid references for RTP stream
    * @version Release 8.1  
    */  
    void DCG_GetHitlessSwitchOverMode(in IPS_Ref_t RefPhys, in Ref_List_t RefList, out DCG_HitlessSwitchOverEnable_List_t HitlessSwitchOverEnableList)
               raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed);

 

    /** Sets the HitlessSwitchOver setting for RTP streams
    *
    * @param[in]  RefPhys  Specifies slot number
    * @param[out] HitlessSwitchOverEnableList  List of HitlessSwitchOver settings to set
    *
    * @exception OpNotSupported When BoardNumber = 0 = Main board or when the board is not an IP Video Adapter or IP Audio Gateway.
    * @exception OpNotSucceeded In case of Invalid references for RTP streams
    * @exception LicenseError    - When the appropriate license is not installed
    *                            - Not enough licenses of this type available
    * @version Release 8.1  
    */
    void DCG_SetHitlessSwitchOverMode(in IPS_Ref_t RefPhys, in DCG_HitlessSwitchOverEnable_List_t HitlessSwitchOverEnableList)
               raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OperationFailed, LicenseError);




    /// @} end of group ipa IP Adapter    
    //////////////////////////////////////////////////////////////
    // END OF IP ADAPTER IDLs
    //////////////////////////////////////////////////////////////                                          
#endif // DISABLE_IPGW
#ifndef DISABLE_GPI
    /** 
     * @defgroup GPI General Purpose interface
     * This contains types, enums and methods to get/set GPI settings.
     * @{
     **/

    // ------------------------------------------------------------------------------------
    // GPI structures & enums
    // ------------------------------------------------------------------------------------
    const unsigned long CONTACT_COUNT = 5;

    enum eGPI_IO_t
    {
      eInput,                      ///< gpi pin used as input
      eOutput                      ///< gpi pin used as output
    };

    enum eGPI_Assert_t
    {
      eLow,                        ///< gpi pin active low
      eHigh                        ///< gpi pin active high
    };

    struct GPI_Settings_t
    {
      unsigned short   Number;     ///< gpi pin number (1 to 5)
      string           Name;       ///< name of the gpi pin indicating the function
      eGPI_IO_t        Direction;  ///< gpi pin direction
      eGPI_Assert_t    Assert;     ///< gpi assert level
      boolean          Enabled;    ///< gpi contact enabled if true
    };
    
    typedef sequence<GPI_Settings_t>  GPI_SettingsList_t;

    struct GPI_StatusControl_t
    {
      boolean          SettingsChanged; ///< gpi pin configuration changed
      unsigned short   Number;          ///< gpi pin number
      unsigned short   Status;          ///< current gpi pin status   (readout pin)  
      unsigned short   Control;         ///< current gpi pin control  (drive pin) 
      unsigned long    TimeStamp;       /**< gpi local timestamp, changed status 
                                             (seconds since 00:00:00 UTC, January 1, 1970) */
      unsigned long    TimeStampOffset; ///< offset in microseconds since TimeStamp
    };

    typedef sequence<GPI_StatusControl_t> GPI_StatusControlList_t;


    // ------------------------------------------------------------------------------------
    // GPI IDLs
    // ------------------------------------------------------------------------------------
    /** Gets the settings for the 5 contacts
     *
     * @return    GPI_SettingsList_t List of GPI_Settings_t
     *
     * @exception TimeOut         A timeout occurred during IIOP processing
     * @exception OpNotSucceeded  Internal error
     * @exception OpNotAllowed    Not logged in
     * @exception OpNotSupported  Thrown if this call is not supported in the
     *                            running software version
     *
     * @version   Release 7.1
     *
     */
    GPI_SettingsList_t GetGpiSettings()
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Sets the settings for the 5 contacts
     *
     * @param[in]                 GpiSettingsList List of GPI_Settings_t
     *
     * @exception TimeOut         A timeout occurred during IIOP processing
     * @exception OpNotSucceeded  Internal error
     * @exception OpNotAllowed    Not logged in
     * @exception OpNotSupported  Thrown if this call is not supported in the
     *                            running software version
     * @exception LicenseError    - When the appropriate license is not installed
     *                            - Not enough licenses of this type available
     * @exception OutOfRange      Too many elements in the specified list
     *
     * @version   Release 7.1
     *
     */
    void SetGpiSettings(in GPI_SettingsList_t GpiSettingsList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, LicenseError, OutOfRange);

    /** Gets the number of the contact used for rebooting the device
     *
     * @return                    Number of the contact; 0 in case no number has
     *                            been set
     *
     * @exception TimeOut         A timeout occurred during IIOP processing
     * @exception OpNotSucceeded  Internal error
     * @exception OpNotAllowed    Not logged in
     * @exception OpNotSupported  Thrown if this call is not supported in the
     *                            running software version
     *
     * @version   Release 7.1
     *
     */
    unsigned short GetGpiRebootContact()
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /** Sets the number of the contact used for rebooting the device
     *
     * @param[in]                 ContactNumber of the contact
     *
     * @exception TimeOut         A timeout occurred during IIOP processing
     * @exception OpNotSucceeded  Internal error
     * @exception OpNotAllowed    Not logged in
     * @exception OpNotSupported  Thrown if this call is not supported in the
     *                            running software version
     * @exception OutOfRange      A contact with the given number does not exist
     *
     * @version   Release 7.1
     *
     */
    void SetGpiRebootContact(in unsigned short ContactNumber)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported, OutOfRange);

    /** Queries the status of the 5 contacts
     *
     * @return                    GPI_StatusControlList_t List of GPI_StatusControl_t
     *
     * @exception TimeOut         A timeout occurred during IIOP processing
     * @exception OpNotSucceeded  Internal error
     * @exception OpNotAllowed    Not logged in
     * @exception OpNotSupported  Thrown if this call is not supported in the
     *                            running software version
     *
     * @version   Release 7.1
     *
     */
    GPI_StatusControlList_t GetGpi()
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);        

    /** Sets the status of the 5 contacts
     * Only the Number and Status or Control member of GPI_StatusControl_t are taken into
     * account, the other members are ignored in this call.
     *
     * @param[in]                 GPiStatusList List of GPI_StatusControl_t
     *
     * @exception TimeOut         A timeout occurred during IIOP processing
     * @exception OpNotSucceeded  Internal error
     * @exception OpNotAllowed    Not logged in
     * @exception OpNotSupported  Thrown if this call is not supported in the
     *                            running software version
     *
     * @version   Release 7.1
     *
     */
    // For internal use only
    void SetGpi(in GPI_StatusControlList_t GPiStatusList)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /**
     * Sets the Gpi Pin that is used to identify the device for customer specific Scte53 commands
     * When the selected pin is asserted, the board will handle customer specific Scte35 commands
     * targeted for the backup/secondary device.
     *
     * @param [in] BoardNumber : The board number for which to set the identifier select pin
     * @param [in] GpiPinNumber : The Gpi pin number that selects the device identifier (valid values 2..5), 0 means no pin configured.
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     * @exception OpNotSucceeded In case
     * - invalid GpiPinNumber is used
     *
     * @version Release 7.1
     */
    void FCS_SetDeviceIdSelectGpiPin(in unsigned short BoardNumber, in unsigned short GpiPinNumber )
          raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);


    /**
     * Gets the Gpi Pin that is used to identify the device for customer specific Scte53 commands
     *
     * @param [in] BoardNumber : The board number for which to set the identifier select pin
     * @param [out] GpiPinNumber : The Gpi pin number that selects the device identifier (valid values 2..5), 0 means no pin configured..
     *
     * @exception OpNotSupported When BoardNr = 0 = Main board.
     *
     * @version Release 7.1
     */
    void FCS_GetDeviceIdSelectGpiPin(in unsigned short BoardNumber, out unsigned short GpiPinNumber )
          raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);

    /// @} end of GPI

#endif // DISABLE_GPI
#ifndef DISABLE_SCRIPT

    /** @defgroup Script Engine
     * Contains methods to control the Script Engine
     * @{
     **/


    // ------------------------------------------------------------------------------------
    // Script Engine structures & enums
    // ------------------------------------------------------------------------------------
    struct ScriptEntry_t
    {
      unsigned long ScriptId;           ///< The Id assigned to this script
      string ScriptName;		        ///< The unique name of the script
      unsigned short ScriptVersion;	    ///< The version of the script, several versions of the same script can be installed
      boolean Running;		            ///< Whether script is currently running
      boolean AutoRun;                  ///< Whether the script will be automatically run on startup
    };
    typedef sequence<ScriptEntry_t> ScriptEntryList_t;


    // ------------------------------------------------------------------------------------
    // Script Engine IDLs
    // ------------------------------------------------------------------------------------


    /** Add a new script to the the list of installed scripts
    *
    * @param [in] ScriptContents The full script, with description and signature
    *
    * @exception OpNotSucceeded : Script couldn't be verified
	  * @exception LicenseError : when the appropriate license is not installed
    *
    * @version release 8.2
    **/
    void AddNewScript(in ByteStream ScriptContents)
        raises(TimeOut, OpNotSucceeded, LicenseError);
    
    /** Delete an existing script
    *
    * @param [in] ScriptId The ID assigned to the script
    *
    * @exception OpNotSucceeded : Script was not in the list
	  * @exception LicenseError : when the appropriate license is not installed
    *
    * @version release 8.2
    **/
    void DeleteScript(in unsigned long ScriptId)
        raises(TimeOut, OpNotSucceeded, LicenseError);
    
    /** Get the list of currently installed scripts
    *
    * @param [out] ScriptList list of all scripts currently installed
    *
	  * @exception LicenseError : when the appropriate license is not installed
    *
    * @version release 8.2
    **/
    void GetScriptsList(out ScriptEntryList_t ScriptList)
        raises(TimeOut, LicenseError);
    
    
    /** Run an existing script
    *
    * @param [in] ScriptId The ID assigned to the script
    *
    * @exception OpNotSucceeded : Script was not in the list
    * @exception OpNotAllowed : Script is allready running
	  * @exception LicenseError : when the appropriate license is not installed
    *
    * @version release 8.2
    **/
    void RunScript(in unsigned long ScriptId)
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, LicenseError);
    
    /** Upload a file to be used by the script (resource, config file,...)
    *
    * @param [in] ScriptId The ID assigned to the script
    * @param [in] FileName the name of the file to be uploaded
    * @param [in] FileContents bytestream of a file, configuration file or resource used by the script
    *
    * @exception OpNotSucceeded : Script was not in the list
	  * @exception LicenseError : when the appropriate license is not installed
    *
    * @version release 8.2
    **/
    void UploadScriptResource(in unsigned long ScriptId, in string FileName, in ByteStream FileContents)
        raises(TimeOut, OpNotSucceeded, LicenseError);
    
    
    /** Stop a running script
    *
    * @param [in] ScriptId The ID assigned to the script
    *
    * @exception OpNotSucceeded : Script was not in the list
	  * @exception LicenseError : when the appropriate license is not installed
    *
    * @version release 8.2
    **/
    void StopScript(in unsigned long ScriptId)
        raises(TimeOut, OpNotSucceeded, LicenseError);
    
    
    /** Change the autorun property of a script, if set to true script will also start
    *
    * @param [in] ScriptId The ID assigned to the script
    * @param [in] AutoRun Set the autorun property to this value
    *
    * @exception OpNotSucceeded : Script was not in the list
	  * @exception LicenseError : when the appropriate license is not installed
    *
    * @version release 8.2
    **/
    void SetAutorunScript(in unsigned long ScriptId, in boolean AutoRun)
        raises(TimeOut, OpNotSucceeded, LicenseError);
    
    
    /** Stop all running scripts
    *
	  * @exception LicenseError : when the appropriate license is not installed
    *
    * @version release 8.2
    **/
    void StopAllScripts()
        raises(TimeOut, LicenseError);
    
    
    /** Get a logfile of an installed script
    *
    * @param [in] ScriptId The ID assigned to the script
    * @param [out] LogContents The full log of this script
    *
    * @exception OpNotSucceeded : Script was not in the list
	  * @exception LicenseError : when the appropriate license is not installed
    *
    * @version release 8.2
    **/
    void GetScriptLogfile(in unsigned long ScriptId, out string LogContents)
        raises(TimeOut, OpNotSucceeded, LicenseError);

    /// @} end of Script Engine
#endif // DISABLE_SCRIPT
#ifndef DISABLE_GBE

    /** @defgroup Anycast Redundancy
     * Contains methods to for the Anycast Redundancy feature
     * @{
     **/

    /** Set SourceIp Scheme for new TS created with IPS_OutTS_AddL().
     * 
     * @param [in] BoardNbr boardwide setting for GbE boards.
     * @param [in] UseScheme use this scheme as default or use the GbE Port Adress
     * @param [in] IP Start IP Address
     * @param [in] SubNetMask default SubNetMask, used to increment
     * 
     * @exception OpNotSupported When called for other boards than GbE ones (Main, ASI,...).
     * @exception OperationFailed In case of
     * - Invalid IPaddress (not valid IP address: IPv4 format).
     * - Invalid SubNetMask (not valid IP address, not all 1's followed by all 0's).
     * 
     * @note Incrementing is done based on the SubNetMask: 
     *       e.g. SubNetMask = 255.255.0.0, Start IP address = 192.10.0.1 => next IP address is 192.11.0.1
     *            SubNetMask = 255.255.255.255, Start IP address = 192.10.0.1 => next IP address is 192.10.0.2
     * @note IP address is not unique over different I/O boards.
     * @note only unicast host ip addresses are accepted: 1.0.0.0 to 223.255.255.255 with exception of 127.x.y.z
     */
    void OutTS_SrcAddrScheme_SetL(in unsigned short BoardNbr, in boolean UseScheme, in string IP, in string SubNetMask)
        raises(TimeOut, OperationFailed, OpNotAllowed, OpNotSupported, OpNotSucceeded);

    /** Get SourceIp Scheme for a new TS.
     * 
     * @param [in] BoardNbr boardwide setting for GbE boards.
     * @param [out] UseScheme use this scheme as default or use the GbE Port Adress
     * @param [out] IP Start IP Address
     * @param [out] SubNetMask default SubNetMask, used to increment
     * 
     * @exception OpNotSupported When called for other boards than GbE ones (Main, ASI,...).
     */
    void OutTS_SrcAddrScheme_GetL(in unsigned short BoardNbr, out boolean UseScheme, out string IP, out string SubNetMask)
        raises(TimeOut, OperationFailed, OpNotAllowed, OpNotSupported, OpNotSucceeded);

    struct RipSettings_t
    {
      boolean Enabled;             ///< Whether RIP is enabled by default for new TS's.
      unsigned short NormalMetric; ///< RIP metric to be advertised when TS is streaming and in good shape. Range [1,16], default 1.
      unsigned short AlarmMetric;  ///< RIP metric to be advertised when TS is not streaming or in bad shape. Range [1,16], default 16.
      unsigned short RouteTag;     ///< Value for the Route tag field. Range [0, 65535], default 0.
    };

    struct RipBoardSettings
    {
      RipSettings_t Defaults;
      unsigned short UpdateInterval;      ///< Update interval for RIP messages. Effective interval. Range [1, 300], default 30.
      unsigned short HoldTimeout;         ///< Time to keep advertising alarm metric after TS Loss cleared or TS removed/stopped streaming. Range[1, 1800], default 180.
    };

    /** Get the board-wide RIP settings.
     *
     * @param [in] BoardNbr
     * @param [out] Settings Currently active settings
     *
     * @exception OpNotSupported 
     * - The board is not a GbE board.
     **/
    void GetRipBoardSettings(in unsigned short BoardNbr, out RipBoardSettings Settings)
        raises(TimeOut, OperationFailed, OpNotAllowed, OpNotSupported, OpNotSucceeded);

    /** Set the board-wide RIP settings.
     *
     * @param [in] BoardNbr
     * @param [in] Settings New settings
     *
     * @exception OperationFailed 
     * - The board is not a GbE board.
     * - Any of the values is out of range.
     **/
    void SetRipBoardSettings(in unsigned short BoardNbr, in RipBoardSettings Settings)
        raises(TimeOut, OperationFailed, OpNotAllowed, OpNotSupported, OpNotSucceeded);

    struct RipInterfaceSettings
    {
      IPS_Ref_t PortRef;                  ///< PhysRef of physical/virtual interface
      string RouterAddress;               ///< Router address, one of [224.0.0.9, 224.0.0.2, 255.255.255.255, unicast address in subnet], default 224.0.0.9.
    };

    typedef sequence<RipInterfaceSettings> RipInterfaceSettingsList_t;

    /** Get the RIP Interface settings
     *
     * @param [in] BoardNbr
     * @param [in] Ports List of interfaces to request settings from
     * @param [out] Settings Settings for the given ports
     *
     * @exception OperationFailed
     * - Board is not a GbE board
     * - Invalid board or port specified.
     **/
    void GetRipInterfaceSettingsL(in unsigned short BoardNbr, in PortList_t Ports, out RipInterfaceSettingsList_t Settings)
        raises(TimeOut, OperationFailed, OpNotAllowed, OpNotSupported, OpNotSucceeded);
    /** Get the RIP Interface settings
     *
     * @param [in] BoardNbr
     * @param [in] Settings Settings for the given ports
     *
     * @exception OpNotSucceeded
     * - Board is not a GbE board
     * - Invalid board or port specified.
     * - Invalid router address
     * @exception OperationFailed
     * - Unsupported boardnr
     **/
    void SetRipInterfaceSettingsL(in unsigned short BoardNbr, in RipInterfaceSettingsList_t Settings)
        raises(TimeOut, OperationFailed, OpNotAllowed, OpNotSupported, OpNotSucceeded);

    struct RipTsSettings_t
    {
      IPS_RefTS_t TSRef;                  ///< TSRef of TS
      RipSettings_t Settings;
    };

    typedef sequence<RipTsSettings_t> RipTsSettingsList_t;
    /** Get RIP TS-specific Settings
     *
     * @param [in] BoardNbr
     * @param [in] TSRefs List of TSRefs
     * @param [out] Settings Settings for all given TSRefs
     *
     * @exception OperationFailed
     * - Board is not a GbE Board
     * - Invalid TS specified
     **/
    void GetRipTsSettingsL(in unsigned short BoardNbr, in IPS_RefTS_List_t TSRefs, out RipTsSettingsList_t Settings)
        raises(TimeOut, OperationFailed, OpNotAllowed, OpNotSupported, OpNotSucceeded);
    /** Get RIP TS-specific Settings
     *
     * @param [in] BoardNbr
     * @param [in] Settings Settings for all given TSRefs
     *
     * @exception OpNotSucceeded
     * - Board is not a GbE Board
     * - Invalid TS specified
     * - Parameters out of range
     * @exception OperationFailed
     * - Board is not a GbE Board
     * - Invalid parameters
     **/
    void SetRipTsSettingsL(in unsigned short BoardNbr, in RipTsSettingsList_t Settings)
        raises(TimeOut, OperationFailed, OpNotAllowed, OpNotSupported, OpNotSucceeded);

    // TS Loss triggers
    // At least one service
    // All services
    // more ?

    typedef octet OutputTsLossTrigger_t;
    const OutputTsLossTrigger_t OutputTS_LossTrigger_Disabled = 0;
    const OutputTsLossTrigger_t OutputTS_LossTrigger_OneService = 1;
    const OutputTsLossTrigger_t OutputTS_LossTrigger_AllServices = 2;

    /** Get the default Output TS Loss trigger
     *
     * @param [in] BoardNbr
     * @param [out] Trigger
     **/
    void GetDefaultOutputTsLossTriggers(in unsigned short BoardNbr, out OutputTsLossTrigger_t Trigger)
        raises(TimeOut, OperationFailed, OpNotAllowed, OpNotSupported, OpNotSucceeded);

    /** Set the default Output TS Loss trigger
     *
     * @param [in] BoardNbr
     * @param [in] Trigger
     **/
    void SetDefaultOutputTsLossTriggers(in unsigned short BoardNbr, in OutputTsLossTrigger_t Trigger)
        raises(TimeOut, OperationFailed, OpNotAllowed, OpNotSupported, OpNotSucceeded);

    struct OutputTsLossTriggerPerTs_t
    {
      IPS_RefTS_t TSRef;                  ///< TSRef of TS.
      OutputTsLossTrigger_t Trigger;      ///< Trigger configuration for Output TS Loss.
    };

    typedef sequence<OutputTsLossTriggerPerTs_t> OutputTsLossTriggerPerTsList_t;

    /** Get the Output TS Loss Triggers for the given TSs
     *
     * @param [in] PhysRef
     * @param [in] TSRefs List of TSs
     * @param [out] Triggers List of triggers for the given TSs
     **/
    void GetOutputTsLossTriggerL(in IPS_Ref_t PhysRef, in IPS_RefTS_List_t TSRefs, out OutputTsLossTriggerPerTsList_t Triggers)
        raises(TimeOut, OperationFailed, OpNotAllowed, OpNotSupported, OpNotSucceeded);

    /** Set the Output TS Loss Triggers for the given TSs
     *
     * @param [in] PhysRef
     * @param [in] Triggers List of triggers for the given TSs
     * 
     * @exception OperationFailed
     * - An invalid TS or port was specified.
     **/
    void SetOutputTsLossTriggerL(in IPS_Ref_t PhysRef, in OutputTsLossTriggerPerTsList_t Triggers)
        raises(TimeOut, OperationFailed, OpNotAllowed, OpNotSupported, OpNotSucceeded);


    /** Bitmap of Output TS loss triggers.
     *
     * - bit 0: indicates that one service should fail to trigger TS loss (compatible with OutputTsLossTrigger_t).
     * - bit 1: indicates that all services should be failing to trigger TS loss (compatible with OutputTsLossTrigger_t).
     * - bit 2: indicates that 'Stuffing Bitrate Too Low' can trigger TS loss (by default enabled)
     * - bit 3: indicates that 'Payload Bitrate Too Low' can trigger TS loss (by default enabled)
     * - bit 4: indicates that TS loss can be triggered by a failing GPS signal (PLL too long in holdover - by default disabled)
     * note: bit 0 and bit 1 cannot be set at the same time
     * note2: the holdover bit (bit 4) can only be set for a TS on a ASI SFN MkII board
     */
    typedef unsigned long OutputTsLossTriggerBitmap_t;

    /** Get the default Output TS Loss trigger bitmap
     *
     * @param [in] BoardNbr
     * @param [out] TriggerBitmap
     *
     * @version Supported since release 10.10
     **/
    void GetDefaultOutputTsLossTriggerBmp(in unsigned short BoardNbr, out OutputTsLossTriggerBitmap_t TriggerBitmap)
        raises(TimeOut, OperationFailed, OpNotAllowed, OpNotSupported, OpNotSucceeded);

    /** Set the default Output TS Loss trigger bitmap
     *
     * @param [in] BoardNbr
     * @param [in] TriggerBitmap
     *
     * @exception OperationFailed
     * - Undefined trigger bits were set.
     * - Both service loss bits were set (bit 0 and bit 1)
     * - The GPS Holdover trigger bit (bit 4) was set for a non-ASI SFN MkII board
     *
     * @version Supported since release 10.10
     **/
    void SetDefaultOutputTsLossTriggerBmp(in unsigned short BoardNbr, in OutputTsLossTriggerBitmap_t TriggerBitmap)
        raises(TimeOut, OperationFailed, OpNotAllowed, OpNotSupported, OpNotSucceeded);

    struct OutputTsLossTriggerBitmapPerTs_t
    {
      IPS_RefTS_t TSRef;                  	 ///< TSRef of TS.
      OutputTsLossTriggerBitmap_t TriggerBitmap;   ///< Trigger bitmap configuration for Output TS Loss.
    };

    typedef sequence<OutputTsLossTriggerBitmapPerTs_t> OutputTsLossTriggerBitmapPerTsList_t;

    /** Get the Output TS Loss Triggers for the given TSs
     *
     * @param [in] PhysRef
     * @param [in] TSRefs List of TSs
     * @param [out] TriggerBitmaps List of trigger bitmaps for the given TSs
     *
     * @note
     * - Wildcards can be used
     *      - PortNr = 0xFFFF in combination with empty TSRefs list: all TS's on all ports are processed
     *      - Empty TSRefs list: all TS's on a specified port (depending on PhysRef.PortNr) are processed
     *
     * @version Supported since release 10.10
     **/
    void GetOutputTsLossTriggerBitmapL(in IPS_Ref_t PhysRef, in IPS_RefTS_List_t TSRefs, out OutputTsLossTriggerBitmapPerTsList_t TriggerBitmaps)
        raises(TimeOut, OperationFailed, OpNotAllowed, OpNotSupported, OpNotSucceeded);

    /** Set the Output TS Loss Triggers for the given TSs
     *
     * @param [in] BoardNr
     * @param [in] TriggerBitmaps List of trigger bitmaps for the given TSs
     * 
     * @exception OperationFailed
     * - An invalid TS or port was specified.
     * - Undefined trigger bits were set.
     * - Both service loss bits were set (bit 0 and bit 1)
     * - The GPS Holdover trigger bit (bit 4) was set for a TS that is not running on a ASI SFN MkII board
     *
     * @version Supported since release 10.10
     **/
    void SetOutputTsLossTriggerBitmapL(in unsigned short BoardNr, in OutputTsLossTriggerBitmapPerTsList_t TriggerBitmaps)
        raises(TimeOut, OperationFailed, OpNotAllowed, OpNotSupported, OpNotSucceeded);


    /// @} end of Anycast Redundancy

    /** @defgroup Test idl
     * Contains methods to for engineering tests
     * @{
     **/

    /** Return an OperationFailed Exception.
    * This operation is added when adding the new exception to test this before other
    * operations start returning the exception.  
    * !!!! THIS OPERATION CAN BE REMOVED AT ANY MOMENT.
    *
    * @param [in] Type Type, represented by the first 2 bytes of the exception info
    * @param [in] Explantion Explantion, represented by the rest of the exception info
    *
    * @exception OpNotSucceeded : Script was not in the list
    *
    * @version release 8.7
    **/
    void ReturnOperationFailedException(in unsigned short Type, in string Explantion)
        raises(OperationFailed);

    /// @} end of Test idl

#endif // DISABLE_GBE

  };

  interface DeviceCallback
  {
    // CLIENT MANAGEMENT
    /////////////////////////////////////////////////////////////////////////////////////// 
    // Client Notifications functions - used to notify the client
    // ------------------------------------------------------------------------------------      

    /// A sequence of longs.
    typedef sequence<long> LongStream;

    // NOTIFICATION 

    typedef sequence<LongStream> NotifDataList;

    /** Notifies changes in the server that can be used as trigger
     *
     * @param[in] NotificationName Name of Notification type (see DCM_Notifications).
     * @param[in] EventDataList list of notifications of the given type with parameters.
     *
     * @remark This GIOP-request doesn't expect a GIOP-reply
     *
     * @exception OpNotSucceeded PhysPort does not specify a valid mgmt port
     **/
    void Notify(in string NotificationName, in NotifDataList EventDataList) 
        raises(TimeOut, OpNotSucceeded, OpNotAllowed, OpNotSupported);
  };

  
  /**
   * Description of all external notifications.
   * Notifications are sent as a sequence of notifications of the same type.
   * The data of a notification is a sequence of maximum 10 unsigned longs.
   * Here is a description of the data of each notification.
   * The name of the struct is the name of the notification.
   */
  interface DCM_Notifications
  {
    /**
     * Notification sent by MB when a new message is available (alarms)
     */
    struct Messages
    {
      unsigned long MainID;
      unsigned long BoardNr;
      unsigned long PortNr;
      unsigned long Ref;    
      unsigned long SubID1;
      unsigned long SubID2;
      unsigned long MessageNumber;
    };
    /**
     * Notification sent by IO when an alarm configured as trigger changes current state (alarms)
     * No parameters given.  The client should synchronize each time
     */
    /* No parameters left in AlarmTrigger.  empty bodies are not allowed in IDL
    struct AlarmTrigger
    {
    };
    */
    /**
     * @remark OBSOLETE, not sent anymore since DCM V5.1
     * Notification sent by MB when TSID/ONID of a TS with DVB_SCRAMBLING licenses changes.
     */
    struct DCM_TsIdOnIdChange
    {
      unsigned long bOnlyScramblingTS;      ///< boolean to notify only TS's with licenses are reported
      unsigned long BoardNr;
      unsigned long PortNr;
      unsigned long Ref;    
      unsigned long OldOnId;
      unsigned long NewOnId;
      unsigned long OldTsId;
      unsigned long NewTsId;
    };
    /**
     * @remark replaces DCM_TsIdOnIdChange, but is also sent for TS'es without DVB_SCRAMBLING licenses.
     * Notification sent when a TS is added (created on DCM) or changed (TSID/ONID, scrambable services).
     */
    struct Output_TS_Change
    {
      unsigned long BoardNr;
      unsigned long PortNr;
      unsigned long Ref;    
      unsigned long OldOnId;
      unsigned long NewOnId;
      unsigned long OldTsId;
      unsigned long NewTsId;
      unsigned long ScrambableServicesAvailable;      ///< when true, same as DCM_TsIdOnIdChange
    };
    /**
     * Notification sent when a TS is deleted (removed from DCM).
     */
    struct Output_TS_Delete
    {
      unsigned long BoardNr;
      unsigned long PortNr;
      unsigned long Ref;    
      unsigned long OnId;
      unsigned long TsId;
    };
    /**
     * Notification sent when a Table is added (starts streaming) or changed.
     */
    struct Output_SI_TableChng
    {
      unsigned long TsRef_BoardNr;
      unsigned long TsRef_PortNr;
      unsigned long TsRef_Ref;    
      unsigned long TsRef_OnId;
      unsigned long TsRef_TsId;
      unsigned long TableKey_Id;
      unsigned long TableKey_IdExt; ///< SID,.... Set to 0xFFFFFFFF when not used.
      unsigned long TableKey_OnId;  ///< Set to 0xFFFFFFFF when not used.
      unsigned long TableKey_TsId;  ///< Set to 0xFFFFFFFF when not used.
      unsigned long TableKey_Pid;   ///< Always filled in.  Only needed for AIT or tables on non-standard PID's
    };
    /**
     * Notification sent when a Table is deleted (stops streaming).
     */
    struct Output_SI_TableDel
    {
      unsigned long TsRef_BoardNr;
      unsigned long TsRef_PortNr;
      unsigned long TsRef_Ref;    
      unsigned long TsRef_OnId;
      unsigned long TsRef_TsId;
      unsigned long TableKey_Id;
      unsigned long TableKey_IdExt; ///< SID,.... Set to 0xFFFFFFFF when not used.
      unsigned long TableKey_OnId;  ///< Set to 0xFFFFFFFF when not used.
      unsigned long TableKey_TsId;  ///< Set to 0xFFFFFFFF when not used.
      unsigned long TableKey_Pid;   ///< Always filled in.  Only needed for AIT or tables on non-standard PID's
    };
    /**
     * Notification sent when settings have been changed
     * No parameters given.
     */
    /* No parameters left in SettingsChanged.  empty bodies are not allowed in IDL
    struct SettingsChanged
    {
    };
    */     
    
  };
}; 

/*
 * Local variables:
 * compile-command: "omniidl DCM.idl DCM_Types.idl && { doxygen 2>&1 | grep -Ei 'warning|error'; } && cat IDLDoxygen.warn"
 * End:
 */


